<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vector的模拟实现</title>
      <link href="/2024/12/13/cpp-vector%20implement/"/>
      <url>/2024/12/13/cpp-vector%20implement/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是vector？"><a href="#什么是vector？" class="headerlink" title="什么是vector？"></a>什么是vector？</h1><p>在C++中，vector是一个非常有用的<code>容器类</code>，用于<code>存储一组元素</code>，类似于数组。它提供了动态大小的数组功能，使得在运行时可以轻松地添加、删除和访问元素。vector是C++标准模板库（STL）的一部分，因此只需包含<code>头文件&lt;vector&gt;</code>即可使用。</p><p>vector主要有以下几种作用：</p><ol><li><p>动态大小: vector可以根据需要<code>动态增长或缩小其大小</code>。这意味着<code>不需要在创建时指定其大小</code>，而是可以在运行时根据需要添加或删除元素。</p></li><li><p>随机访问: 类似于数组可以使用<code>索引</code>来直接访问vector中的元素。</p></li><li><p>自动内存管理: vector会自动进行<code>内存管理</code>，我们也就不用担心内存分配和释放的细节。</p></li><li><p>元素操作: vector提供了许多用于操作元素的函数，例如在尾部添加元素（push_back()）、删除尾部元素（pop_back()）、插入元素（insert()）、删除指定位置元素（erase()）等等。</p></li></ol><p>一个使用vector的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector; <span class="comment">// 创建一个空的整数向量</span></span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">// 在尾部添加元素</span></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector size: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 输出元素个数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector capacity: &quot;</span> &lt;&lt; myVector.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出容量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 随机访问元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector size: <span class="number">3</span></span><br><span class="line">Vector capacity: <span class="number">4</span></span><br><span class="line">Elements: <span class="number">10</span> <span class="number">20</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><h1 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h1><h2 id="构造函数与迭代器"><a href="#构造函数与迭代器" class="headerlink" title="构造函数与迭代器"></a>构造函数与迭代器</h2><p>在C++中，vector是一个模板类（template class），它通过<code>模板参数</code>来指定所存储元素的类型。这意味着vector可以存放各种类型的值。<br>例如，如果想要存储整数类型的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; intVector; <span class="comment">// 存放整数类型的元素</span></span><br></pre></td></tr></table></figure><p>如果想存储浮点数类型的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span>&gt; floatVector; <span class="comment">// 存放浮点数类型的元素</span></span><br></pre></td></tr></table></figure><p>简而言之，vector是通过模板参数生成不同类型的容器。<br>在上面的示例中，vector的行为是相同的，只是存储的元素类型不同。模板类让我们可以轻松创建存储不同类型元素的向量容器。</p><p>vector容器类通常使用两个指针来表示元素范围，<code>start和finish</code>，即有效元素的<code>起始位置和结束位置</code>。还使用一个指针来表示内存中可用于<code>存储元素的结束位置</code>，这个指针通常称为<code>endofstorage</code>，指向存储在内存中的元素数组的指针，指向当前 vector 对象的<code>内存缓冲区的末尾位置</code>。</p><ol><li><p>start: 指向vector中的<code>第一个有效元素</code>的位置。通常，它指向存储在内存中的元素数组的首地址。</p></li><li><p>finish: 指向<code>vector中最后一个有效元素的下一个位置</code>。换句话说，它指向存储在内存中的元素数组中的下一个可用位置。</p></li><li><p>endofstorage: 指向可用存储空间的最后一个位置。</p></li></ol><blockquote><p>这三个指针共同定义了vector中存储元素的范围。有效的元素是从start指针开始，一直到finish指针之前的位置（即<code>左闭右开</code>区间）。因此，vector中的实际存储元素数量可以通过 <code>finish - start </code>来计算。<br>当添加或删除元素时，指针会<code>随之更新</code>，以反映vector中元素的当前范围。如果 vector 的元素数量超过当前内存缓冲区的容量，vector 将会重新分配<code>更大</code>的内存空间，并更新 endofstorage 指针为新内存缓冲区的末尾位置。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;   </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T* const_iterator;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">iterator _start = <span class="literal">nullptr</span>;</span><br><span class="line">iterator _finish = <span class="literal">nullptr</span>;</span><br><span class="line">iterator _endofstorage = <span class="literal">nullptr</span>;       </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//在函数后加上 const 关键字，表示这个成员函数是一个常量成员函数（const member function）。这样的设计告诉编译器这个函数不会修改类对象的成员变量。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//有参和无参构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">resize</span>(n, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; v)  </span><br><span class="line">&#123;</span><br><span class="line">_start = <span class="keyword">new</span> T[v.<span class="built_in">capacity</span>()]; <span class="comment">//C++ STL 的标准容器已经对内存管理和容量调整进行了优化，可以正确地处理不同类型的元素，包括自定义类型。所以在这里哪怕T是自定义类型也无所谓。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">_start[i] = v._start[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_finish = _start + v.<span class="built_in">size</span>();</span><br><span class="line">_endofstorage = _start + v.<span class="built_in">capacity</span>();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">_start = _finish = _endofstorage = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为篇幅较长，所以拎出来单独解释一下这个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br></pre></td></tr></table></figure><p>第一个参数是 size_t n，表示要创建的 vector 的大小，即其中包含的元素数量。第二个参数是 const T&amp; val，表示要用来初始化 vector 中元素的值，它可以作为一个常量引用来<code>接收内置类型的调用</code>，同时也可以接收自己写的类，比如上一篇文章重写的string类。</p><p>当我们使用类似 vector<int> myVector(10, 1); 这样的调用时，它是有效的，因为这其实是一个<code>隐式的类型转换</code>。<br>1 是一个整数常量，而不是 const int&amp; 类型的常量引用。然而，C++ 允许进行隐式类型转换，可以将 1 转换为 const int&amp; 类型的常量引用，以匹配构造函数的参数类型。当我们传递 1 作为第二个参数时，虽然 1 是一个<code>临时的常量值</code>，但它会被绑定到构造函数参数 const T&amp; val 上的常量引用。这样做可以延长 1 的生命周期，确保它在 vector 的构造函数中被正确使用，即在 vector 对象创建过程中可以通过常量引用访问这个值。</p><h2 id="一些其他常用的函数"><a href="#一些其他常用的函数" class="headerlink" title="一些其他常用的函数"></a>一些其他常用的函数</h2><p>其实和string类的模拟实现大差不差，就不单独一个一个的写了（懒）。<br>单独提一下insert和erase函数。<br>在 C++ STL 中，std::vector 的 insert 函数是用于在指定位置插入元素的成员函数。它<code>返回一个迭代器</code>（iterator），指向插入的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的参数如下：<br>pos：一个迭代器，表示插入元素的位置。<br>value：要插入的元素的值。<br>insert 函数的作用是将新元素插入到指定位置，它会改变 vector 的大小和容量，可能导致内部的数据重新分配。为了方便使用者处理插入后的元素，函数返回一个指向插入元素的迭代器，这样用户就可以继续对新元素进行操作，或者在需要时获取其位置或修改其值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在位置 2 插入新元素 100</span></span><br><span class="line">    <span class="keyword">auto</span> insertPos = myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">100</span>);  <span class="comment">//因为vector本质上还是顺序存储的，所以+2可以顺利读取到第三个元素，而重写list也这样简单带过就不行了，其底层逻辑是链表，到时候详细讲。</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inserted Element: &quot;</span> &lt;&lt; *insertPos &lt;&lt; std::endl; <span class="comment">// 输出：100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert和erase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_finish == _endofstorage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = pos - _start;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="built_in">capacity</span>() == <span class="number">0</span> ? <span class="number">4</span> : <span class="built_in">capacity</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决pos迭代器失效问题</span></span><br><span class="line">pos = _start + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterator end = _finish - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos)</span><br><span class="line">&#123;</span><br><span class="line">*(end + <span class="number">1</span>) = *end;</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pos = x;</span><br><span class="line">++_finish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &gt;= _start &amp;&amp; pos &lt; _finish);</span><br><span class="line"></span><br><span class="line">iterator it = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (it != _finish)</span><br><span class="line">&#123;</span><br><span class="line">*(it - <span class="number">1</span>) = *it;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--_finish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释了我提到了<code>迭代器失效</code>。为什么迭代器会失效？<br>这里的迭代器失效指的是在向 vector 中<code>插入新元素</code>后，之前的迭代器可能会变得无效。<br>在 vector 中插入元素可能会导致<code>内部数据重新分配</code>，这涉及到扩容操作。如果扩容后，原先的内存块不够存放所有元素，vector 就会在新的内存地址上<code>重新分配内存</code>，并将原先的元素复制到新的位置。这样一来，原先指向vector 中元素的迭代器就会失效，<code>因为它们指向了之前的内存地址，而这些地址现在已经不再有效</code>。</p><p>为了解决这个问题，首先会检查插入新元素后是否需要扩容。如果需要扩容，就会重新分配更大的内存块，并将原先的元素复制到新的位置。然后，为了使原先的迭代器仍然有效，会将 pos 这个迭代器重新设置为插入元素后的位置，即 _start + len。这样一来，之前的迭代器 pos 就仍然指向正确的位置，不会失效。</p><p>其他的一些函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(vector&lt;T&gt; v)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_start, v._start);</span><br><span class="line">std::<span class="built_in">swap</span>(_finish, v._finish);</span><br><span class="line">std::<span class="built_in">swap</span>(_endofstorage, v._endofstorage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="built_in">capacity</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="built_in">size</span>();</span><br><span class="line">T* tmp = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="keyword">if</span> (_start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp[i] = _start[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_start = tmp;</span><br><span class="line">_finish = _start + sz;</span><br><span class="line">_endofstorage = _start + n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; val = T())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">_finish = _start + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_finish != _start + n)</span><br><span class="line">&#123;</span><br><span class="line">*_finish = val;</span><br><span class="line">++_finish;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _endofstorage - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; <span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _start[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; <span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _start[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些碎碎念</title>
      <link href="/2024/11/06/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2024/11/06/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于c++的inline关键字,以下说法正确的是( ) </p></blockquote><p>A.使用inline关键字的函数会被编译器在调用处展开<br>B.头文件中可以包含inline函数的声明<br>C.可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数<br>D.递归函数也都可以成为inline函数</p><p>A.inline只是一种建议，需要看此函数是否能够成为内联函数，具体看编译器。</p><p>B. inline函数<code>不支持声明和定义分离</code>，编译器一旦将一个函数作为内联函数处理，就会在调用位置展开，即该函数是<code>没有地址</code>的，也不能在其他源文件中调用，故一般都是直接在源文件中定义内联函数的。</p><p>C.inline函数会在调用的地方展开，所以符号表中不会有inline函数的符号名，不存在链接冲突。</p><p>D.比较长的函数，递归函数就算定义为inline，也会被编译器忽略。</p><p>故选C。</p><blockquote><p>下面描述错误的是( )</p></blockquote><p>A.this指针是非静态成员函数的隐含形参.<br>B.每个非静态的成员函数都有一个this指针.<br>C.this指针是存在对象里面的.<br>D.this指针可以为空</p><p>A.静态成员函数没有this指针，只有非静态成员函数才有，且为隐藏指针。</p><p>B.非静态成员函数的第一个参数就是隐藏的this指针。</p><p>C.this指针在非静态的成员函数里面，对象的内存布局中并没有一个专门的字段用来存储this指针。this指针在成员函数被调用时，指向调用该成员函数的对象。</p><p>D.单纯的对this赋空是不可以的，但可以强转直接赋空(不建议)。</p><p>故选C。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
            <tag> 易错点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>木星卫星上可能存在生命</title>
      <link href="/2024/11/06/Life%20may%20exist%20on%20Jupiter/"/>
      <url>/2024/11/06/Life%20may%20exist%20on%20Jupiter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>经济学人-科技</p></blockquote><h1 id="木星卫星上可能存在生命-上"><a href="#木星卫星上可能存在生命-上" class="headerlink" title="木星卫星上可能存在生命(上)"></a>木星卫星上可能存在生命(上)</h1><p><em><strong>506词</strong></em><br>Besides Earth itself, Mars is the most-studied planet in the <code>solar</code>(adj.太阳的;日光的;利用太阳光的;与太阳相关的n.日光浴室)system.<br>除了地球，火星是太阳系中研究最多的行星。<br>One reason for the abundance (n. 大量,充足) of probes and landers, of course, is that Mars is relatively (adv.<br>相对地,比较而言;相当 相对来说;相比较而言)close.<br>探测器和着陆器数量众多的原因之一当然是火星距离地球相对较近<br>Another is that Mars appears to have once had plenty of liquid(adj.液体的;清澈的;明亮的;易变的n.液体，流体;[语]流音) water on its surface(n.表面;外观;表层 adj.表面的，肤浅的).另一个原因是火星表面似乎曾经有大量液态水。<br>And where there is water, astrobiologists whisper(n.私语;谣传;飒飒的声音 v.耳语;密谈;飒飒地响) about thepossibility(n.可能;可能性;可能的事情;潜在的价值)oflife.<br>而哪里有水，天体生物学家就会悄悄谈论生命存在的可能性。<br>But Mars and Earth are not the only places in the solar system that either have, or have had, water但火星和地球并不是太阳系中唯一有水或曾经有水的地方。<br>On October 14th a NASA probe (n.探针;调查 vi.调查;探测) called Europa Clipper blasted off from Florida10月14日，美国宇航局的“欧罗巴快船”号探测器从佛罗里达州发射升空。<br>As its name suggests, the mission’s target is Europa, one of the biggest of jupiter’s 95 known moonsEuropa is a snowball slightly smaller than Earth’s moon.<br>顾名思义，该任务的目标是欧罗巴，它是木星95颗已知卫星中最大的卫星之一。欧罗巴是一个比月球略小的雪球。<br>It has an atmosphere (n.大气;空气;气氛;气压)that is thin(adj.薄的;瘦的;稀薄的;微弱的v.使淡;使瘦;使稀疏) to the point of non-existence,a crust(n.面包皮;外壳;坚硬外皮 .结硬皮;结成外壳) of water ice and asurface temperature (n.温度, 气温 高烧,发烧,发热) of around -180°C.<br>它的大气层稀薄到几乎不存在，地壳由水冰组成，表面温度约为-180°C<br>But scientists (n.科学家) think a vast(adj.巨大的;广阔的;大量的;巨额的 n.浩瀚;广阔无垠的空间)ocean existsbeneath (prep.在…之下 adv. 在下方) the ice, kept liquid by friction (n.摩擦，摩擦力)produced as Europa iskneaded by Jupiter’s powerful gravity(n.重力，地心引力;庄严;严重性).<br>但科学家认为，冰层之下存在着一片浩瀚的海洋，欧罗巴在木星强大的引力作用下产生摩擦，使之保持液态。<br>Over the past few decades scientists have become steadily more excited (adi. 激动的;兴奋的;活跃的 v. 激动;唤起(excite的过去分词))about the life-bearing potential(adj,潜在的,有可能的n.潜力;电位;电势;可能性) ofsuch “icy moons”.<br>在过去的几十年里，科学家们对这种“冰卫星”孕育生命的可能性越来越感兴趣<br>Besides Europa, these include Ganymede and Callisto, two other Jovian moons; Enceladus, which orbits (r轨道;眼眶;势力范围;生活常规 v.盘旋;绕轨道运行)Saturn; and Triton,the biggest satellite(n.卫星人造卫星卫星国,附庸国,卫星都市) of Neptune.<br>除了欧罗巴，这些卫星还包括:另外两颗木星卫星木卫三和木卫四;绕土星运行的土卫二;海王星最大的卫星海卫一。<br>Europa’s icy crust is thought to be tens of kilometres (n.千米,公里)thick (adj. 厚的;浓密的;粗的;愚笨的).Europa Clipperwill, therefore, not be able to tell whether there actually are any aliens swimming around inthe depths(n.深度;深奥).<br>欧罗巴的冰壳被认为有数十公里厚。因此，欧罗巴快船将无法判断是否真的有外星人在深处游动。<br>Instead, its job is to assess (vt. 评定;估价;对..征税) whether the moon is the sort of place where life mightplausibly arise(v.发生;产生;出现;起身，起来;起床).<br>相反，它的工作是评估这颗卫星是否是生命可能出现的地方<br>One of the probe’s tasks will be to characterise the size and saltiness of the ocean.探测器的任务之一是描述海洋的大小和盐度，<br>NASA’s present best guess is that it varies from 60km to 150km deep.<br>美国宇航局目前最好的猜测是，海洋深度从60公里到150公里不等<br>lf that is right, then, despite its small size, Europa would have about twice as much liquid water as Earthdoes.<br>如果这是正确的，那么尽管欧罗巴体积很小，但其液态水量却是地球的两倍<br>But although water is thought to be extremely useful (adj. 有用的，有益的;有帮助的)(and possibly even vita(adj.生死攸关的;至关重要的;有活力的))to the development of life,it is not enough on its own.但是，尽管人们认为水对生命的发展极其有用(甚至可能至关重要)，但仅靠水是不够的。<br>To qualify (vt.使具有资格;证明..合格;限制 v.取得资格，有资格) as habitable(adj.适于居住的),a world needsenough other elements to allow complex(adj.复杂的;合成的 n.复合体;综合设施)chemistry(n.化学).要成为宜居星球，一个星球需要足够多的其他元素才能进行复杂的化学反应。<br>Besides the hydrogen (n.氢) and oxygen (n.氧气，氧) in water, a common shortlist (vt.把.….列入决选名单) addscarbon (n.碳;碳棒;复写纸 adj.碳的;碳处理的),nitrogen (n.[化]氮),phosphorus (n.磷) and sulphur(n.[化]硫磺;硫磺色 vt.用硫磺处理;使硫化).<br>除了水中的氢和氧之外，常见的元素还包括碳、氮、磷和硫。<br>All of these have already been found on a different icy moon-Enceladus.所有这些都已在另一颗冰卫星土卫二上发现，<br>On Enceladus, plumes (vt. 用羽毛装饰 n. 羽毛) of ocean water jet out into space through cracks in the crust.在土卫二上，海水羽流通过地壳裂缝喷入太空，<br>In 2008 Cassini, another American spacecraft (n. 字宙飞船), flew straight through one of those plumes,discovering six of the elements on the astrobiological list.2008年，另一艘美国航天器卡西尼号直接飞过其中一个羽流，发现了天体生物学名单上的六种元素<br>Whether such plumes exist on Europa is an open question, says Robert Pappalardo, Europa Clipper’s chiefscientist.<br>欧罗巴快船首席科学家罗伯特·帕帕拉多(Robert Pappalardo)表示，欧罗巴上是否存在这样的羽流仍是一个悬而未决的问题。<br>Europa’s ice shell (n.壳，贝壳;外形;炮弹 vi.剥落;[计]设定命令行解释器的位置) is much thicker than Enceladus’she says, which makes it less likely that surface cracks or fissures would reach all the way to the ocean.他说，欧罗巴的冰壳比土卫二的厚得多，因此表面裂缝不太可能一直延伸到海洋。<br>Some tantalising-but uncertain-images from telescopes (n.望远镜v. 缩短;压缩;套叠) nevertheless (adv. 仍然然而,不过 coni. 尽管如此,然而) show things that look plume-like.<br>一些令人着迷但不确定的望远镜图像显示了类似羽状的东西。<br>But follow-up observations (n.观察;观察力;注意;评论) with the space-based James Webb Space Telescope have so far failed to spot any.但太空中的詹姆斯·韦布空间望远镜的后续观测迄今为止未能发现任何羽状物.</p><h1 id="木星卫星上可能存在生命-下"><a href="#木星卫星上可能存在生命-下" class="headerlink" title="木星卫星上可能存在生命(下)"></a>木星卫星上可能存在生命(下)</h1><p><em><strong>447词</strong></em><br>If plumes (n.李子;洋李;紫红色;梅子 adj.人所希望的;有利的;上等的) do not exist,then Europa Clipperwill haveto content itself with examining (vt.调查;考试;检査;[计算机]检测 vi.检查;调查)the moon’s surface(n.表面;外观;表层 adj.表面的，肤浅的).<br>如果不存在羽状物，那么欧罗巴快船就只能满足于检测卫星表面，<br>That surface is notably(adv.显著地;尤其)smooth(adj.光滑的;顺利的;平稳的 .使光滑;缓和;消除(障碍等);使优雅) and relatively(adv.相对地,比较而言;相当 相对来说;相比较而言)free from impact craters,which suggestsit is regularly renewed by processes a bit like plate tectonics on Earth.欧罗巴表面非常光滑，相对没有撞击坑，这表明它定期通过类似地球板块构造的过程进行更新。<br>That, in turn, suggests that chemicals that form on Europa’s surface might have a way down to the ocean,and vice (n,堕落，恶习;(尤指与性或毒品有关的)罪行，道德败坏行为;老虎钳 pref,副职的;副的)versa.这反过来又表明，欧罗巴表面形成的化学物质可能有通往海洋的途径，反之亦然。<br>Studying Europa’s surface mav, therefore, qive valuable (adi.贵重的;有价值的;可估价的n. 贵重物品) clues asto what lies beneath(prep.在…之下 adv. 在下方).因此，研究欧罗巴表面可能会为了解其下方情况提供有价值的线索。<br>The final ingredient (n.混合物的组成部分;配料) for a habitable (adj. 适于居住的) world is a source of energy forife to exploit(vt.开发，开拓;剥削;开采 n.勋绩;功绩).<br>宜居世界的最后一个要素是可供生命利用的能量来源。<br>Whatever that might be on Europa-far from the Sun, and beneath kilometres (n, 千米,公里) of ice-it will notbe sunlight. That is a bit of a problem.<br>欧罗巴远离太阳，在数公里厚的冰层之下，因此，无论欧罗巴上有什么，它都不会有阳光。这有点问题<br>On Earth almost every living thing ultimately (ady,最后:最终) depends (yi, 依赖，依靠;相信，信赖;取决干) onphotosynthesis for its energy, including the rich ecosystems (n. 生态系统) in the ocean depths (n. 深度;深奥),discovered in the 1980s and which helped the idea of life on Europa gain (n.收获;增加;利润 v.获得;增加;<br>赚到) a foothold(n.立足处;据点).在地球上，几乎所有生物最终都依赖光合作用获取能量，包括20世纪80年代发现的丰富的海洋深处生态系统，这有助于欧罗巴上存在生命的观点获得立足点。<br>Their inhabitants (n, 居民) do not benefit from sunlight directlv, but their metabolisms (n, 新陈代谢) arepowered by chemicals created in the photosynthesising, oxygen-rich surface oceans far above.那里的居民并不直接受益于阳光，但他们的新陈代谢是由远在天上、进行光合作用、氧气丰富的海洋表面产生的化学物质提供能量的。<br>There’s none of that on Europa. But there does not have to be欧罗巴上没有这些。但也不一定要有。<br>Some of the microbes living in fissures in the earth’s sea bed make use of chemicals that come entirelyfrom below, rather than above.<br>一些生活在地球海床裂缝中的微生物利用完全来自下方而不是上方的化学物质<br>It is a scant (adj.不足的;缺乏的;勉强够的 vt.减少;节省;限制)source of energy, but areal one. And Europamight offer much the same.<br>这是一种稀少的能量来源，但却是真实存在的。欧罗巴可能也提供类似的能量<br>Analysing (vt. 分析;分解;细察) Europa’s surface chemistry (n. 化学) may give clues as to whether somethingsimilar could, at least in principle (n.原理;原则;主义;信念),be happening on its ocean floor分析欧罗巴的表面化学成分可能会提供线索，说明类似的事情是否至少在原则上可能发生在其海底。<br>And Europa Clipperwil not be the only probe (n. 探针;调查 vi. 调查;探测) hanging out at Jupiter.欧罗巴快船将不是唯一在木星上停留的探测器<br>_ast year saw the launch (vt.发射(导弹、火箭等);发起，发动;使….下水 v.下水;开始;起飞)ofa Europeanprobe called the Jupiter lcy Moons Explorer(n.探测者，探测器;探险家)(JUICE(n.果汁;(水果)汁，液))<br>去年，欧洲发射了一个名为木星冰卫星探测器(JUICE)的探测器。<br>It will likewise (adv, 也; 同样地) examine Europa, as well as Callisto and Ganymede, two other moons that arealso thought to have oceans.<br>它还将研究欧罗巴，以及另外两颗被认为也拥有海洋的卫星木卫四和木卫三<br>The vagaries of orbital (adj. 轨道的;眼窝的) mechanics mean that, despite its later departure (n.离开,离去)Europa Clipperwill arrive in 2030, a year before JUlCE.<br>轨道力学的变化意味着，尽管欧罗巴快船较晚离开，但它将于2030年抵达，比JUICE早一年。<br>If the findings from the two missions are sufficiently (ady,足够地,充分地)exciting (adi,使人激动的;令人兴奋的 v激动;唤起;刺激(excite的ing形式)),then the next step could be to send alander.如果这两次任务的发现足够令人兴奋，那么下一步可能是发射着陆器。<br>Scouting for landing sites on Europa is another of Europa Clipper’s goals.<br>寻找欧罗巴上的着陆点是欧罗巴快船的另一个目标。<br>But the probe will not be able to build a perfect map of the moon’s surface.<br>但探测器无法绘制出完美的月球表面地图。<br>Jupiter’s powerful maqnetic (adi.有吸引力的;有磁性的;地磁的) field produces areas of intense (adi. 强烈的;紧张的;热情的;非常的)radiation(n.辐射能;放射 放射物) near the planet, enough to fry any spacecraft (n.宇宙飞船) that dingers (vi. 逗留, 徘徊 缓慢消失) too long.<br>木星强大的磁场在木星附近产生强烈辐射区，足以摧毁任何停留时间过长的航天器，<br>Europa Clipper wil, instead, make 49 looping flybys, gathering as much data as possible each time beforeretreating to a safe distance.<br>相反，欧罗巴快船将进行49次循环飞行，每次在撤退到安全距离之前收集尽可能多的数据，<br>The world’s alien-hunters will be hoping it survives.<br>全世界的外星人猎人都希望它能幸存下来。</p>]]></content>
      
      
      <categories>
          
          <category> 经济学人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学人2024 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类的模拟实现</title>
      <link href="/2024/11/04/cpp-String%20implement/"/>
      <url>/2024/11/04/cpp-String%20implement/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近学到了string的相关的库，于是为了加深对函数的理解便打算模拟实现一下常用的string库函数。</p></blockquote><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>这是一个简单的string类的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The length of the string is: &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上可见，string类是C++标准库中的一个类，它定义在<code>std命名空间</code>中。因此，当使用string类时，需要指定其命名空间为std，若未定义，则可能被认为是未定义的标识符，从而导致错误。</p><blockquote><p>std是C++标准库中定义的命名空间，它包含了许多C++标准库中的类、函数和类型定义。在C++中，命名空间提供了一种将名称隔离开来以<code>避免名称冲突</code>的机制。这样，不同库中的同名函数或类就可以在同一个程序中共存，而不会发生冲突。</p></blockquote><p>所以我想进行模拟的string类实现，为了避免与std的string类冲突，就自定义了一个新的namespace——newstring。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> newstring &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line"><span class="type">size_t</span> _capacity;</span><br><span class="line"><span class="type">char</span>* _str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在newstring这块命名空间中，我创建了自己的string类，有三个基本元素：</p><ol><li>字符串_str</li><li>容量_capacity</li><li>目前大小_size</li></ol><p>设置容量和大小的目的主要是为了方便内存的管理，同时需要注意，字符串虽然是以’\0’结尾，但在string类中，是否结束的标志是size。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;123\\01212121&quot;</span>;</span><br><span class="line">   <span class="type">size_t</span> len = str<span class="number">1.</span><span class="built_in">size</span>(); <span class="comment">// 获取字符串的长度，不包括 null 结尾符</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> c : str1) &#123; <span class="comment">// 遍历字符串，包括 null 字符和换行符</span></span><br><span class="line">       std::cout &lt;&lt; c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上，输出的结果是123\01212121，并没有遇到\0就终止。</p><h1 id="函数模拟实现"><a href="#函数模拟实现" class="headerlink" title="函数模拟实现"></a>函数模拟实现</h1><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>首先要实现的是构造和析构函数，其重要性不必多说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">_capacity = _size;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[_size + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(_str, str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">string</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = <span class="literal">nullptr</span>;</span><br><span class="line">_size = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里还有一点要注意，虽然常见的输入都是以’\0’为结尾的字符串，但有时候仍然会遇见<br>中间出现’\0’的串，这时使用这里的构造函数就会出现问题了。</p></blockquote><p>比如，一个串为”hello\0world”,在进行strcpy时就只会copy到<code>第一个遇到的\0</code>为止，后面的内容就会遗失，所以为了避免这种情况，可以考虑将strcpy换成<code>memcpy</code>。</p><p>不清楚的可以看下这里的对比分析。</p><p>strcpy 和 memcpy 都是 C&#x2F;C++ 中常用的<code>字符串/内存拷贝</code>函数。<br>strcpy 函数用于将一个以 <code>null</code> 结尾的字符串从源地址拷贝到目标地址，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，dest 是<code>目标地址</code>，src 是<code>源地址</code>。strcpy 函数会将源地址（包括 null 结尾符）中的所有字符拷贝到目标地址中，并<code>返回目标地址的指针</code>。strcpy 函数<code>不会检查目标地址是否有足够的空间</code>来存储源地址中的所有字符，如果目标地址不够大，可能会导致内存溢出和程序崩溃的问题。</p><p>例如，下面的代码使用 strcpy 函数将字符串 “Hello, world!” 拷贝到字符数组 str 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>memcpy 函数用于将<code>指定长度的内存块</code>从源地址拷贝到目标地址，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，dest 是目标地址，src 是源地址，count 是要拷贝的字节数。memcpy 函数会将源地址中的指定长度的内存块拷贝到目标地址中，并返回目标地址的指针。与 strcpy 不同，memcpy 函数<code>不会自动添加 null 结尾符</code>，而且要求目标地址有足够的空间来存储拷贝的数据。</p><p>例如，下面的代码使用 memcpy 函数将长度为 10 的内存块从数组 src 中拷贝到数组 dest 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> src[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dest, src, <span class="built_in">sizeof</span>(src));</span><br></pre></td></tr></table></figure><p>下面这一点非常重要！</p><blockquote><p>由于 memcpy 函数<code>不会自动添加 null 结尾符</code>，如果使用 memcpy 函数拷贝字符串时，需要手动添加 null 结尾符，例如：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span>* src = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(str, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>); <span class="comment">//将原字符串带的\0一起复制到新的空间。</span></span><br></pre></td></tr></table></figure><h2 id="snowflake-获取其长度，容量，内容"><a href="#snowflake-获取其长度，容量，内容" class="headerlink" title=":snowflake:获取其长度，容量，内容"></a>:snowflake:获取其长度，容量，内容</h2><p>由于是自定义的类，无法直接使用cout来输出，那么就可以考虑实现c_str来获取字符串内容。长度和容量由于在其他函数中复用很多，也就一并拿出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 获取字符串长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">//这里的 const 表示该成员函数是一个常量成员函数。这意味着它不会修改类的任何成员变量。因此，这个成员函数可以在常量对象上被调用，也可以在被声明为 const 的对象指针或引用上被调用。</span></span><br><span class="line"><span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串容量</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串内容</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">//这里的 const 表示返回的指针指向的字符数组是常量，即通过这个指针不能修改字符数组的内容。</span></span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="reserve函数"><a href="#reserve函数" class="headerlink" title="reserve函数"></a>reserve函数</h2><p>reserve 函数用于为<code>字符串预分配内存空间</code>，以提高字符串操作的效率和性能。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(size_type new_cap)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，new_cap 是要预分配的内存空间大小，以字节为单位。reserve 函数会尝试为字符串分配至少 new_cap 个字节的内存空间，如果当前已经分配的内存空间足够大，则不会进行分配，如果分配失败，则会抛出 <code>std::bad_alloc</code> 异常。</p><p>下面的代码使用 reserve 函数为字符串 str 预分配 100 个字节的内存空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">str.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>调用reserve函数仅仅是为字符串预分配内存空间，并<code>不会改变字符串的长度</code>。如果要修改字符串的长度，可以使用 resize 函数或者直接对字符串进行赋值操作。<br>另外，由于 C++ STL 中的 std::string 类已经封装了内存管理的细节，因此在大多数情况下不需要手动调用 reserve 函数进行内存管理，只需要使用字符串类提供的成员函数和操作符即可。只有在特殊的性能优化或者内存限制的情况下，才需要手动调用 reserve 函数。</p><p>模拟实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; _capacity) <span class="comment">//只有当预留空间大于当前分配空间才会进行</span></span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">//核心思路就是开辟一个新的空间，让旧指针指向他</span></span><br><span class="line"><span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(tmp, _str);</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = tmp;</span><br><span class="line">_capacity = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="push-back和append函数"><a href="#push-back和append函数" class="headerlink" title="push_back和append函数"></a>push_back和append函数</h2><p>push_back 和 append用于向字符串<code>末尾</code>添加新的字符或字符串。它们的区别和用法如下：</p><h3 id="cyclone-push-back"><a href="#cyclone-push-back" class="headerlink" title=":cyclone:push_back"></a>:cyclone:push_back</h3><p>push_back 函数用于向字符串末尾添加<code>一个字符</code>。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，ch 是要添加的字符。例如，下面的代码使用 push_back 函数向字符串 str 中添加字符 ‘a’：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，push_back 函数将字符 ‘a’ 添加到字符串 str 的末尾。<br>模拟实现为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2倍扩容</span></span><br><span class="line"><span class="built_in">reserve</span>(_capacity == <span class="number">0</span> ? <span class="number">4</span> : _capacity * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_str[_size] = ch;</span><br><span class="line"></span><br><span class="line">++_size;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//不要忘记\0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>append 函数用于向字符串末尾添加<code>一个字符串</code>。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> basic_string&amp; str)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，str 是要添加的字符串，s 是要添加的字符数组，n 是要添加的字符个数，c 是要添加的字符。例如，下面的代码使用 append 函数向字符串 str 中添加一个字符串和一个字符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot; - C++&quot;</span>, <span class="number">5</span>).<span class="built_in">append</span>(<span class="number">1</span>, <span class="string">&#x27;!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，append 函数先将字符串 “ - C++” 中的前 5 个字符（即 “ - C”）添加到字符串 str 的末尾，然后再将字符 ‘!’ 添加到字符串 str 的末尾。<br>append 函数可以一次性向字符串中添加多个字符和字符串，比 push_back 函数更加灵活。</p><p>模拟实现为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 至少扩容到_size + len</span></span><br><span class="line"><span class="built_in">reserve</span>(_size + len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(_str + _size, str);</span><br><span class="line">_size += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="+&#x3D;操作符"></a>+&#x3D;操作符</h2><p>有了append和push_back，+&#x3D;直接复用就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(ch);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str)  <span class="comment">//思考为什么要加const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">append</span>(str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二个函数如果去掉const，使用str+&#x3D;”abc”这样的语句，编译器会报错:没有与这些操作数匹配的 “+&#x3D;” 运算符。原因是”abc”的类型是const char，同时被<code>隐式转换为const char*</code>，参数却希望接受char*，这样的结果当然是编译器所不希望的，也就是所谓的权限放大。明明是不可以更改的常量串，传个参还变成可更改了，这自然不被允许。</p></blockquote><h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2><p>insert用于向字符串中插入字符或字符串。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> basic_string&amp; str)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> basic_string&amp; str, size_type subpos, size_type sublen)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> <span class="type">char</span>* s, size_type n)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, size_type n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator p, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator p, size_type n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator p, InputIt first, InputIt last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 是要插入的位置，str 是要插入的字符串，subpos 和 sublen 是要插入的子字符串的起始位置和长度，s 是要插入的字符数组，n 是要插入的字符个数，c 是要插入的字符，p 是要插入的位置，first 和 last 是要插入的字符序列的起始和结束迭代器。</p><p>在指定位置插入一个字符或一个字符序列。<br>例如，下面的代码使用 insert 函数在字符串 str 的第 5 个位置插入字符 ‘a’：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，insert 函数将字符 ‘a’ 插入到字符串 str 的第 5 个位置。</p><p>insert 函数还可以插入一个字符序列，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot; - C++&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，insert 函数将字符串 “ - C++” 插入到字符串 str 的第 5 个位置。</p><p>常用的也就是上面两种。<br>模拟实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_size + n &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 至少扩容到_size + len</span></span><br><span class="line"><span class="built_in">reserve</span>(_size + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end = _size;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos &amp;&amp; end&lt;_size)<span class="comment">//重要的地方</span></span><br><span class="line">&#123;</span><br><span class="line">_str[end + n] = _str[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos + i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_size += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* str)</span>  <span class="comment">//同理要加const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 至少扩容到_size + len</span></span><br><span class="line"><span class="built_in">reserve</span>(_size + len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end = _size;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos &amp;&amp; end != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">_str[end + len] = _str[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos + i] = str[i]; <span class="comment">//别写成了_sre[end]，此时enb比pos还小1</span></span><br><span class="line">&#125;   <span class="comment">//不用for循环同样可以用memcpy或者strcpy，</span></span><br><span class="line">    <span class="comment">//示例:memcpy(_str + pos, str, len);</span></span><br><span class="line"></span><br><span class="line">_size += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert的模拟实现就是先判定空间是否够大，不够大就扩容，然后把插入位置pos后面的元素都往后挪n个位置，再回到pos插入指定的元素。</p><blockquote><p>while (end &gt;&#x3D; pos &amp;&amp; end&lt;&#x3D;_size)</p></blockquote><p>这个地方单独提一下，因为end存在减为0继续减到-1的情况，但这里end是size_t类型，是一个<code>无符号整型</code>，当0再减1时，end就变成了一个<code>极大数</code>，此时需要end&lt;&#x3D;_size来终止循环。</p><h2 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h2><p>find用于在字符串中查找指定子串的位置。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> basic_string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>其中，str 是要查找的子串，s 是要查找的字符数组，n 是要查找的字符个数，c 是要查找的字符，pos 是查找起始位置。具体用法如下：</p><p>查找指定字符串在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找子串 “world” 的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，find 函数查找字符串 “world” 在字符串 str 中第一次出现的位置，并将其返回。如果字符串 “world” 不在字符串 str 中，find 函数将返回 std::string::npos。</p><p>查找指定字符数组在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找字符数组 “world” 的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，find 函数在字符串 str 的第 7 个位置开始查找字符数组 “world” 的前 5 个字符，并将其返回。如果字符数组 “world” 不在字符串 str 中，find 函数将返回 std::string::npos。</p><p>查找指定字符在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找字符 ‘o’ 的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，find 函数在字符串 str 的第 5 个位置开始查找字符 ‘o’ 的位置，并将其返回。如果字符 ‘o’ 不在字符串 str 中，find 函数将返回 std::string::npos。</p><blockquote><p>在string类中存在<code>npos</code>这个<code>特殊的常量</code>。在字符串操作中，通常使用 find 等函数来查找指定子串或字符在原字符串中的位置。如果查找失败，这些函数会<code>返回一个特殊的值 npos</code>，以表示查找失败的情况。</p></blockquote><p>以下是两种常用形式的模拟实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> ch, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = pos; i &lt; _size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_str[i] == ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//也可以是npos，不过需要自己新定义一个，npos 是 std::string::npos 的一个静态成员变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = <span class="built_in">strstr</span>(_str + pos, str); <span class="comment">//strstr 是 C 语言标准库中的一个函数，用于在一个字符串中查找另一个字符串的第一次出现位置。</span></span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ptr - _str; <span class="comment">//返回偏移量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重要必看-substr函数"><a href="#重要必看-substr函数" class="headerlink" title="(重要必看)substr函数"></a>(重要必看)substr函数</h2><p>substr用于从一个字符串中提取子串。其函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> count = npos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 是子串的起始位置，count 是子串的长度。如果省略 count 参数，则返回从 pos 开始到字符串末尾的所有字符。如果 pos 大于等于字符串的长度，或者 count 为 0，那么函数返回一个空字符串。</p><p>下面是一个使用 substr 函数提取子串的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>);  <span class="comment">// 从位置 7 开始提取长度为 5 的子串</span></span><br><span class="line">    std::cout &lt;&lt; sub &lt;&lt; std::endl;  <span class="comment">// 输出 &quot;world&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，substr 函数从字符串 str 中提取了一个子串，其起始位置是 7，长度是 5。提取出的子串是 “world”，并赋值给了变量 sub。<br>模拟实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line"><span class="type">size_t</span> n = length;</span><br><span class="line"><span class="keyword">if</span> (pos + length &gt; size)</span><br><span class="line">n = size - pos;</span><br><span class="line">string tmp;</span><br><span class="line"><span class="type">char</span>* s = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];</span><br><span class="line">tmp._str = s;</span><br><span class="line">tmp._capacity = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">tmp += _str[pos + i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里有几个需要注意的点。第一是string tmp并未传入参数，所以此处调用<code>无参构造</code>。而上文还未实现无参构造。第二，return时会调用拷贝构造函数，上文也没写拷贝构造。</p></blockquote><p><em><strong>敲重点！非常重要</strong></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value) &#123;&#125; <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">data</span>(other.data) &#123;&#125; <span class="comment">// 拷贝构造函数  </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> data;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用构造函数  </span></span><br><span class="line">MyClass* objPtr = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">20</span>); <span class="comment">// 调用构造函数，在堆上创建对象并初始化data为20</span></span><br><span class="line">MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数，创建obj2作为obj1的副本  </span></span><br><span class="line"><span class="function">MyClass <span class="title">obj3</span><span class="params">(obj1)</span></span>; <span class="comment">// 同样调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>return时返回类型是string，所以该返回一份副本，应该调用拷贝构造函数。如果是引用或者指针的形式，就不会创建副本，也就不会调用拷贝构造，但这个行为非常危险！</p><p>完善无参构造与拷贝构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">string</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">capacity</span>(<span class="number">0</span>),_str(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数  </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; other) &#123;</span><br><span class="line">size = other.size;</span><br><span class="line">capacity = other.capacity;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[capacity + <span class="number">1</span>];</span><br><span class="line">std::<span class="built_in">memcpy</span>(_str, other._str, size + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>因为是自己实现的类，所以如果要用到范围for这样的代码，就得自己实现迭代器。注意有无const的情况最好都写一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">//必须要加const，单纯返回类型不一致无法构成重载！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//同理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用范围for等需要迭代器的用法了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : s1) &#123;</span><br><span class="line">       std::cout &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果你的类支持正向遍历和反向遍历，你可能需要实现两个迭代器：一个<code>正向迭代器和一个反向迭代器</code>。</p><p>一旦你实现了迭代器，你的自定义类就可以像标准容器一样使用范围for语句了。在范围for语句中，你需要使用 <code>begin() </code>方法返回你的类的起始迭代器，使用<code>end()</code> 方法返回你的类的结束迭代器。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回正向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回正向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">ReverseIterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回反向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">ReverseIterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回反向迭代器 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyContainer container;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : container) &#123;</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : std::<span class="built_in">reverse</span>(container)) &#123;</span><br><span class="line">    <span class="comment">// 反向遍历元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h2><p>resize() 是 C++ 标准库中容器和字符串类中的一个成员函数，用于改变容器或字符串的大小。<br>resize() 会<code>改变容器中元素的个数</code>。<br>对容器而言：</p><ol><li>如果新的大小<code>小于</code>当前大小，那么超出新大小的元素将被截断；</li><li>如果新的大小<code>大于</code>当前大小，那么容器将增加新元素，并使用默认构造函数初始化这些新元素。</li></ol><p>对于字符串：</p><ol><li>如果新的大小<code>小于</code>当前大小，那么超出新大小的字符将被截断；</li><li>如果新的大小<code>大于</code>当前大小，那么字符串将增加新字符，并使用<code> &#39;\0&#39; 字符</code>填充这些新字符。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> ch = <span class="string">&#x27;\0&#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; _size)</span><br><span class="line">&#123;</span><br><span class="line">_size = n;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = _size; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_size = n;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些运算符"><a href="#一些运算符" class="headerlink" title="一些运算符"></a>一些运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">memcmp</span>(_str, s._str, _size &lt; s._size ? _size : s._size); <span class="comment">//第三个参数确定要比较的字节数</span></span><br><span class="line"><span class="comment">//_str比s._str大则返回正数，小则返回负数，相等则返回0</span></span><br><span class="line"><span class="keyword">return</span> ret == <span class="number">0</span> ? _size &lt; s._size : ret &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 const 修饰的是<code>函数参数 s</code>，表示该参数是一个常量引用，避免了对参数进行修改。而第二个 const 修饰的是<code>函数自身</code>，表示该成员函数不会修改对象的状态，即不会修改该对象的成员变量。<br>用一个写好的运算符在其他的运算符中进行复用也是一个常见的技巧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _size == s._size </span><br><span class="line">&amp;&amp; <span class="built_in">memcmp</span>(_str, s._str, _size) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> &lt; s || *<span class="keyword">this</span> == s;  <span class="comment">//像这个，直接就复用了才写好的&lt;和==</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="&lt;&lt;与&gt;&gt;"></a>&lt;&lt;与&gt;&gt;</h2><p>要实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>这样的效果，就需要重载&gt;&gt;与&lt;&lt;操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = in.<span class="built_in">get</span>(); <span class="comment">//从输入流中读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">//检查此字符是否是空字符或者&#x27;\0&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">ch = in.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch != <span class="string">&#x27; &#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff[i++] = ch;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">127</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">s += buff;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch = in.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">s += buff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这两个重载需要放在全局情况中，不要放到string类中！</p></blockquote><p>这是因为在 C++ 中，运算符重载是一种基于函数重载的机制，它允许自定义类对象的行为，并支持与内置类型的相同语义。在大多数情况下可以重载任何运算符，包括 &lt;, &gt;, &#x3D;&#x3D;, &lt;&lt; 和 &gt;&gt; 等。<br>然而，对于 &lt;&lt; 和 &gt;&gt; 运算符，它们具有特殊的语义，通常用于<code>输入和输出</code>操作，因此在重载时需要特别注意。如果将 &lt;&lt; 或 &gt;&gt; 运算符<code>作为成员函数</code>来定义，其左操作数将被隐式地设置为<code>该类的对象</code>，而右操作数则需要作为<code>函数参数</code>传入。但是，对于输入流对象和输出流对象，它们是作为<code>全局对象</code>存在的，而不是作为类的成员对象存在的，因此需要使用全局函数来重载这些运算符。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态</title>
      <link href="/2024/11/03/cpp-Inheritance%20and%20polymorphism/"/>
      <url>/2024/11/03/cpp-Inheritance%20and%20polymorphism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学到了cpp的继承和多态这块，感觉知识点还是很细碎繁杂的，所以就写了一篇博客记录一下在这一块遇到的一些容易搞错的问题。</p></blockquote><h1 id="三种继承"><a href="#三种继承" class="headerlink" title="三种继承"></a>三种继承</h1><blockquote><p>cpp的三种继承：public（公有继承）、protected（保护继承）和private（私有继承）。</p></blockquote><h2 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h2><p>公有继承是最常见的继承方式，基类的公有成员在派生类中仍然是公有的，保护成员在派生类中变为保护的，私有成员在派生类中是不可访问的。<br>使用public关键字来表示公有继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::publicFunc()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPublic</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar 是公有的</span></span><br><span class="line">    <span class="comment">// publicFunc() 是公有的</span></span><br><span class="line">    <span class="comment">// protectedVar 变为保护的</span></span><br><span class="line">    <span class="comment">// privateVar 不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DerivedPublic derived;</span><br><span class="line">    derived.publicVar = <span class="number">42</span>; <span class="comment">// 可访问</span></span><br><span class="line">    derived.<span class="built_in">publicFunc</span>();  <span class="comment">// 可访问</span></span><br><span class="line">    <span class="comment">//derived.protectedVar = 10; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.privateVar = 20; // 错误，不能访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><p>保护继承使得基类的公有和保护成员在派生类中变为保护的，私有成员在派生类中是不可访问的。<br>使用protected关键字来表示保护继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::publicFunc()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedProtected</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar 变为保护的</span></span><br><span class="line">    <span class="comment">// publicFunc() 变为保护的</span></span><br><span class="line">    <span class="comment">// protectedVar 变为保护的</span></span><br><span class="line">    <span class="comment">// privateVar 不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DerivedProtected derived;</span><br><span class="line">    <span class="comment">//derived.publicVar = 42; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.publicFunc();  // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.protectedVar = 10; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.privateVar = 20; // 错误，不能访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>私有继承使得基类的公有和保护成员在派生类中变为私有的，私有成员在派生类中是不可访问的。<br>使用private关键字来表示私有继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::publicFunc()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPrivate</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar 变为私有的</span></span><br><span class="line">    <span class="comment">// publicFunc() 变为私有的</span></span><br><span class="line">    <span class="comment">// protectedVar 变为私有的</span></span><br><span class="line">    <span class="comment">// privateVar 不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DerivedPrivate derived;</span><br><span class="line">    <span class="comment">//derived.publicVar = 42; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.publicFunc();  // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.protectedVar = 10; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.privateVar = 20; // 错误，不能访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：基类private成员在派生类中不管怎么继承<code>都是不可见</code>的。<br>使用关键字<code>class</code>时默认的继承方式是<code>private</code>，使用<code>struct</code>时默认的继承方式是<code>public</code>，不过最好直接了当地写出继承方式。<br>在实际运用中一般使用都是public继承，几乎很少使用protetced&#x2F;private继承，也不提倡使用protetced&#x2F;private继承，因为protetced&#x2F;private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。</p><h1 id="基类和派生类的赋值转换"><a href="#基类和派生类的赋值转换" class="headerlink" title="基类和派生类的赋值转换"></a>基类和派生类的赋值转换</h1><blockquote><p>基类和派生类之间的对象赋值转换包括两种类型：向上转换（Upcasting）和向下转换（Downcasting）。</p></blockquote><h2 id="向上转换（Upcasting）"><a href="#向上转换（Upcasting）" class="headerlink" title="向上转换（Upcasting）"></a>向上转换（Upcasting）</h2><p>向上转换是将<code>派生类</code>的指针或引用赋值给<code>基类</code>指针或引用的过程。由于派生类<code>包含了基类的部分</code>，所以向上转换是安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    Base* basePtr = &amp;derivedObj; <span class="comment">// 向上转换</span></span><br><span class="line"></span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 输出 &quot;Base class&quot;，即使是派生类对象，调用的也是基类的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要把这个和多态搞混了，实现多态需要使用<code>虚函数</code>。这个在后面会提。<br>之所以会出现子类对象调用父类函数的原因是因为：在向上转换的情况下，将派生类对象的地址赋值给基类指针basePtr，调用basePtr-&gt;display()时，编译器会根据<code>指针的静态类型（即基类指针）</code>来确定调用的函数。因为静态类型是<code>Base*</code>，编译器会查找Base类中是否有名为display的成员函数。即使在派生类Derived中也存在名为display的成员函数，编译器也只会在Base类中查找。</p><p>这种行为称为<code>静态绑定或早绑定</code>，因为编译器在编译时就确定了要调用的成员函数，不考虑运行时对象的实际类型。</p><h2 id="向下转换（Downcasting）"><a href="#向下转换（Downcasting）" class="headerlink" title="向下转换（Downcasting）"></a>向下转换（Downcasting）</h2><p>向下转换是将基类的指针或引用赋值给派生类指针或引用的过程。由于基类可能不是派生类的对象，因此向下转换需要进行类型检查，确保转换是有效的。<br>但是实际中很少会用到向下转换。<br>为了进行向下转换（从基类到派生类），可以使用<code>dynamic_cast</code>运算符，但是这种转换要求基类指针指向的对象必须是<code>派生类的实例</code>，否则转换会失败并返回nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;   <span class="comment">//虚函数，实现了多态。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base baseObj;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    Base* basePtr = &amp;derivedObj;</span><br><span class="line"></span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 因为base里的displya是虚函数，所以输出 &quot;Derived class&quot;，通过基类指针调用派生类的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下转换，几乎不会使用！看看就行了</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line">    <span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        derivedPtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 输出 &quot;Derived class&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to downcast&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重载和隐藏"><a href="#重载和隐藏" class="headerlink" title="重载和隐藏"></a>重载和隐藏</h1><blockquote><p>重载（Overloading）和隐藏（Hiding）是两种不同的概念，用于描述函数和成员变量在继承关系中的行为。</p></blockquote><h2 id="函数重载（Function-Overloading）"><a href="#函数重载（Function-Overloading）" class="headerlink" title="函数重载（Function Overloading）"></a>函数重载（Function Overloading）</h2><p>函数重载是指在<code>同一个作用域</code>内，定义了多个函数，它们具有<code>相同的名称但具有不同的参数列表</code>。函数重载的目的是为了提供一种简洁和直观的方式来处理不同类型或数量的参数，以实现相似的功能。在进行函数调用时，编译器根据调用的函数参数类型和数量来决定要调用的具体函数。</p><ol><li>函数重载发生在<code>同一个作用域</code>内。</li><li>函数重载根据<code>函数的参数列表</code>来区分函数。</li><li>返回值类型不会影响函数重载的判定。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);      <span class="comment">// 调用 void print(int num)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2.1</span>);    <span class="comment">// 调用 void print(double num)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数隐藏（Member-Function-Hiding）"><a href="#成员函数隐藏（Member-Function-Hiding）" class="headerlink" title="成员函数隐藏（Member Function Hiding）"></a>成员函数隐藏（Member Function Hiding）</h2><p>成员函数隐藏是指在派生类中定义一个<code>与基类中成员函数名称相同</code>的函数，该派生类函数会<code>隐藏</code>基类中的同名函数，使得在派生类对象上<code>无法直接访问</code>基类的同名函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    derivedObj.<span class="built_in">display</span>(); <span class="comment">// 输出 &quot;Derived class&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏了基类的 display() 函数，无法直接通过派生类对象调用基类函数</span></span><br><span class="line">    <span class="comment">// derivedObj.Base::display(); // 通过限定作用域可以访问基类的同名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一波：在继承体系中基类和派生类都有<code>独立</code>的作用域。子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。如果是成员函数的隐藏，<code>只需要函数名相同</code>就构成隐藏。</p><h1 id="默认成员函数"><a href="#默认成员函数" class="headerlink" title="默认成员函数"></a>默认成员函数</h1><p>默认成员函数的本意就是如果我们不写，那么编译器会自动为我们生成。<br>派生类的成员函数会遵循这样的规则：</p><blockquote><p>派生类的构造函数负责初始化派生类<code>自己的成员以及基类的成员</code>。在派生类的构造函数中，需要在构造函数的初始化列表中<code>显式调用基类的构造函数</code>来初始化基类的成员。如果基类没有默认构造函数（无参构造函数），则必须通过派生类构造函数的初始化列表来调用基类构造函数，并传递必要的参数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// Base类构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">Base</span>(x) &#123;</span><br><span class="line">        <span class="comment">// Derived类构造函数</span></span><br><span class="line">        <span class="comment">// Base类的构造函数通过初始化列表调用，传递参数 x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</p></blockquote><p>当使用派生类对象初始化另一个派生类对象或将派生类对象传递给函数时，需要调用拷贝构造函数。在派生类的拷贝构造函数中，必须<code>调用基类的拷贝构造函数</code>来完成基类成员的拷贝初始化，以确保基类部分正确地复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        <span class="comment">// Base类拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> Derived&amp; other) : <span class="built_in">Base</span>(other) &#123;</span><br><span class="line">        <span class="comment">// Derived类拷贝构造函数</span></span><br><span class="line">        <span class="comment">// Base类的拷贝构造函数通过初始化列表调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>派生类的operator&#x3D;必须要调用基类的operator&#x3D;完成基类的复制。</p></blockquote><p>类的赋值运算符（operator&#x3D;）用于将一个对象的值赋给另一个对象。当派生类需要赋值运算符时，应该在派生类的operator&#x3D;中<code>调用基类的operator=</code>来完成基类部分的复制操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        <span class="comment">// Base类赋值运算符</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; other) &#123;</span><br><span class="line">        <span class="comment">// Derived类赋值运算符</span></span><br><span class="line">        Base::<span class="keyword">operator</span>=(other); <span class="comment">// 调用基类的赋值运算符</span></span><br><span class="line">        <span class="comment">// 处理派生类的赋值操作</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>派生类的析构函数会在被调用完成后<code>自动调用基类的析构函数</code>清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        <span class="comment">// Base类析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        <span class="comment">// Derived类析构函数</span></span><br><span class="line">        <span class="comment">// 在析构函数执行完毕后，会自动调用Base类的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="友元和静态成员"><a href="#友元和静态成员" class="headerlink" title="友元和静态成员"></a>友元和静态成员</h1><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元关系<code>不能继承</code>，也就是说基类友元不能访问子类私有和保护成员 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() : <span class="built_in">privateData</span>(<span class="number">1</span>), <span class="built_in">protectedData</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(Base&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendFunction</span><span class="params">(Base&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在友元函数中可以访问Base类的私有和保护成员</span></span><br><span class="line">    <span class="type">int</span> a = obj.privateData;    <span class="comment">// 可以访问私有成员</span></span><br><span class="line">    <span class="type">int</span> b = obj.protectedData;  <span class="comment">// 可以访问保护成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> derivedPrivateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">derivedPrivateData</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base baseObj;</span><br><span class="line">    <span class="built_in">friendFunction</span>(baseObj); <span class="comment">// 友元函数可以访问Base类的私有和保护成员</span></span><br><span class="line"></span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    <span class="built_in">friendFunction</span>(derivedObj); <span class="comment">// error！友元关系不能继承，不能直接访问Derived类的私有和保护成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Base类声明了一个友元函数friendFunction，该函数可以访问Base类的私有和保护成员。当我们创建一个Base类对象baseObj时，friendFunction可以访问baseObj的私有和保护成员。<br>当创建一个Derived类对象derivedObj时，尝试调用friendFunction(derivedObj)，会抛出异常。因为派生类Derived继承了Base类的友元关系，但是这个继承并不会使friendFunction可以直接访问Derived类的私有和保护成员。<code>友元关系只对声明为友元的类有效，不会在继承层次中传递</code>。</p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>运行下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; ++_count; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _stuNum; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graduate</span> : <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _seminarCourse; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">        Student s1;</span><br><span class="line">        Student s2;</span><br><span class="line">        Student s3;</span><br><span class="line">        Graduate s4;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到结果：4。因为基类定义了static静态成员，则整个继承体系里面<code>只有一个这样的成员</code>。</p><h1 id="菱形虚拟继承"><a href="#菱形虚拟继承" class="headerlink" title="菱形虚拟继承"></a>菱形虚拟继承</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>菱形虚拟继承是指在多重继承中，通过使用虚拟继承来解决由于多个基类共同派生同一个中间基类而导致的二义性和资源浪费问题。</p></blockquote><p>假设有一个基类Animal，两个派生类Bird和Fish，以及一个继承自Bird和Fish的派生类FlyingFish。此时，如果Bird和Fish都派生自Animal，而FlyingFish又同时继承自Bird和Fish，那么会形成一个菱形继承的结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Animal</span><br><span class="line">  /    \</span><br><span class="line">Bird   Fish</span><br><span class="line">  \    /</span><br><span class="line"> FlyingFish</span><br></pre></td></tr></table></figure><p>在这种情况下，FlyingFish类会同时继承自Bird和Fish，而Bird和Fish都继承自Animal。这样就会导致FlyingFish类中<code>有两份Animal类的副本</code>，而这两份副本实际上是<code>同一个类的不同实例</code>，造成了资源浪费。</p><p>此外，如果Bird和Fish分别定义了相同名称的成员函数或成员变量，那么在FlyingFish中使用这些名称时将会产生<code>二义性</code>。</p><p>C++提供了虚拟继承（virtual inheritance）的机制。在虚拟继承中，使用<code>关键字virtual</code>来声明继承，使得派生类只继承基类的一个<code>共同基类的单一实例</code>，而不是每个直接或间接基类都有一份实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Animal 类定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Bird 类定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Fish 类定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingFish</span> : <span class="keyword">public</span> Bird, <span class="keyword">public</span> Fish &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FlyingFish 类定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过在Bird和Fish类的继承中使用virtual关键字，FlyingFish类将只继承一份Animal类的实例，从而避免了资源浪费和二义性。</p><blockquote><p>二义性？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal is eating.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bird is flying.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fish is swimming.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingFish</span> : <span class="keyword">public</span> Bird, <span class="keyword">public</span> Fish &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FlyingFish 类继承自 Bird 和 Fish</span></span><br><span class="line">    <span class="comment">// Bird 和 Fish 类虚拟继承自 Animal</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个类层次结构中，FlyingFish类继承自Bird和Fish，而Bird和Fish类都虚拟继承自Animal。</p><p>如果没有使用虚拟继承，FlyingFish类将同时继承来自Bird和Fish的各自实例的Animal部分。这样，在FlyingFish类中调用eat()函数时，会发生二义性，因为存在两个Animal的实例。</p><blockquote><p>问题代表本质就在于<code>编译器无法确定应该调用哪个Animal类的eat()函数</code>，从而导致了二义性。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果不用虚拟继承，那么如果有下列结构，会出现数据冗余。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line"><span class="comment">//class B : virtual public A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line"><span class="comment">//class C : virtual public A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>D里会有两个A的_a,这样对内存是一种浪费，也造成了二义性。当改用<code>虚拟继承</code>后，D就只会继承到一个公用的_a了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">2</span>;</span><br><span class="line">    d.C::_a = <span class="number">9</span>;</span><br><span class="line">    std::cout &lt;&lt; d._a;  <span class="comment">//输出9而不是2,2被9覆盖。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; d._a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不采用虚拟继承时：<br>打开内存窗口，监视d的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x000000E2788FF968  01 00 00 00  ....    //d.B::_a</span><br><span class="line">0x000000E2788FF96C  03 00 00 00  ....</span><br><span class="line">0x000000E2788FF970  02 00 00 00  ....    //d.C::_a</span><br><span class="line">0x000000E2788FF974  04 00 00 00  ....</span><br><span class="line">0x000000E2788FF978  05 00 00 00  ....</span><br></pre></td></tr></table></figure><p>可以看到存在两个不同的_a。</p><p>当采用虚拟继承时：</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%811.png'><p>可以看到，此时只存在唯一的_a了。</p><p>当一个类进行虚继承（virtual inheritance），意味着该类继承自一个虚基类。</p><p>虚继承的实现依赖于<code>虚基表（virtual table）和虚基表指针（vptr）</code>：</p><blockquote><p>虚基表（virtual table）</p></blockquote><p>虚基表是一个数据结构，包含了虚基类的相关信息，如虚基类的<code>数据成员偏移量</code>和虚函数表的指针（如果存在虚函数）。<br>对于每个虚基类，编译器会生成一个虚基表。虚基表中的条目和顺序与虚基类的声明顺序一致。<br>图中的0060cd4c和0060cbac就是两个虚基表的地址。</p><blockquote><p>虚基表指针（vptr）</p></blockquote><p>每个含有虚函数或者继承了虚基类的类都会在其对象中包含一个<code>指向虚基表的指针</code>，称为虚基表指针（vptr）。<br>vptr 存储着对应类的虚基表的地址。编译器会在每个对象的<code>起始位置</code>（通常是对象的内存布局的开头）存储这个指针。</p><p>class D 对象中的内存布局包含<code>两个虚基表指针</code>，其中一个指向 class B 的虚基表，另一个指向 class C 的虚基表(如图中蓝线所指，两个指针分别指向两张虚基表)。通过查询各自的虚基表中所存放的<code>偏移量</code>，再和各自指向虚基表的指针的地址相加，就可以获取到_a的真实位置了！</p><blockquote><p>如图，第一个虚基表地址为0060cd4c，偏移量为14 00 00 00，也就是20个字节，正好一行是4字节偏移，往下数四行不正好就是_a的存储位置了吗？0060cbac也是同理，偏移量是12个字节，往下数三行即可。</p></blockquote><h1 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h1><h2 id="构成条件"><a href="#构成条件" class="headerlink" title="构成条件"></a>构成条件</h2><blockquote><p>多态（polymorphism）的构成条件：继承（inheritance）和虚函数（virtual function）。</p></blockquote><p>继承关系（Inheritance）：多态是通过<code>继承关系</code>来实现的。在 C++ 中，基类（父类）可以派生出派生类（子类）。子类可以继承基类的成员变量和成员函数。这样就可以使用<code>基类的指针或引用</code>来操作派生类的对象。</p><p>虚函数（Virtual Function）：通过使用虚函数，可以在基类中声明一个虚函数，然后在派生类中进行<code>重写（覆盖）</code>。虚函数使得在运行时动态地确定要调用的函数，而非静态绑定。<br>在基类中，使用 virtual 关键字声明虚函数。<br>在派生类中，使用 override 关键字来明确地重写基类中的虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Square square;</span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;circle;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a circle.</span></span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;square;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a square.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个要点：</p><ol><li>必须通过<code>基类的指针或者引用</code>调用虚函数。</li><li>被调用的函数必须是<code>虚函数</code>，且派生类必须对基类的虚函数进行重写。</li></ol><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>那么何为虚函数？</p><blockquote><p>虚函数是一种用于实现运行时多态性的特殊函数，可以在基类中声明一个函数为虚函数，然后在派生类中进行<code>重写（覆盖）</code>。这使得在运行时能够<code>动态地确定</code>要调用的函数版本。</p></blockquote><p>在基类中，使用 <code>virtual 关键字</code>来声明虚函数。当在基类中将一个成员函数声明为虚函数时，C++ 编译器会为该类创建一个<code>虚函数表（vtable）</code>（也可以称为虚表），其中保存了指向派生类重写函数的指针。这个虚函数表使得在运行时能够确定调用的是哪个函数版本。</p><p>在派生类中，使用 override 关键字来明确地重写基类中的虚函数。通过重写，派生类提供了一个<code>与基类虚函数同名、参数列表相同</code>的新实现。</p><p>通过基类的指针或引用来调用虚函数时，实际上会在运行时根据对象的类型<code>动态绑定</code>到正确的函数版本。这使得能够调用到派生类中的重写函数，而不是基类的实现。</p><p>虚函数的重写(覆盖)：派生类中有一个跟基类<code>完全相同</code>的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。</p><p>构成条件部分的代码基本展示了虚函数用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Square square;</span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;circle;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a circle.</span></span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;square;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a square.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果基类的<code>析构函数</code>为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析构函数构成重写，虽然函数名不相同，但可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成<code>destructor</code>。</p><h1 id="虚函数表和虚基表的区别"><a href="#虚函数表和虚基表的区别" class="headerlink" title="虚函数表和虚基表的区别"></a>虚函数表和虚基表的区别</h1><p>别把这两个东西给搞混了。</p><blockquote><p>虚基表</p></blockquote><p>在上面的部分已经提到过，在C++中，虚基表是用于解决菱形继承问题的一种机制。菱形继承指的是一个类同时继承了两个共同基类，而派生类又继承了这两个共同基类，导致派生类中<code>含有两份基类成员的副本</code>，造成冗余和二义性。</p><p>为了解决这个问题，C++引入了虚基类的概念。虚基类是在多重继承中声明为虚拟的基类，这样在派生类中就只会包含一个共同的基类子对象，而不会出现冗余。</p><blockquote><p>虚函数表(虚表)</p></blockquote><p>虚函数表是数据库中一种用于<code>实现多态性</code>的机制，通常用于支持对象关系映射和继承关系。<br>其中包含了对象的虚函数指针,对象的虚函数通过虚表来实现动态绑定（Dynamic Binding），也就是在运行时确定调用哪个实际函数，实现多态性。</p><p>当一个对象被创建时，会根据其实际类型初始化虚表指针，以便正确调用属于该对象实际类型的虚函数。这样，即使通过基类指针或引用来调用虚函数，也能够正确地执行派生类中相应的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Draw a circle.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Draw a square.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，Shape类是一个抽象基类，它包含一个虚函数draw。Circle和Square是Shape的派生类，它们都实现了draw函数。每个对象的虚表中存储着<code>对应的虚函数指针</code>，确保在运行时能正确调用相应的派生类的draw函数。</p><p>这么讲可能还是有点不清楚，得从原理下手才行。</p><p>先看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调一下内存窗口：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%812.png'></p><p>可以看到这里多出了一个<code>__vfptr</code>，对象中的这个指针我们叫做<code>虚函数表指针</code>(v代表virtual，f代表function)。一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，所以一定会有__vfptr。</p><p>再写一个派生类出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Base::print1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Base::print2()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Base::print3()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::print1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Base b;</span><br><span class="line"> Derive d;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调出内存窗口：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%813.png'></p><p>派生类对象d中同样包含一个虚表指针。d对象由两部分构成：一部分是<code>继承自父类的成员</code>，包括虚表指针，这部分可以称为继承部分；另一部分是派生类<code>自己的成员</code>，即新增的成员。基类b对象和派生类d对象的虚表是<code>不相同</code>的。在派生类d中，我们发现print1函数被重写（覆盖）。因此，d的虚表中存储的是重写后的Derive::print1，这也是虚函数的重写和覆盖的两种叫法，分别是语法层和原理层的称呼。</p><p>另外，虚表中还包含继承自基类的其他虚函数，例如print2。由于print2是基类中的虚函数，在派生类中也被继承下来，因此被放进了派生类d的虚表中。但是print3并不是虚函数，因此不会放进派生类d的虚表中。</p><p>虚函数表本质上是一个<code>存放虚函数指针</code>的指针数组，通常在数组的最后面会放置一个nullptr，表示虚函数表的结束。</p><p>总结一下派生类虚表的生成过程：</p><ol><li>首先将基类中的虚表内容拷贝一份到派生类的虚表中；</li><li>如果派生类重写了基类中的某个虚函数，就用派生类自己的虚函数<code>覆盖</code>虚表中基类的虚函数；</li><li>派生类自己新增加的虚函数按照在派生类中的声明次序增加到派生类虚表的最后。</li></ol><p>这样，派生类的虚表就包含了基类的虚函数和派生类自己的虚函数，构成了完整的虚函数表。</p><blockquote><p>虚表存的是<code>虚函数指针</code>，不是虚函数，虚函数和普通函数一样的，都是存在<code>代码段</code>的，只是他的指针又存到了虚表中。</p></blockquote><p>虚表和虚函数也是产生多态的基本条件。<br>满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到<code>对象</code>里去找的。不满足多态的函数调用时是<code>编译</code>时就确认好的。<br>也就是常说的静态绑定与动态绑定。静态绑定常见的就是函数重载，动态则是多态。</p><p>有兴趣的还可以自行研究下多继承里虚基表与虚函数的位置关系，还有复杂的菱形继承情况。在这里就不多赘述了，以后有机会再补一篇关于这方面的博客。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 友元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的内存管理</title>
      <link href="/2024/11/03/cpp-Memory%20management/"/>
      <url>/2024/11/03/cpp-Memory%20management/</url>
      
        <content type="html"><![CDATA[<h1 id="在c-c-内存如何分布"><a href="#在c-c-内存如何分布" class="headerlink" title="在c&#x2F;c++内存如何分布"></a>在c&#x2F;c++内存如何分布</h1><p>在一个程序的运行过程中，总是需要存储一些数据。这些数据可以粗略的被分为：</p><ol><li>常量数据</li><li>局部数据</li><li>静态数据与全局数据</li><li>动态申请数据</li></ol><p>在c&#x2F;c++中，内存可以分为四个区域：<code>栈区、堆区、静态区和常量区</code>。它们分别用于存储不同类型的数据，如下所示：</p><p>栈区：栈区是由编译器<code>自动分配和释放的内存区域</code>。它用于存储<code>局部变量、函数参数和函数返回地址</code>等。栈区是一个连续的内存块，它的大小是固定的。当程序执行离开一个函数时，栈中的内存就会被<code>自动释放</code>。为什么形参是实参的拷贝就与栈帧(栈帧也叫过程活动记录，是编译器用来实现过程&#x2F;函数调用的一种数据结构。每一次函数的调用，都会在调用栈（call stack）上维护一个独立的栈帧（stack frame）。)有关，二者是通过栈帧与寄存器的一些操作来实现数据传输的。并且建立栈帧的主要目的就是<code>存储局部的数据</code>。</p><p>堆区：堆区是由程序员手动分配和释放的内存区域。它用于存储<code>动态分配</code>的对象，如new操作符创建的对象。堆区是一个不连续的内存块，它的大小可以动态地调整。因此，堆区的内存容量比栈区大得多。程序员需要<code>手动释放</code>堆区中的内存，否则就会出现<code>内存泄漏</code>的问题。</p><p>静态区：静态区是用于存储<code>全局变量和静态变量</code>的内存区域。它在程序<code>启动时被分配，直到程序结束才被释放</code>。静态区也是一个连续的内存块，它的大小是固定的。</p><p>常量区：常量区是用于存储<code>常量数据</code>的内存区域。它包括字符串常量和其他类型的常量数据。常量区是一个不连续的内存块，它的大小固定不变。程序员<code>不能修改</code>常量区中的数据。</p><p>这些都是需要重点掌握的知识。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%86%85%E5%AD%981.png'><p>以一道题来巩固下知识：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> d=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> f[<span class="number">3</span>]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* g=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* p1=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别指出以上8个变量所存储的内存位置。<br>a：全局变量存储在静态区。<br>b：静态变量存储在静态区。<br>c：c也是存储在静态区。<br>d：d是一个局部变量只在main内可用，所以存储在栈区。<br>e：数组存储在栈区。<br>f：同上。<br>g：g是指向常量区的一个指针，但本身仍然存储在栈区内。<br>p1：p1是指向堆区的一个指针，但本身仍然存储在栈区内。<br>*p1： 对p1解引用，那么就是在堆区内。<br>*g1： 同理，解引用后在常量区。</p><h1 id="c-的动态内存分配"><a href="#c-的动态内存分配" class="headerlink" title="c++的动态内存分配"></a>c++的动态内存分配</h1><p>c语言里的内存分配函数如malloc，calloc等都可以在c++中使用，且可以满足大部分的功能，那为何c++要自行开发自己的动态内存管理方式呢？<br>在c中，内存管理主要是通过malloc和free函数进行的，这种方式对于简单程序来说非常有效。但是，在c++中，对象的构造和析构需要进行特殊的处理，而c中的内存管理方式无法满足这些要求。<br>因此，c++引入了new和delete运算符，这些运算符可以执行对象的构造和析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=<span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>上述的代码段就完成了动态申请一个int类型的空间。还可以扩展如下的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);  <span class="comment">//动态申请一个int空间且初始化为10。 </span></span><br><span class="line"><span class="type">int</span>* p2=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>];   <span class="comment">//动态申请4个int类型的空间。</span></span><br><span class="line"><span class="type">int</span>* p3=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//动态申请4个int类型空间其初始化为1,2,3,4</span></span><br></pre></td></tr></table></figure><p>不过在使用完后记得使用delete将其销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure><h1 id="malloc-free，new-delete有何异同？"><a href="#malloc-free，new-delete有何异同？" class="headerlink" title="malloc&#x2F;free，new&#x2F;delete有何异同？"></a>malloc&#x2F;free，new&#x2F;delete有何异同？</h1><p>相同点在于malloc与new都是从<code>堆上</code>去申请空间，且完成其使命后都要<code>手动销毁</code>，否则可能造成内存泄漏。<br>而不同点就比较多了。<br>第一，malloc无法完成初始化，这也是c++要使用新的内存管理方式的重要原因。<br>例如在写栈的函数时，使用malloc就只能完成申请空间的功能，而new可以在申请空间后<code>调用构造函数</code>对对象进行初始化。<br>第二，同上，free也只是完成空间的释放，而不会像delete一样会调用析构函数。<br>第三，new的<code>抛出异常机制</code>更适合在c++中使用，而malloc在空间申请失败时返回的是NULL。<br>第四，malloc与free是<code>函数</code>，而new和delete则是被定义为<code>操作符</code>。</p><p>既然讲到就简单谈谈<code>内存泄漏</code>。<br>内存泄漏，就是在应用程序分配某段内存后，因为某些失误，失去了对该段内存的控制，造成内存的浪费。如果内存不断的泄漏，那么由于其导致的响应速度会越来越慢，最终可能会造成崩溃。<br>也许有的人会有疑惑，为何自己在写动态分配内存时，有时候会忘记free或者delete，但好像也没什么事。这是因为现阶段我们写的代码都是在编译器上完成的，当程序停止，所有被用到的内存也都被释放了，包括我们失去控制的那段内存。但服务器就不一样了，例如游戏的服务器，是不能随意开关机的，那么如果有内存泄漏，势必会让服务器内存越来越慢，从而导致运行变慢，最终崩溃。</p><p>再说说new和delete，二者在底层的实现上都用到了malloc和free，只是除此之外调用了析构和构造而已。<br>new和delete是用户进行动态内存申请和释放的操作符，<code>operator new 和operator delete</code>是<br>系统提供的全局函数，new在<code>底层</code>调用operator new全局函数来申请空间，delete在<code>底层</code>通过<br>operator delete全局函数来释放空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间</span></span><br><span class="line"><span class="comment">失败，尝试执行空               间不足应对措施，如果改应对措施用户设置了，则继续申请，否</span></span><br><span class="line"><span class="comment">则抛异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try to allocate size bytes</span></span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line"><span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// report no memory</span></span><br><span class="line">         <span class="comment">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常</span></span><br><span class="line">         <span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">         _RAISE(nomem);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">operator delete: 该函数最终是通过free来释放空间的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *pUserData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     _CrtMemBlockHeader * pHead;</span><br><span class="line">     <span class="built_in">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class="number">0</span>));</span><br><span class="line">     <span class="keyword">if</span> (pUserData == <span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     _mlock(_HEAP_LOCK);  <span class="comment">/* block other threads */</span></span><br><span class="line">     __TRY</span><br><span class="line">         <span class="comment">/* get a pointer to memory block header */</span></span><br><span class="line">         pHead = <span class="built_in">pHdr</span>(pUserData);</span><br><span class="line">          <span class="comment">/* verify block type */</span></span><br><span class="line">         _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line">         _free_dbg( pUserData, pHead-&gt;nBlockUse );</span><br><span class="line">     __FINALLY</span><br><span class="line">         _munlock(_HEAP_LOCK);  <span class="comment">/* release other threads */</span></span><br><span class="line">     __END_TRY_FINALLY</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">free的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   free(p)               _free_dbg(p, _NORMAL_BLOCK)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上述两个全局函数的实现知道，operator new 实际也是通过malloc来申请空间，如果<br>malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete 最终是通过free来释放空间的。</p><p>new等于开空间加调用构造函数。<br>delete等于调用析构函数加释放空间。</p><p>例如我们new了一个stack类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span>&#123;</span><br><span class="line"> <span class="type">int</span>* arr;</span><br><span class="line"> <span class="type">int</span> capacity;</span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line">stack *p=<span class="keyword">new</span> stack;</span><br></pre></td></tr></table></figure><p>开空间就是在堆上为其开辟了指定的一块stack大小的空间。这点和malloc是一致的。而调用构造函数就是malloc无法办到的事情了，如果我们为stack类写了一个无参构造，那么此时申请完空间就会去调用无参构造，为stack类里的arr申请一块空间。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%86%85%E5%AD%983.png'><br>同样的，free也无法调用析构函数，并且delete里<code>析构执行顺序先于free</code>！<br>free能办到什么事呢？有这样一个有趣的比喻，你是一个需要水桶的人，管理水桶的我们暂且称为管家，malloc就是你对管家说：请给我xx个水桶，而free就是你对管家说：这xx个我用完了，还给你。而是否桶里的水有没有用完，管家也<code>不会去处理</code>。c语言程序中，在free后将指针<code>指向NULL</code>，也不过是提醒自己：这些水桶<code>不再属于我</code>了，我不能再往里面进行操作了。如果你free了还要执意使用水桶，别人拿去装饮料，你却往里面撒尿，这样做肯定会引起管家的不满啦！</p><p>总之free后你<code>仍然可以使用</code>这个指针，但操作系统认为这块内存已经还给了他，他会毫不犹豫的<code>分配给其他程序</code>，当你下一次在使用时就会有内容改变的风险！</p><p>所以free一个stack只是将arr，size，capacity从堆区中抹掉了，而arr指向的那块空间是free无法染指的，也就是桶里的水还在，这需要我们手动的去写析构函数才行。</p><h1 id="delete和delete"><a href="#delete和delete" class="headerlink" title="delete和delete[]"></a>delete和delete[]</h1><p>C++中，delete和delete[]都是用来释放动态分配的内存的关键字，但是它们的使用方式和释放的内存类型有所不同。<br>delete用于释放单个对象所占用的内存，即释放使用new关键字动态分配的单个对象的内存。当我们使用new来分配一个单个对象的内存时，需要使用delete来释放这个对象的内存。<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>delete[]用于释放数组对象所占用的内存，即释放使用new[]关键字动态分配的数组对象的内存。当我们使用new[]来分配一个数组对象的内存时，需要使用delete[]来释放这个数组对象的内存。<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><p>需要注意，如果我们使用delete来释放使用new[]关键字动态分配的数组对象的内存，或者使用delete[]来释放使用new关键字动态分配的单个对象的内存，都会导致未定义的行为，可能会出现内存泄漏或其他错误。因此，在使用动态内存分配时，需要根据对象类型选择合适的释放方式，以避免出现内存错误。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈初始化列表</title>
      <link href="/2024/11/03/cpp-initlist/"/>
      <url>/2024/11/03/cpp-initlist/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在之前的成员函数一文中谈到过构造函数，在创建对象时，编译器会调用构造函数，为成员变量进行赋值。但这个操作<code>并不是初始化</code>，初始化只能有<code>一次</code>，而在构造函数里面是可以进行多次赋值的。初始化的工作通常可以交由初始化列表来执行。</p></blockquote><h1 id="什么是初始化列表？"><a href="#什么是初始化列表？" class="headerlink" title="什么是初始化列表？"></a>什么是初始化列表？</h1><p>C++的<code>初始化列表</code>是一种在创建对象时<code>初始化成员变量</code>的特殊语法。它的存在可以显著的提高代码的可读性和性能。<br>在C++中，当我们创建一个对象时，我们需要为其成员变量<code>赋值</code>。通常情况下，我们会在构造函数中对成员变量赋值。但是，当对象中有大量成员变量时，这种方法可能会让代码变得冗长。<br>C++的初始化列表提供了一种更简洁、更清晰的方法来初始化成员变量。它使用<code>冒号分隔符</code>来定义一个初始化列表，并在其中列出成员变量及其初始值。<br>下面是一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> a;</span><br><span class="line">      <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>(<span class="type">int</span> a1,<span class="type">int</span> b1)</span><br><span class="line">        : <span class="built_in">a</span>(a1),<span class="built_in">b</span>(b1)</span><br><span class="line">      &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述的代码里，使用了初始化列表来为a与b赋值而没有经过构造函数体内。这就是初始化列表的基础用法。</p><p>使用初始化列表有一些需要注意的地方：</p><ol><li>成员变量在初始化列表里只可以有一次。</li><li>当类中包含<code>引用成员变量，const成员变量，自定义类型成员变量(该类没有默认构造函数时)</code>时，必须放在初始化列表里进行初始化。</li></ol><h1 id="初始化列表的使用"><a href="#初始化列表的使用" class="headerlink" title="初始化列表的使用"></a>初始化列表的使用</h1><p>在需要注意的第二点中我们提到了一旦包含上面的三个成员，就要放入初始化列表中进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">    : <span class="built_in">eternity</span>(a),<span class="built_in">reference</span>(b)</span><br><span class="line">    &#123;&#125; </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span>&amp; reference;</span><br><span class="line">     <span class="type">const</span> <span class="type">int</span> eternity;</span><br><span class="line">     B b1; <span class="comment">// B是另一个自定义类型，如果有默认构造函数，可不必放在初始化列表。</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果B类不存在默认构造函数，那么就需要在A的初始化列表中对b1进行一个显式的调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> x) : <span class="built_in">eternity</span>(a), <span class="built_in">reference</span>(b), <span class="built_in">b1</span>(x) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; reference;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> eternity;</span><br><span class="line">    B b1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在创建A对象时，编译器需要为其成员变量<code>分配内存并初始化</code>，如果B没有默认构造函数，那么编译器不知道<code>如何为b1分配内存</code>并初始化，从而产生编译错误。</p><p>并且请注意：成员变量在<code>类中的声明次序</code>就是其在初始化列表中的初始化顺序，而与其在初始化列表的顺序是<code>无关</code>的！</p><p>一个很经典的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">a1</span>(a),<span class="built_in">a2</span>(a1)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">      <span class="type">int</span> a2;</span><br><span class="line">      <span class="type">int</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在初始化列表中的顺序是a1，a2，但真正的执行顺序是a2，a1，也就是a2的初始化是一个随机值（因为此时a1就是随机的），在a2初始化完成之后a1才会被a赋值。</p><h1 id="为什么引用，const或者类变量必须在初始化列表中？"><a href="#为什么引用，const或者类变量必须在初始化列表中？" class="headerlink" title="为什么引用，const或者类变量必须在初始化列表中？"></a>为什么引用，const或者类变量必须在初始化列表中？</h1><p>const，引用类型或者类的成员变量必须要放在<code>初始化列表</code>里面，因为它们在创建对象时需要被初始化，而且只能在初始化时被赋值，不能在构造函数中再次被赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; reference;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> eternity;</span><br><span class="line">    B b1;       <span class="comment">//这里的都是声明！！！</span></span><br></pre></td></tr></table></figure><p>上面三个变量的特征就是<code>在定义时就必须被初始化</code>！</p><p>在C++中，对象的创建分为两个步骤：<code>分配内存和初始化</code>。在分配内存的过程中，编译器会为对象中的每一个成员变量分配内存空间；在初始化的过程中，编译器会调用构造函数来初始化每一个成员变量。对于const或者引用类型的成员变量，其值必须在初始化时被赋值，因此<code>必须在构造函数的初始化列表中进行初始化</code>，否则会导致编译错误。<br>另外，const或者引用类型的成员变量在对象的<code>整个生命周期中都不能被修改</code>，因此也不能在构造函数中再次被赋值。因此，将其放在初始化列表中进行初始化，可以确保它们的值只被赋值一次，并且在对象的整个生命周期中保持不变。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 对象 </tag>
            
            <tag> 类 </tag>
            
            <tag> 初始化列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>默认成员函数那些事儿</title>
      <link href="/2024/11/03/cpp-Member%20functions/"/>
      <url>/2024/11/03/cpp-Member%20functions/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在C++中，有许多<code>默认成员函数</code>，如默认构造函数、拷贝构造函数和析构函数等。这些默认成员函数在代码中扮演着重要的角色，它们可以帮助开发者快速<code>构建对象、复制对象和释放对象</code>。然而，这些默认成员函数的使用也有一些需要注意的细节和技巧。本文将详细介绍C++中的默认成员函数，包括其作用、使用方法、注意事项和实例说明等，旨在帮助读者深入了解和掌握这些重要的语言特性，从而写出更加高效可靠的代码。</p></blockquote><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>一个类没有成员，称为<code>空类</code>。但一个空类却并不为空。<br>编译器会在其中为开发者默认生成了两大类成员函数。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B01.png'></p><p>构造函数：当<code>创建</code>一个对象时，如果没有<code>显式地</code>提供构造函数，编译器会自动生成一个默认构造函数。默认构造函数的主要功能是<code>初始化成员变量</code>，使对象能够正确地工作。</p><p>析构函数：当一个对象<code>生命周期结束</code>时，如果没有<code>显式地</code>提供析构函数，编译器会自动生成一个默认的析构函数。析构函数的主要功能是<code>释放对象占用的资源</code>，如释放动态分配的内存等。</p><p>拷贝构造函数：当一个对象要被<code>复制</code>到另一个对象中时，如果没有<code>显式地</code>提供拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。拷贝构造函数的主要功能是将一个已有对象的值复制到新的对象中。</p><p>拷贝赋值运算符：当一个对象要被<code>赋值</code>给另一个对象时，如果没有<code>显式地</code>提供拷贝赋值运算符，编译器会自动生成一个默认的拷贝赋值运算符。拷贝赋值运算符的主要功能是将一个已有对象的值赋值给另一个对象。</p><blockquote><p>如果我们在类中显式地定义了这些成员函数，则编译器不会再生成默认版本。而且，如果我们定义了其中的某一个成员函数，则最好<code>也定义其它成员函数</code>，以保证它们能够协同工作，避免出现一些难以预料的问题。</p></blockquote><p><code>取地址重载</code>也可以算作默认成员函数的成员。主要是普通对象和const对象取地址，在文章后面也会提到。</p><p>创建一个class data，作为示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">data</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>再未了解构造函数前，我们想要对类中private修饰的成员变量赋值，需要写一个函数来访问它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date d1;</span><br><span class="line">d<span class="number">1.</span>_day = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这样的案例是错误的，编译器报错：<code>成员不可访问</code>。因为此时的_day成员被private所修饰，只能在类里对其进行访问。<br>使用private的好处是极多的。建议将类中的<code>成员变量</code>用<code>private</code>来修饰实现封装，是因为这样能够有效地<code>保护数据，防止外部的非法访问和修改</code>，从而提高程序的安全性和可靠性。<br>封装可以做到：</p><ol><li><p>隐藏实现细节：将成员变量封装在类的私有部分，可以隐藏实现细节，避免外部直接访问和修改，从而保证数据的<code>安全性和完整性</code>。</p></li><li><p>提高代码复用性：类的成员变量只有在<code>类的内部</code>才能访问，所以可以在类的内部定义一些公共的成员函数，通过这些函数来访问和修改成员变量，从而实现代码的复用。</p></li><li><p>方便代码维护：成员变量只能通过类的公共接口来访问，所以如果需要修改成员变量或者添加新的成员变量，只需要<code>修改类的公共接口</code>，而不需要修改外部的代码。</p></li></ol><p>那么此时我们可能会采取写一个init函数来对成员变量进行初始化。这也正是<code>构造函数</code>的职能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">_day = day;</span><br><span class="line">_month = month;</span><br><span class="line">_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数并不是如他的名字——去创建一个对象，而是参与了<code>对象中成员变量的初始化</code>。</p><blockquote><p>构造函数是一个特殊的函数，<code>名字与类名是相同</code>的，在创建对象时就由编译器<code>直接调用</code>，且在对象整个生命周期内<code>只调用一次</code>。</p></blockquote><p>构造函数有这样的几个特点：</p><ol><li>函数名与类名是<code>相同</code>的。比如date类的构造函数就叫date。</li><li>构造函数是<code>没有返回值</code>的。</li><li>当对象进行实例化时，编译器会<code>自动</code>调用此函数。</li><li>构造函数是可以进行重载的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">date</span>(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year) &#123;</span><br><span class="line">_day = day;</span><br><span class="line">_month = month;</span><br><span class="line">_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，这样就实现了两个构造函数——一个<code>有参构造</code>，一个<code>无参构造</code>。因为其支持重载，所以这样设置是没问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">date <span class="title">d1</span><span class="params">(<span class="number">12</span>,<span class="number">1</span>,<span class="number">2012</span>)</span></span>;  <span class="comment">//调用有参构造</span></span><br><span class="line">date d2;  <span class="comment">//调用无参构造,注意不能写成date d2()</span></span><br></pre></td></tr></table></figure><blockquote><p>当用户未进行显示定义时，编译器会<code>自动</code>生成一个<code>无参</code>构造函数。但一旦用户定义了，编译器就不会生成了。</p></blockquote><p>在c++中，类型可以被分为两种：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B02.png'></p><p>像int，double这样的类型就是内置类型，也被称作基本类型。<br>而像上面定义的date类，就被叫做自定义类型。</p><p>编译器在调用无参构造时，内置类型可能是随机值，也可能是0这样的值，这点<code>取决于编译器</code>。而自定义类型就一定会调用该类自己的<code>默认成员函数</code>。<br>我们又创建了一个类——student，并将其放在date类中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">student</span>() &#123;</span><br><span class="line">age = <span class="number">10</span>;</span><br><span class="line">name = <span class="string">&quot;chengzi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">_day = day;</span><br><span class="line">_month = month;</span><br><span class="line">_year = year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//date() &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//date(int day, int month, int year) &#123;</span></span><br><span class="line"><span class="comment">//_day = day;</span></span><br><span class="line"><span class="comment">//_month = month;</span></span><br><span class="line"><span class="comment">//_year = year;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line">student stu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行截图如下（vs2022）：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B03.png'><br>可以看到，虽然date的几个基本类型是随机值，但stu里带的成员变量因为<code>调用了自身的默认构造</code>，所以不是随机值。注意，调用的<code>必须</code>是默认构造也就是无参的哦。</p><p>在c++11中规定： 内置类型可以在类中声明时给出默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       <span class="type">int</span> _day=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _month=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _year=<span class="number">1</span>;</span><br><span class="line">student stu;</span><br></pre></td></tr></table></figure><p>运行截图：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B04.png'></p><p><code>无参构造</code>和<code>全缺省</code>都被称为默认构造，但两者只能存在一个，否则编译器不知道调用哪一个。</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>析构函数负责对象的<code>销毁</code>。<br>但析构函数不是对对象本身进行销毁，而是在编译器<code>出手销毁</code>时，作为一个强有力的工具，来帮助完成<code>对象资源</code>的清理。<br>析构函数的特征:</p><ol><li>析构函数的名就是在<code>类名</code>前加上一个<code>~</code>即可。</li><li>同样的，析构函数没有返回值。</li><li>析构函数是<code>不支持重载</code>的。</li><li>在对象生命周期结束时，由编译器亲自调用析构函数。</li></ol><p>析构函数适用于哪些情景呢？</p><ol><li>动态分配内存：当我们使用动态分配内存时，需要使用析构函数来释放这些动态分配的内存，防止<code>内存泄漏</code>。</li><li>对象销毁前的清理工作：当我们需要在对象销毁前进行一些清理工作时，可以使用析构函数来实现。例如，我们可以在析构函数中关闭对象的一些状态，保存对象的一些状态等等。</li></ol><p>所以当类中没有申请资源时，就不用写析构函数了，例如上面date类或者student类。而一旦类中进行了动态内存分配，我们就必须得自己写一个析构函数。<br>例如我们创建了一个类——stack。就必须要手动进行释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stack</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * capacity);</span><br><span class="line">currentsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">stack</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (arr) &#123;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* arr;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line"><span class="type">int</span> currentsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，默认的析构函数会调用自定义成员变量默认的析构函数（如果类中存在自定义成员变量的话）。</p><ul><li>构造顺序是按照语句的顺序进行构造，析构是按照构造的<code>相反顺序</code>进行析构。</li></ul><p>题1.函数F中，本地变量a和b的构造函数(constructor)和析构函数(destructor)的调用顺序是: ( )</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class A;</span><br><span class="line"></span><br><span class="line">Class B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">    B b;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>答案是a构造 b构造 b析构 a析构。</p><p>题2.设已经有A,B,C,D4个类的定义，程序中A,B,C,D析构函数调用顺序为？（ ）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> D d;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>类的析构函数调用一般按照构造函数调用的相反顺序进行调用，但是要注意static对象的存在，因为static改变了对象的生存作用域，需要等待程序结束时才会析构释放对象。</p></li><li><p><code>全局</code>对象先于<code>局部</code>对象进行构造。</p></li><li><p>局部对象按照出现的顺序进行构造，无论是否为static。</p></li><li><p>所以构造的顺序为C A B D。</p></li><li><p>析构的顺序按照构造的相反顺序析构，只需注意<code>static改变对象的生存作用域</code>之后，会放在<code>局部对象之后</code>进行析构。</p></li><li><p>因此析构顺序为B A D C。</p></li></ol><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>拷贝构造适用于创建一个与<code>原对象一模一样</code>的新对象。<br>且拷贝构造是一个构造函数的<code>重载</code>，且只有<code>单个形参</code>。<br>形参必须为<code>类类型对象的引用</code>，如果使用的是传值，那么编译器会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span>(<span class="type">const</span> date&amp; d) &#123;</span><br><span class="line">_day = d._day;</span><br><span class="line">_month = d._month;</span><br><span class="line">_year = d._year;</span><br><span class="line">stu = d.stu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果传递的是const date d，那么会引起<code>无限制的调用</code>。</p></blockquote><p>因为c++规定，在函数里调用自定义类型，必须要调用其<code>拷贝构造</code>来完成。因为传值通常就意味着拷贝，这点还是很好去理解的。只不过相较于内置类型的直接拷贝，自定义类型的传值拷贝稍微要麻烦一点点。</p><p>如果是传值，不就陷入了一个无穷的递归之中了吗？传值就要拷贝，拷贝就要调用拷贝构造，这不是没完没了了？<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B05.png"></p><p>当用户未在类中设置显式定义，编译器会生成默认的拷贝构造函数。此函数可以按照字节序进行拷贝（也被称为浅拷贝）。<br>所以如果还是使用date或者student类，仍然没有必要去写一个拷贝构造函数。那换成上面的<code>stack</code>类呢？<br>答案是<code>不行</code>。<br>因为在stack类里我们定义了一个arr作为栈的<code>基址</code>。当使用浅拷贝的时候，拷贝过去的仍然是这个基址。<br>当程序准备退出时，stack1和stack2都要调用析构函数进行销毁，无论哪个对象先调用析构进行销毁，等到下一个对象要销毁时，发现arr那块空间的支配权已经还给了系统了，同时<code>多次的内存空间释放必然会造成程序崩溃</code>。<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B06.png"><br>所以我们需要自行写一个拷贝构造函数。也就是深拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack&amp; stack1) &#123;</span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * stack<span class="number">1.</span>capacity);</span><br><span class="line"><span class="built_in">memcpy</span>(arr, stack<span class="number">1.</span>arr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * stack<span class="number">1.</span>currentsize);</span><br><span class="line">capacity = stack<span class="number">1.</span>capacity;</span><br><span class="line">currentsize = stack<span class="number">1.</span>currentsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造的使用方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stack <span class="title">s2</span><span class="params">(s1)</span></span>;   <span class="comment">//s2为要拷贝的目标，s1为拷贝的原本</span></span><br></pre></td></tr></table></figure><p>总结一下构造函数的适用场景：</p><ol><li>如上所示的stack s2(s1)，利用一个<code>已存在的对象来创建新对象</code>。</li><li>函数中有<code>参数</code>为类类型的对象。如add(date d1)这个函数，调用了d1这个对象，那么在传参的过程中必然会使用到拷贝构造。</li><li>函数<code>返回值</code>有类类型对象也是同样道理。</li></ol><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>运算符重载的引入是为了增强c++的代码可读性。其函数名为：<code> operator接需要重载的运算符号</code>。<br>并且在重载运算符中必须含有<code>至少一个类类型</code>的参数。</p><p>比如重载一个判断两日期是否相等的&#x3D;&#x3D;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> date&amp; d1) &#123;</span><br><span class="line"><span class="keyword">return</span> d<span class="number">1.</span>_year == _year &amp;&amp; d<span class="number">1.</span>_month == _month &amp;&amp; d<span class="number">1.</span>_day == _day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意： <code>::</code> ,<code>sizeof</code>,<code>?:</code>,<code> .</code>,<code> .*</code>不可被重载！</p><h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>赋值运算符重载是运算符重载的一种特例，它主要用于实现自定义类型的<code>深拷贝</code>。这个我们后面再说。<br>既然是赋值运算符重载，那么必然和普通的运算符重载有些许的区别，最明显的地方就在于<code>返回值</code>。<br>赋值运算符的返回值类型应该是一个<code>引用</code>，其目的是<code>支持连续赋值</code>。比如a&#x3D;b&#x3D;c，如果仍然按照上面的bool型返回，a&#x3D;b判断后返回一个true或者false，那又该如何去判断c呢？为了实现连续判断肯定会返回一个类对象的引用。<br>参数类型也常用引用，目的是为了<code>提高效率</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date&amp; <span class="keyword">operator</span>=(<span class="type">const</span> date&amp; d1) &#123;</span><br><span class="line">_year = d<span class="number">1.</span>_year;</span><br><span class="line">_day = d<span class="number">1.</span>_day;</span><br><span class="line">_month = d<span class="number">1.</span>_month;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，*this的用法是需要重点理解的。<br>在C++中，return *this是一个<code>返回当前对象引用</code>的语句，常用于<code>实现链式调用</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Class&amp; <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Class&amp; <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的示例中，func1()和func2()都返回MyClass类型的对象引用，因此可以在它们之间进行链式调用，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class obj;</span><br><span class="line">obj.<span class="built_in">func1</span>().<span class="built_in">func2</span>();</span><br></pre></td></tr></table></figure><p>这样的代码能够更加简洁和易读。同时，使用return *this也可以避免出现<code>多余的对象拷贝</code>操作，提高代码的效率。*this代表着返回当前对象，return *this与date &amp;作为返回值，则代表返回引用，引用就不必经过许多繁琐的拷贝工作，也就提高了效率。</p><p>c++也规定：<code> 赋值运算重载只能是类的成员函数</code>！<br>其中比较重要的一点原因：赋值运算符是<code>作用于对象</code>上的，而对象是类的实例，因此赋值运算符必须能够访问类的私有成员，只有<code>类的成员函数才能够访问类的私有成员</code>，因此赋值运算符重载只能作为类的成员函数来定义。除此之外，赋值运算符重载还需要<code>返回一个对象的引用</code>，这个引用指向赋值后的对象。如果赋值运算符重载作为全局函数或友元函数来定义，则无法访问对象的私有成员，并且无法返回对象的引用，因此无法实现赋值运算符的重载。</p><p>当用户未显式实现时，编译器也会自动生成一个<code>默认</code>的赋值运算符重载，以值的方式<code>逐字节</code>拷贝。<br>那么如果还是date这种类，直接使用默认的即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assignment</span><span class="params">(date&amp; d1)</span> </span>&#123;</span><br><span class="line">(*<span class="keyword">this</span>) = d1;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">date <span class="title">d1</span><span class="params">(<span class="number">22</span>,<span class="number">22</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">date d2;</span><br><span class="line">d<span class="number">2.</span><span class="built_in">assignment</span>(d1);</span><br></pre></td></tr></table></figure><p>编译结果：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B07.png'></p><p>但要是stack这样的类就不行了。s2&#x3D;s1，将s1的内容拷贝给s2，那么s2和s1指向同一片空间不说，s2赋值后还会丢失原本的空间，导致内存泄漏，最终释放两次相同的空间也一定会造成程序崩溃。所以stack这样的类需要的是<code>深拷贝</code>。</p><blockquote><p>请牢记，只要涉及到资源管理，那么一定需要重写赋值运算符。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符重载，实现深拷贝  </span></span><br><span class="line">    stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack&amp; other) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;  </span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 处理自赋值  </span></span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 分配新资源并复制数据  </span></span><br><span class="line">        capacity = other.capacity;  </span><br><span class="line">        currentsize = other.currentsize;  </span><br><span class="line">        arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * capacity);  </span><br><span class="line">        std::<span class="built_in">memcpy</span>(arr, other.arr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * currentsize);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="一些运算符重载示例"><a href="#一些运算符重载示例" class="headerlink" title="一些运算符重载示例"></a>一些运算符重载示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_year &lt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month &lt; x._month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _day &lt; x._day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _year == x._year</span><br><span class="line">&amp;&amp; _month == x._month</span><br><span class="line">&amp;&amp; _day == x._day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> &lt; x || *<span class="keyword">this</span> == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> date &amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == x);</span><br><span class="line">&#125;</span><br><span class="line">date <span class="keyword">operator</span>+(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">tmp += day;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前置++</span></span><br><span class="line">date&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置++</span></span><br><span class="line"><span class="comment">// 增加这个int参数不是为了接收具体的值，仅仅是占位，跟前置++构成重载</span></span><br><span class="line">date <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">date tmp = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于开头提到的取地址与取地址操作符重载 ,基本不会在日常生活中使用，想要了解的可以自行谷歌。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 对象 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体对齐与大小端</title>
      <link href="/2024/11/03/cpp-Structure%20alignment/"/>
      <url>/2024/11/03/cpp-Structure%20alignment/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h1><p>什么叫结构体对齐？</p><blockquote><p>结构体对齐是内存对齐的一种应用，主要是为了使结构体中的各个成员在内存中按照一定的规则排列，以符合CPU对数据访问的要求。某些CPU对于访问内存中的数据要求必须按照一定的边界对齐。没有对齐可能导致CPU<code>多次读取内存</code>，从而降低性能。内存对齐也可以简化编译器的设计，不用处理没有对齐的复杂情况。</p></blockquote><ul><li>结构体对齐基础规则</li></ul><ol><li>第一个成员在结构体变量偏移量为<code>0</code>的地址处</li><li>其他成员变量要对齐到<code>对齐数</code>的<code>整数倍</code>的地址处</li><li>对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的<code>较小值</code>。(VS中默认的值为8、Linux环境默认不设对齐数（对齐数是结构体成员自身的大小）)</li><li>结构体总大小为<code>最大对齐数</code>（每个成员变量都有一个对齐数）的<code>整数</code>倍</li></ol><p>看着文字可能有点懵，上个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;      <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">int</span> b;       <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="type">short</span> c;     <span class="comment">// 2 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>a在地址0x00，占用1字节<br>为了保证b能够aligned到4字节边界(b的对齐数是4，存放地址应该是4的整数倍处)，编译器会在a和b之间添加3个填充字节<br>b在地址0x04，占用4字节<br>c(同理，c的对齐数是2，存放在2的整数倍处即可)在地址0x08，占用2字节<br>为了保证整个结构体 Example 的大小能够被最大成员（4 字节）对齐，编译器可能在末尾添加 2 个填充字节，使得结构体的大小为 12 字节</p></blockquote><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF1.png'><blockquote><p>拓展1：内存体嵌套问题</p></blockquote><p>规则： 嵌套的结构体对齐到<code>自己的最大对齐数</code>的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">double</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">s1</span>;</span></span><br><span class="line"><span class="type">double</span> e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体S1的大小为16，算错的再看看上面的例子重新算一算。S1被嵌套在S2里，那么来看看S2的内存分配情况。</p><p>char型占1字节，直接从0开始算。 S1的对齐位置应该是其最大对齐数，也就是8。整体如下：</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF2.png'><blockquote><p>拓展2：如何让结构体按照指定的对齐参数进行对齐?</p></blockquote><ol><li>使用 #pragma pack（C和C++）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)  <span class="comment">// 将当前对齐方式设置为1字节对齐，并保存之前的对齐方式  </span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PackedStruct</span> &#123;  </span><br><span class="line">    <span class="type">char</span> a;  </span><br><span class="line">    <span class="type">int</span> b;  </span><br><span class="line">    <span class="type">short</span> c;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)  <span class="comment">// 恢复之前的对齐方式  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of PackedStruct: %zu\n&quot;</span>, <span class="built_in">sizeof</span>(PackedStruct));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 _<em>attribute_</em>((aligned(N)))（GCC编译器）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AlignedStruct</span> &#123;  </span><br><span class="line">    <span class="type">char</span> a;  </span><br><span class="line">    <span class="type">int</span> b;  </span><br><span class="line">    <span class="type">short</span> c;  </span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>)));  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of AlignedStruct: %zu\n&quot;</span>, <span class="built_in">sizeof</span>(AlignedStruct));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alignment of AlignedStruct: %zu\n&quot;</span>, __alignof__(AlignedStruct));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>为何要采取对齐内存的策略？</li></ul><p>如果没有内存对齐机制，就意味着数据可以存放在任意的位置，若一个int变量存放在从地址2开始的四个连续的字节地址中，当cpu取数据时，就要先从0地址开始读取第一个4字节块,再剔除掉不需要的字节地址0和1,然后从地址4开始再读取下一个4字节块,也剔除不要的数据地址6和7,最后留下的两块数据再合并放入寄存器。这样就导致读内存次数增多，也就导致了工作效率的下降。同时，有些硬件平台并不支持随意地址存取，这可能会导致抛出硬件异常。</p><h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><blockquote><p>大小端指的是多字节数据在内存中存储时，字节的<code>排列顺序</code>。具体来说，大端（Big-endian）模式将数据的最高有效字节（MSB）存储在最低的内存地址处，而最低有效字节（LSB）存储在最高的内存地址处。相反，小端（Little-endian）模式则将数据的最低有效字节存储在最低的内存地址处，最高有效字节存储在最高的内存地址处。</p></blockquote><p>这么说肯定不太直观，结合个例子看看：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF3.jpg'></p><p>小端存C1C2,先将C2(低位)存在地址的低位，大端则相反，C2存放在地址的高位。</p><ul><li>如何知道你的计算机是大端还是小端存储呢？</li></ul><blockquote><p>联合体（union）是一种特殊的数据结构，它允许在相同的内存位置以不同的类型来存储数据。联合体的所有成员共享同一块内存空间，这意味着它们在内存中的起始地址是相同的。</p></blockquote><p>定义一个联合体（union），该联合体包含至少两个不同类型的成员：一个整型（如int）和一个字符型（如char）。由于联合体成员共享同一块内存空间，因此可以通过<code>修改一个成员的值来观察另一个成员的变化</code>。<br>将整型成员的值设置为一个已知的、具有特定字节模式的值（如0x01020304）。<br>检查字符型成员的值。如果字符型成员的值是0x04（即整型值的最低字节），则机器是小端模式；如果字符型成员的值是0x01（即整型值的最高字节），则机器是大端模式。</p><p>在大端（Big-endian）模式下，最高有效字节（0x01）存储在最低的内存地址处，最低有效字节（0x04）存储在最高的内存地址处。<br>在小端（Little-endian）模式下，最低有效字节（0x04）存储在最低的内存地址处，最高有效字节（0x01）存储在最高的内存地址处。<br>由于字符型成员只占用一个字节，并且它与整型成员共享同一块内存，因此字符型成员将“看到”整型成员在<code>最低内存地址</code>处的那个字节的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">check_endianness</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>  </span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="type">char</span> c;  </span><br><span class="line">    &#125; test_union;  </span><br><span class="line">  </span><br><span class="line">    test_union.i = <span class="number">0x01020304</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (test_union.c == <span class="number">0x04</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Little-endian  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// Big-endian  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> result = check_endianness();  </span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This machine is Little-endian.\n&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This machine is Big-endian.\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大小端使用场景</li></ul><p>大端在我学习计算机网络时有涉及过，网络上传输的数据普遍采用大端模式（即网络字节序）。小端模式的设备在需要进行网络通信时，可以通过软件层面的转换来适应大端模式的数据格式。<br>然而在计算机里，还是小端用的要多一些。比较浅显的理由有这么两条：</p><ol><li>小端模式下，内存的<code>低地址</code>处存放的是数据的<code>低字节</code>。这种存储方式使得在强制转换数据类型时，不需要调整字节的内容。例如，将int类型的4字节数据强制转换为short类型的2字节数据时，可以<code>直接取int数据的前两个字节</code>（即低地址处的两个字节），因为它们刚好就是short类型所需要的最低两个字节。此外，CPU在做数值运算时，通常是从内存中依次<code>从低位到高位取数据</code>进行运算，直到最后刷新最高位的符号位。小端模式符合这种运算方式，因此可以提高运算效率。</li><li>在早期的计算机系统中，存储器的价格昂贵，且加法器的设计相对复杂。小端模式可以简化加法器的设计，因为只需要一个较低位数的加法器，然后依次从低到高循环加上所有字节即可，进位的电路相对简单。</li><li>小端模式在<code>数据扩展</code>时更加方便。例如，将16位整数扩展为32位整数时，只需在高地址处添0即可，而<code>无需移动数据</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 内存对齐 </tag>
            
            <tag> 大小端 </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之引用</title>
      <link href="/2024/11/03/cpp-reference/"/>
      <url>/2024/11/03/cpp-reference/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言： 最近学到了c++中的引用，发现引用和c中所学到的指针有着很相似的效果，但在c++中仍然有着指针的一席之地，想必二者的适用场景是各有千秋，于是查阅资料，写了此文来方便日后复习。</p></blockquote><h1 id="引用的基本知识"><a href="#引用的基本知识" class="headerlink" title="引用的基本知识"></a>引用的基本知识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>引用是C++中的一种<code>数据类型</code>，它是一种类似于指针的变量。引用可以被认为是一个变量的<code>别名</code>(比如你名字叫大明，外号叫小明，别人喊小明你肯定就知道是在叫你)，它提供了一种<code>访问变量</code>的方式，使得程序员可以通过<code>不同的名称来操作同一个变量</code>(喊大明小明都是在叫你)，从而简化了代码的编写。<br>引用的语法非常简单，可以通过在变量名前面加上“&amp;”符号来定义一个引用。例如，如果我们定义了一个整型变量a，可以通过以下语句来定义一个引用b：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure><p>这样，变量b就成为了变量a的别名，它们<code>指向同一个内存地址</code>(这点非常重要)。因此，对变量b的操作也会影响到变量a。</p><h2 id="引用的适用场景"><a href="#引用的适用场景" class="headerlink" title="引用的适用场景"></a>引用的适用场景</h2><ol><li>引用必须在定义时进行<code>初始化</code>。一旦引用被初始化，它将一直指向该变量，并不能再被改变。</li><li>引用可以作为<code>函数参数</code>传递。通过引用传递参数可以避免复制大量的数据，提高程序的效率。</li><li>引用可以作为函数的<code>返回值</code>。通过引用返回值可以避免复制大量的数据，提高程序的效率。</li><li>引用可以被用来操作数组，但它的使用有一些限制。<br>这几点我会在后面进行一个详细的解释。</li></ol><h1 id="正餐"><a href="#正餐" class="headerlink" title="正餐"></a>正餐</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>人可以有多个外号，同样，一个变量也可以有多个引用。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%BC%95%E7%94%A8-1.png'></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="type">int</span>&amp; c = a;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>得到的结果是10 10 20。说明了改变b与c可以影响a，且b与c指向的是<code>同一块</code>内存空间。<br>但一个引用就只可以引用一个实体。如果出现了一个<code>引用</code>引用多个实体的情况，编译器是不会放行的。<br>引用在定义时就必须<code>进行初始化</code>，这是不同于指针的一点。</p><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b=a;</span><br></pre></td></tr></table></figure><p>这样的例子是典型的错误。编译器给出了报错原因：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%BC%95%E7%94%A8-2.png'></p><blockquote><p>在这段代码中，常量a被定义为const int类型，它的值<code>不能被修改</code>。同时，变量b被定义为int类型的引用，它指向了a的内存地址。由于a是一个常量，它的值不能被修改，因此<code>对b的任何修改都会影响到a的值</code>，这与const int类型的a所表示的<code>语义不符</code>。因此，编译器会报错，提示“invalid initialization of reference of type ‘int&amp;’ from expression of type ‘const int’”。<br>常引用在c++里通常被用作函数参数，函数返回值或者成员变量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的a是一个常引用，此时在函数里对a的<code>任何修改</code>都是<code>非法</code>的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">getLonger</span><span class="params">(<span class="type">const</span> string&amp; str1, <span class="type">const</span> string&amp; str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str<span class="number">1.l</span>ength() &gt; str<span class="number">2.l</span>ength() ? str1 : str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数的功能是返回较长的一个字符串，常引用作为返回值确保了字符串在返回时<code>不会被修改</code>。此外，在作类成员变量，或者遍历容器时也会有常引用的身影。</p><blockquote><p>即当既要使用引用提高程序的效率(下面讲)，又不能在函数内部修改实参的值时，可使用常引用。</p></blockquote><h2 id="引用的适用场景-1"><a href="#引用的适用场景-1" class="headerlink" title="引用的适用场景"></a>引用的适用场景</h2><h3 id="做参数"><a href="#做参数" class="headerlink" title="做参数"></a>做参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; nums1, <span class="type">int</span>&amp; nums2)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; nums1 + nums2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个引用做参数的典型例子，其不仅在写法上更简洁，效率也是更高的。</p><ol><li>减少了数据的<code>拷贝</code><br>当使用<code>传值</code>方式时，函数会将参数的值复制一份给形参，如果参数<code>较大</code>，则会消耗较多的时间和空间。而使用引用做参数时，函数只需要<code>传入参数的地址</code>，不需要复制数据，因此可以减少数据的拷贝，提高程序的效率。</li><li>减少了内存的占用<br>当使用传值方式时，每次调用函数都需要为形参<code>分配内存空间</code>，当调用次数较多时，会占用较多的内存空间。而使用引用做参数时，只需要传递一个地址，不需要分配额外的内存空间，因此可以减少内存的占用，提高程序的效率。</li></ol><h3 id="做返回值"><a href="#做返回值" class="headerlink" title="做返回值"></a>做返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> nums1,<span class="type">int</span> nums2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums1+nums2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="built_in">add</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>传值返回</code>的传统写法，在返回时会创建一个<code>临时变量</code>，哪怕函数的栈帧已经被销毁，main里面接受的值也是从临时变量得来的，所以这种传递方式是安全的。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%BC%95%E7%94%A81.png'><br>但如果返回的是一个引用，那么情况就会出现变数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; nums1, <span class="type">int</span>&amp; nums2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = nums1 + nums2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时int c&#x3D;add(a, b)中的c是不确定的，可能得到正确的答案，那是因为add函数栈帧还没清理，如果栈帧被清理，得到的就是个随机值了。<br>同样的，如果将接受的变量换做一个<code>引用</code>，会变得更加的不可控。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; c=<span class="built_in">add</span>(a, b);</span><br><span class="line"> cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;aaa\n&quot;</span>);</span><br><span class="line"> cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>我的编译器给出的结果：</p><blockquote><p>30<br>aaa<br>-858993460</p></blockquote><p>可见在随意的调用另一个函数后，c的值发生了变化。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%BC%95%E7%94%A82.png'></p><p>此时，c是指向sum的，当add函数调用完成后<code>栈帧就被销毁</code>，但此时我的编译器仍然没有清理它，销毁意味着系统将add所用的栈帧空间<code>回收</code>，但回收并不意味着数据也随之抹去，比如你今天在A201上课，放学后你离开了A201，意味着你将教室归还，当你朋友第二天来<code>A201</code>上课时，教室是存在的,只是<code>使用者被换了</code>。<br>所以这里当add调用完成后，空间还给了操作系统，操作系统又把这块空间给了printf函数来使用，自然第二次输出c就会是乱码了。因为c始终都<code>指向</code>这个位置，但<code>谁来用</code>这个位置是不确定的。</p><p>那么可以做如下的总结：</p><ol><li>几乎在任何的场景下使用<code>引用传参</code>都是可以的。</li><li>但<code>引用返回</code>是需要谨慎使用的。一不留神就使用到了错误的空间。</li><li>函数返回时，出了函数作用域，如果返回对象还<code>未归还</code>给系统，则可以使用引用返回，但如果已经将其归还给了系统，那么最好用传值返回。</li></ol><h1 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h1><p>看到这里，你会发现指针似乎和引用没有很大的区别，确实，就我现阶段的学习来看，二者的差别并不是很大。<br>以下是我总结的一些差别和相同的地方。<br>区别：</p><ol><li>指针可以被<code>重新赋值</code>，而引用不行。(引用在初始化后不能改变所指向的对象)</li><li>指针可以为<code>空</code>，而引用不行。</li><li>指针可以进行指针运算，而引用不行。</li><li>指针可以<code>指向空地址</code>，而引用必须指向已存在的对象。</li><li>指针可以指向同一类型的不同对象，而引用只能指向同一类型的同一对象。</li><li>引用必须在<code>定义时</code>初始化，而指针可以在任何时候进行初始化。</li><li>指针有<code>多级</code>的说法，但引用没有。</li><li>指针需要<code>解引用</code>才可以访问存储的地址，引用不用。<br>相同：</li><li>指针和引用都是用来间接访问程序中的变量。</li><li>指针和引用都可以作为函数的参数和返回值。</li></ol><p>指针和引用都可以提高程序的运行效率，因为它们避免了不必要的变量拷贝。<br>指针和引用都是C++中的两种重要的数据类型，它们在某些方面有相同之处，但也有很多区别。在使用时，需要根据具体的情况来选择使用哪种类型。例如，如果需要动态分配内存或者需要进行指针运算，则必须使用指针；而如果不需要修改变量的值，则可以使用引用，避免了指针的复杂性。</p><p>还有一点很有意思，在语法的概念上，引用就是取一个别名，是<code>没有独立的空间</code>的。但在其底层实现上实际是存在空间的，这是因为<code>引用是按照指针的形式来实现的</code>。这一点可以在反汇编代码进行查证。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%BC%95%E7%94%A83.png'></p><p>可以看到反汇编代码几乎是一致的。但要深究其原理就等到以后再填坑啦。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++如何实现函数重载?</title>
      <link href="/2024/10/26/cpp-Function%20overloading/"/>
      <url>/2024/10/26/cpp-Function%20overloading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在c++中，有一种用法，名叫<code>函数重载</code>，函数重载是c++中一个非常重要的特性，它允许程序员定义<code>同名</code>但<code>参数列表不同</code>的函数，这样可以方便地实现代码复用和提高程序的可读性。但是在学习过程中令我感到奇怪的是，C却并不支持这一做法。于是通过查阅资料，完成了此篇博客。</p></blockquote><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数重载指的是在同一个作用域内，可以定义多个同名但参数列表不同的函数。例如：<br>如下是两个同名的add函数，功能是将两数相加并返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是add，但是它们的<code>参数列表不同</code>，一个是两个整数，一个是两个浮点数。当调用add函数时，编译器会根据实参的类型和数量来选择调用哪一个函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">// 调用int add(int, int)</span></span><br><span class="line"><span class="type">double</span> y = <span class="built_in">add</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);  <span class="comment">// 调用double add(double, double)</span></span><br></pre></td></tr></table></figure><p>这就是函数重载。函数重载的好处在于，可以让程序员使用同一个名字来表示多个不同的操作，这样做最浅显的好处就是给代码带来了美观。</p><p>函数重载一共有以下几种：</p><blockquote><p>参数数量不同</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数类型不同</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数顺序不同</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用引用或指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *a)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>常量参数与非常量参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>不同的返回类型（仅限于与参数数量和类型不同的情况）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>重点来啦：单纯通过返回类型的不同而构成重载是不可行的，必须还有<code>参数上的区别</code>。因为这样做编译器搞不明白你究竟想要使用的是哪个函数。<br>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>编译器到底该调哪一个呢？</p><h1 id="c-如何支持函数重载"><a href="#c-如何支持函数重载" class="headerlink" title="c++如何支持函数重载"></a>c++如何支持函数重载</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在c&#x2F;c++中，要想将一个程序跑起来，就需要经过如下的几个阶段 </p><blockquote><p>预处理，编译，汇编，链接<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD1.jpg'><br>图源王道2025操作系统讲义3.1</p></blockquote><p><code>预处理</code>是C++程序在编译过程中的第一步，它主要负责处理头文件、宏定义和条件编译等。在预处理阶段，预处理器会对<code>函数的声明</code>进行处理，通常，此文件是以<code>.i</code>为后缀。</p><p>编译器在<code>编译</code>阶段主要负责将源代码翻译成<code>汇编</code>代码。编译器通过分析源代码，将其转换为计算机可以理解的指令。汇编语言程序中的每条语句都以一种标准的文本格式确切的描述了一条低级机器语言指令。此时，文件后缀为<code>.s</code>。</p><p>在<code>汇编</code>阶段，编译器会将<code>汇编</code>代码翻译成<code>机器</code>代码。汇编器将<code>.s文件</code>翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件<code>.o</code>中。<code>.o</code>文件是一个二进制文件，它的字节编码是机器语言指令而不是字符，如果我们在文本文件中打开<code>.o文件</code>，所呈现的就是一串串的乱码。在汇编阶段，会生成一份<code>符号表</code>（这个表很重要,每个目标文件都有一份符号表，可简单理解为函数或变量对应的实际内存地址）。</p><p>在<code>链接</code>阶段，编译器会将多个目标文件链接成一个可执行文件。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/52ca90eb6e87f4b12c4dc7a7a4a2681.jpg'>图源《计算机系统基础》-袁春风(此图在软件层并未涉及到链接)<blockquote><p>(拓展)此图给出了实现两个相邻数组元素交换功能的不同层次语言的描述 。在高级语言源程序中，可直观地用三个赋值语句实现;在经<code>编译</code>后生成的汇编语言源程序中,可用4 个汇编指令 表 示 ， 其 中 ， 两 条 是 取 数 指 令 I w (l o a d w o r d )， 另 两 条 是 存 数 指 令 s w (s t o r e w o r d ); 在 经 汇编后生成的<code>机器语言程序</code>中，对应的机器指令是特定格式的二进制代码，例如，第一条Iw指令对应的机器代码为“1000 11000100 11110000000000000000”，这是一条MIPS体系结构中的指令，其中，高6位“100011” 为操作码，随后5位“00010” 为寄存器编号2，再后面5位 “01111” 为另一个寄存器编号，最后16位表示立即数0 。CPU能够通过<code>逻辑电路</code>直接执行这种<code>二进制表示的机器指令</code>。指令执行时通过控制器对指令操作码进行译码，解释成控制信号(control signal)控制数据通路执行，例如，控制信号ALUop&#x3D; add 可以控制ALU进行加法操作，RegWr&#x3D; 1 可以控制将结果写人寄存器。</p></blockquote><p>而要解释为何c++支持函数重载，就需要说一说<code>链接</code>阶段。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><blockquote><p>链接过程就是将<code>多个</code>输入目标文件(.o文件)加工合并成<code>一个</code>输出文件(<code>可执行</code>二进制文件)。在此阶段，可执行的二进制文件会对一些<code>符号</code>进行解析，调整一些地址。(注意：目标文件也是二进制，但操作系统并不允许直接执行！)</p></blockquote><ul><li>重点<br>比如在编译main文件时，有一个func函数(来自func文件)的声明，但编译器完全不知道他的存在！printf也是同理，虽然有#include &lt;stdio.h&gt;，但是在此头文件里也仅仅是一个<code>函数声明</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就意味着具体代码是什么样，或者存放在哪个内存块都是编译器目前不知道的。那么没有办法，只有先把函数的<code>跳转地址设置为0</code>，等到链接阶段再去修正。(为了找到这些要修正的函数，会生成重定位表，存放函数地址的偏移量。)</p><blockquote><p>(扩展)重定位表（Relocation Table）：重定位表保存了程序中需要进行地址重定位的信息。在编译和链接过程中，代码和数据段的实际内存地址可能还未确定，因此在生成目标文件时，编译器会记录下哪些位置<code>需要在链接时进行修改</code>。</p></blockquote><p>所以链接其实就是将多个目标文件以及一些静态库等等组合成一个可执行文件。在此过程中还会进行地址修正等工作。</p><p>接下来用一个具体的例子来解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>; <span class="comment">// 声明外部函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo(); <span class="comment">// 调用外部函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时生成的总符号表：</p><table><thead><tr><th>符号</th><th>类型</th><th>地址</th></tr></thead><tbody><tr><td>foo</td><td>函数</td><td>0x1000</td></tr><tr><td>bar</td><td>函数</td><td>0x2000</td></tr></tbody></table><p>bar里的重定位表</p><table><thead><tr><th>段</th><th>偏移</th><th>符号</th><th>操作</th></tr></thead><tbody><tr><td>.text.bar</td><td>0x04</td><td>foo</td><td>重定位</td></tr></tbody></table><p>在链接阶段，链接器会通过重定位表中的信息，将 b.c 中对 foo 的调用地址修改为 foo 在内存中的实际地址（假设是 0x1000）。</p><ul><li>注意：在不同的编译和链接阶段，符号表中的地址可能会有变化，尤其是在动态链接和加载的情况下。这里只是取简单情况进行分析。具体还要结合链接方式等情况来分析。</li></ul><p>如何在符号表里找到想要的函数，就需要借助命名规则。<br>Linux下的g++的命名规则最简单，常常修饰后变成【_Z+函数长度+函数名+类型首字母】。<br>c++存在这样的<code>函数名修饰</code>规则，而c没有，这就是c++可以实现重载的关键。</p><blockquote><p>规则规定：在 c++ 中，为了支持函数重载，编译器会对每个<code>函数名</code>进行<code>修饰</code>，从而生成<code>唯一的符号</code>来标识该函数。函数名修饰规则是由编译器定义的，不同的编译器可能会采用不同的修饰规则。Microsoft Visual C++ 编译器将函数名后面加上下划线和参数个数，参数类型和参数个数之间用 @ 分隔。例如，函数 void foo(int a, float b) 的修饰名为 _foo@8。</p></blockquote><p>如：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD4.png'></p><p>汇编阶段生成的符号表将会记录函数的<code>名称</code>与<code>地址</code>。</p><ul><li>若无函数名修饰规则，那么编译器只根据原始函数名来生成放在符号表中的函数名；如果有修饰规则，那么会将<code>形参个数，类型，顺序</code>也添加进考虑范围，以形成新的函数名。</li></ul><p>有一点需要注意，在编译的过程中，是<code>不会</code>执行用户的自定义函数的。</p><blockquote><p>在链接的阶段，链接器会解析<code>所有的符号</code>，并将被调用的函数的目标代码包含在可执行文件中。当我们在一个源文件中定义一个函数时，编译器会将该函数编译成目标代码，并在生成的目标文件中生成相应的符号。如果在其他源文件中<code>调用</code>了该函数，链接器会在链接阶段将相应的目标文件合并成一个可执行文件，并将<code>各个符号解析成实际的地址</code>，从而使得程序能够正确地执行。</p></blockquote><ul><li>所以c无法实现函数重载就是因为c没有像c++这样的修饰规则，而是仅仅以函数名来区分各函数。<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD3.png'></li></ul><p>此时又会出现一个问题，如果在团队开发里，有人用c，有人用c++，那么此时在这种混合模式下开发，由于c和c++编译器对函数名字修饰规则不同，可能就会导致链接失败！<br>针对这样的问题，可以采取在函数前加extern “C”的办法，也就是告诉编译器将该函数按照c语言规则来编译。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 函数重载 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
