<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO与文件系统</title>
      <link href="/2024/12/18/linux-file%20system/"/>
      <url>/2024/12/18/linux-file%20system/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾c语言的文件操作"><a href="#回顾c语言的文件操作" class="headerlink" title="回顾c语言的文件操作"></a>回顾c语言的文件操作</h1><h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><p>简单的回顾下在c语言中，我们是如何使用相关的文件接口的。<br>C语言提供了一套强大而灵活的文件接口，使得程序能够在磁盘上读取和写入数据。这个文件接口是操作系统提供的API（应用程序编程接口）的一部分，这里则是简单介绍一下C语言中常用的文件接口，包括文件的打开、读取、写入、关闭等操作。</p><blockquote><p>打开文件</p></blockquote><p>在C语言中，要对一个文件进行操作，首先需要<code>将其打开</code>。这可以通过使用fopen函数来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fptr;  <span class="comment">// 声明一个文件指针</span></span><br><span class="line">fptr = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">// 打开名为example.txt的文件以供读取</span></span><br></pre></td></tr></table></figure><p>声明了一个文件指针fptr，使用fopen函数将名为example.txt的文件以<code>只读</code>模式打开，函数返回一个指向该文件的指针。</p><blockquote><p>读取文件</p></blockquote><p>一旦文件打开成功，我们可以使用fread函数来读取文件内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 声明一个用于存储数据的缓冲区</span></span><br><span class="line">fread(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">100</span>, fptr);  <span class="comment">// 从文件中读取100个字符到缓冲区中</span></span><br></pre></td></tr></table></figure><p>使用fread函数从打开的文件中读取了100个字符，然后将其存储到名为buffer的字符数组中。</p><blockquote><p>写入文件</p></blockquote><p>如果需要将数据写入文件，可以使用fwrite函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">fwrite(data, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(data), fptr);  <span class="comment">// 将数据写入文件</span></span><br></pre></td></tr></table></figure><p>将字符串”Hello, World!”写入到已经打开的文件中。</p><blockquote><p>关闭文件</p></blockquote><p>在完成文件操作后，应该<code>及时关闭</code>文件，以释放资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(fptr);  <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure><blockquote><p>错误处理</p></blockquote><p>可以通过检查函数的<code>返回值</code>来判断文件是否成功打开或操作是否成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *fptr;</span><br><span class="line">fptr = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c语言的输入输出流"><a href="#c语言的输入输出流" class="headerlink" title="c语言的输入输出流"></a>c语言的输入输出流</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line"> fwrite(str, <span class="built_in">strlen</span>(str), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello linux\n&quot;</span>);</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fwrite函数将字符串 “hello world\n” 写入<code>标准输出</code>。fwrite 函数的参数依次为字符串的指针（str），字符串的长度（strlen(str)），写入次数（1），和目标输出（stdout）。<br>printf 函数来打印 “hello linux”。printf 函数将格式化字符串写入标准输出。<br>fprintf 函数来打印 “hello world”。fprintf 函数的参数依次为目标输出（stdout）和格式化字符串。</p><p>上面三个函数都提到了<code>stdout</code>，那么stdout到底是什么？</p><blockquote><p>在C语言中，stdout是<code>指向标准输出的文件指针</code>。标准输出是一个特殊的<code>文件流</code>，通常用于将程序的输出<code>打印</code>到屏幕上。<br>在这个函数中，使用了不同的输出函数来将字符串打印到标准输出上。fwrite、printf和fprintf都可以接受<code>文件指针作为参数</code>，用于指定输出的目标。<br>使用stdout可以方便地将输出打印到屏幕上，而不需要指定具体的文件或设备。这样，程序的输出就可以在控制台上可见，并且可以通过重定向等方式将输出保存到文件中。</p></blockquote><p>C语言默认会打开<code>三个</code>输入输出流，分别是<code>stdin, stdout, stderr</code>。<br>stdout已经在上文解释过，当涉及到<code>输入和错误输出</code>时，C语言提供了两个额外的标准流：stdin和stderr。</p><p>stdin是指向<code>标准输入</code>的文件指针。标准输入用于<code>接收来自用户的输入</code>，通常是通过<code>键盘</code>输入。例如，使用scanf函数可以从标准输入中读取用户的输入。</p><p>stderr是指向<code>标准错误</code>的文件指针。标准错误用于<code>输出程序的错误消息或其他诊断信息</code>。与标准输出不同，标准错误的输出通常被发送到屏幕上的错误流中，而不会被重定向到文件。例如，使用fprintf(stderr, …)函数可以将错误消息输出到标准错误流。</p><h1 id="linux下的文件操作"><a href="#linux下的文件操作" class="headerlink" title="linux下的文件操作"></a>linux下的文件操作</h1><h2 id="系统文件io"><a href="#系统文件io" class="headerlink" title="系统文件io"></a>系统文件io</h2><p>除了上面提到的C语言来进行文件操作，也可以通过<code>系统调用</code>来对文件进行读或者写等等操作。<br>当使用系统调用进行文件I&#x2F;O时，有几个常用的调用：</p><ol><li>open()：用于打开文件。它接受文件路径和一些标志作为参数，并返回一个文件描述符（file descriptor），表示打开的文件。</li><li>read()：用于从文件中读取数据。它接受文件描述符、数据缓冲区和读取字节数作为参数，并返回实际读取的字节数。</li><li>write()：用于向文件中写入数据。它接受文件描述符、数据缓冲区和写入字节数作为参数，并返回实际写入的字节数。</li><li>close()：用于关闭文件。它接受文件描述符作为参数，并在操作完成后关闭文件。</li></ol><blockquote><p>打开一个名为 “example.txt” 的文件（如果不存在则创建），然后写入字符串 “Hello, world!”。最后关闭文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理打开文件失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理写入文件失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四个常用接口介绍"><a href="#四个常用接口介绍" class="headerlink" title="四个常用接口介绍"></a>四个常用接口介绍</h2><blockquote><p>open</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname: 要打开或创建的目标文件<br>flags: 打开文件时，可以传入多个参数选项，用下面的一个或者多个常量进行“或”运算，构成flags。<br><br>参数:   <br><br>O_RDONLY: 只读打开。 <br><br>O_WRONLY: 只写打开。 <br><br>O_RDWR : 读，写打开。 <br><br>这三个常量，必须指定一个且只能指定一个。<br><br>O_CREAT : 若文件不存在，则创建它。  <br><br>O_APPEND: 追加写。 <br><br>返回值： <br><br>成功：新打开的文件描述符（什么是文件描述符会在下文讲）。 <br><br>失败：-1  <br><br>mode参数用于指定新创建文件的权限模式。 <br></p><blockquote><p>close</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于关闭文件。它接受文件描述符（fd）作为参数，在操作完成后关闭文件。<br>参数：<br>fd：要关闭的文件描述符。<br>返回值：<br>成功：0。<br>失败：-1。</p><blockquote><p>write</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于向文件中写入数据。它接受文件描述符（fd），数据缓冲区指针（buf）和要写入的字节数（count）作为参数。<br>参数：<br>fd：要写入的文件描述符。<br>buf：指向要写入的数据的缓冲区的指针。<br>count：要写入的字节数。<br>返回值：<br>成功：实际写入的字节数。<br>失败：-1。</p><blockquote><p>read</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于从文件中读取数据。它接受文件描述符（fd），数据缓冲区指针（buf）和要读取的最大字节数（count）作为参数。</p><p>参数：<br>fd：要读取的文件描述符。<br>buf：指向存储读取数据的缓冲区的指针。<br>count：要读取的最大字节数。<br>返回值：<br>成功：实际读取的字节数。<br>失败：-1。</p><blockquote><p>接口演示</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理文件打开失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理读取文件失败的情况</span></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取的数据</span></span><br><span class="line">    write(STDOUT_FILENO, buffer, bytes_read);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上文很多地方都出现了fd和文件描述符的概念（二者是一个东西），那么什么是文件描述符呢？</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>在文章开篇时，提到了c语言会打开三个输入输出流，那是如何得知这三个流被打开了呢？</p><p>文件描述符是一个<code>非负整数</code>，用于<code>唯一标识</code>一个打开的文件或I&#x2F;O流。它是一个抽象的概念，可以是文件、管道、套接字等。</p><p>标准文件描述符</p><blockquote><p>Linux系统通常会为每个进程自动分配三个标准文件描述符：<br>0（stdin）：标准输入，通常用于从键盘或其他输入设备读取数据。<br>1（stdout）：标准输出，通常用于向终端或其他输出设备输出数据。<br>2（stderr）：标准错误，通常用于输出错误消息。<br>0,1,2对应的物理设备一般是：<code>键盘，显示器，显示器</code>。</p></blockquote><p>文件描述符主要用于进行文件和I&#x2F;O操作，通常通过以下系统调用来操作文件描述符：</p><blockquote><p>open()：打开一个文件并返回一个文件描述符。<br>close()：关闭一个文件描述符，释放相关资源。<br>read()：从文件描述符中读取数据。<br>write()：向文件描述符中写入数据。<br>lseek()：移动文件描述符的读&#x2F;写位置。<br>dup()和dup2()：复制文件描述符，创建一个新的文件描述符与之关联。</p></blockquote><p>也就是说，可以这样输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="type">ssize_t</span> s = read(<span class="number">0</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> buffer[s] = <span class="number">0</span>;</span><br><span class="line"> write(<span class="number">1</span>, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line"> write(<span class="number">2</span>, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现了从标准输入读取数据，并将其写入标准输出和标准错误。<br>当打开一个文件时，操作系统在内存中要创建相应的数据结构来<code>描述目标文件</code>(比如文件大小，在磁盘位置，打开计数等文件属性)，也就是file结构体来表示并描述一个已经打开的文件对象。而如何管理一个个file结构体呢？Linux为其创建了文件描述符表(图中的File Struct)，里面存储了一个指针数组，每个元素都指向一个已经打开的文件。<br>如图，当进程执行open系统调用打开文件时，当前进程结构中有一个指针<code>*files</code>, 指向一张<code>文件描述符表</code>files_struct(每个进程有自己的表),该表的指针数组中每个元素都是一个指向打开文件的指针。下标0指向默认的stdin文件，下标1指向stdout文件，下标2指向stderr文件。所以，<code>文件描述符就是该数组的下标</code>。只要有文件描述符，就可以找到对应的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+         +------------------------+</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   Process (进程)  |         |   File Struct (file)   |</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   +------------+  |         |   +----------------+   |</span><br><span class="line">|   |  *files    |  |         |   | File*  0       |   |</span><br><span class="line">|   |  (指针)    |----------&gt; |   | File*  1       |   |</span><br><span class="line">|   +------------+  |         |   | File*  2       |   |</span><br><span class="line">|                   |         |   +----------------+   |                  </span><br><span class="line">+-------------------+         +------------------------+</span><br><span class="line">  </span><br><span class="line">0,1,2分别是这个指针数组的下标，从上往下分别指向stdin，stdout，stderr所代表的三个已打开的文件。</span><br></pre></td></tr></table></figure><blockquote><p>上图的File*列表仅存储打开的文件，也就是说，如果此时新建一个文件，那么分配给他的下标就会是3，如果在创建此文件前关闭了1，那么此文件的文件描述符就会被分配为1。这就是Linux系统下文件描述符基本的分配规则。</p></blockquote><p>当关闭掉文件描述符1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> close(<span class="number">1</span>);</span><br><span class="line"> <span class="type">int</span> fd = open(<span class="string">&quot;file&quot;</span>, O_WRONLY|O_CREAT, <span class="number">00644</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"> </span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>c语言printf函数底层封装的输出接口仍然是下标1，哪怕stdout被关闭，系统也只认识1，他要做的就是将需要打印的内容输出到1代表的这个文件。这也是linux环境下文件管理的一个显著特征，层层封装，再由系统统一调用，有点多态的意思在里面。</p><blockquote><p>将原本该打印到屏幕的内容打印到file里，这就叫重定向。</p></blockquote><p>文件描述符的重定向允许将一个文件描述符与另一个文件或设备相关联。例如，可以使用&gt;将命令的输出重定向到文件，或使用&lt;将文件内容作为输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出重定向：将命令的标准输出保存到文件。</span></span><br><span class="line"><span class="comment">//将 &quot;Hello, World!&quot; 写入到文件 output.txt</span></span><br><span class="line">echo <span class="string">&quot;Hello, World!&quot;</span> &gt; output.txt</span><br><span class="line"><span class="comment">//输入重定向：从文件中读取数据作为命令的标准输入。</span></span><br><span class="line"><span class="comment">//从文件 input.txt 中读取数据并将其作为命令的输入</span></span><br><span class="line">cat &lt; input.txt</span><br><span class="line"><span class="comment">//追加：将命令的标准输出追加到文件末尾。</span></span><br><span class="line"><span class="comment">//追加 &quot;Hello again!&quot; 到文件 output.txt</span></span><br><span class="line">echo <span class="string">&quot;Hello again!&quot;</span> &gt;&gt; output.txt</span><br><span class="line"><span class="comment">//错误输出重定向：将命令的标准错误输出保存到文件。</span></span><br><span class="line"><span class="comment">//将命令的标准错误输出保存到 error.log 文件</span></span><br><span class="line">ls non_existent_directory <span class="number">2</span>&gt; error.<span class="built_in">log</span>  </span><br><span class="line"><span class="comment">//标准输出和标准错误重定向到同一文件：</span></span><br><span class="line"><span class="comment">//将标准输出和标准错误输出都重定向到同一个文件</span></span><br><span class="line">ls non_existent_directory &gt; output_and_error.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="comment">//使用管道：将一个命令的输出传递给另一个命令的输入。</span></span><br><span class="line"><span class="comment">//列出当前目录下的文件，并将结果通过管道传递给 grep 命令以筛选文件名中包含 &quot;example&quot; 的文件</span></span><br><span class="line">ls | grep <span class="string">&quot;example&quot;</span></span><br></pre></td></tr></table></figure><p>但在本质上，重定向更改的是文件描述符所指向的内容。如上文所画的图，当执行了close(1)操作，再执行新建file文件，那么此时文件描述符为1的坑位就指向了file而不是stdout。<br>可以这么说，重定向的魅力在于<code>操作文件描述符</code>，将它们连接到不同的位置，从而<code>改变了命令的输入和输出源</code>，使得命令行操作更加灵活多变。<br>举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开或创建文件 &quot;output.txt&quot;，并获取文件描述符</span></span><br><span class="line">    <span class="comment">// O_WRONLY 表示以只写方式打开文件</span></span><br><span class="line">    <span class="comment">// O_CREAT 表示如果文件不存在则创建它</span></span><br><span class="line">    <span class="comment">// O_TRUNC 表示如果文件已存在，截断文件长度为0（即清空文件内容）</span></span><br><span class="line">    <span class="comment">// 0666 是文件的权限模式，这里表示所有者、所属组、其他用户都有读写权限（实际权限会受umask影响）</span></span><br><span class="line">    <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查文件是否成功打开，如果file_fd为 -1，表示打开文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (file_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// perror函数用于输出错误信息，它会输出传入的字符串以及对应的系统错误提示</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="comment">// 遇到错误，以错误状态码1退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 备份标准输出文件描述符</span></span><br><span class="line">    <span class="comment">// dup函数用于复制一个现存的文件描述符，这里复制标准输出文件描述符（其值为1）</span></span><br><span class="line">    <span class="comment">// 返回新的文件描述符（stdout_backup），它指向与标准输出相同的文件（通常是终端屏幕）</span></span><br><span class="line">    <span class="type">int</span> stdout_backup = dup(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查复制文件描述符是否成功，如果stdout_backup为 -1，表示复制失败</span></span><br><span class="line">    <span class="keyword">if</span> (stdout_backup == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用dup2将文件描述符 &quot;file_fd&quot; 复制到标准输出文件描述符 &quot;1&quot;</span></span><br><span class="line">    <span class="comment">// 这意味着后续所有向标准输出（文件描述符为1）的输出操作，都会改为输出到file_fd所指向的文件（即output.txt）</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(file_fd, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在标准输出已经被重定向到 &quot;output.txt&quot;，执行printf语句，输出的内容会写入到output.txt文件中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to output.txt\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复标准输出</span></span><br><span class="line">    <span class="comment">// 通过再次使用dup2，将之前备份的标准输出文件描述符（stdout_backup）复制回标准输出（文件描述符1）</span></span><br><span class="line">    <span class="comment">// 这样后续的输出操作又会回到正常的终端屏幕输出了</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(stdout_backup, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="comment">// 关闭用于操作output.txt文件的文件描述符file_fd，释放相关资源</span></span><br><span class="line">    close(file_fd);</span><br><span class="line">    <span class="comment">// 关闭备份的标准输出文件描述符stdout_backup，同样是释放资源</span></span><br><span class="line">    close(stdout_backup);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在标准输出已经恢复，继续输出到屏幕，这条printf语句输出的内容会显示在终端屏幕上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be shown on the screen\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为IO相关函数与系统调用接口对应，并且库函数封装系统调用，所以本质上，访问文件都是通过<code>fd</code>访问的。所以C库当中的FILE结构体内部，<code>必定封装了fd</code>。</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p1=<span class="string">&quot;fwrite\n&quot;</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p2=<span class="string">&quot;write\n&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;printf\n&quot;</span>);</span><br><span class="line"> fwrite(p1, <span class="built_in">strlen</span>(p1), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line"> write(<span class="number">1</span>, p2, <span class="built_in">strlen</span>(p2));</span><br><span class="line"> fork();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行三个输出，将信息打印到屏幕上，再执行fork新建一个子进程。<br>如果将此文件重定向到一个普通文件中时:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"> <span class="keyword">if</span> (dup2(file_fd, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p1=<span class="string">&quot;fwrite\n&quot;</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p2=<span class="string">&quot;write\n&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;printf\n&quot;</span>);</span><br><span class="line"> fwrite(p1, <span class="built_in">strlen</span>(p1), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line"> write(<span class="number">1</span>, p2, <span class="built_in">strlen</span>(p2));</span><br><span class="line"> fork();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出会变成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write</span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">fwrite</span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">fwrite</span><br></pre></td></tr></table></figure><p>write仍然只执行一次，而printf和fwrite被执行了两次。</p><p>首先，需要明白一个概念:printf和fwrite库函数有自带的缓冲区，而write作为系统调用则没有缓冲区。<br>这些缓冲区都是<code>用户级</code>缓冲区。<br>printf和fwrite都是库函数，这个缓冲区由C的标准库来提供。而write是系统调用，库函数则是在系统调用的“上层”， 是对系统调用的“封装”，所以write没有这个缓冲区也不足为奇。 <br><br>一般C库函数写入文件时是<code>全缓冲</code>(进程结束统一刷新)的，而写入显示器是<code>行缓冲</code>(遇到\n刷新)。当发生重定向到普通文件时，数据的缓冲方式由行缓冲变成了全缓冲。那么缓冲区中的数据就不会被立即刷新，甚至fork之后也不会刷新。当<code>进程退出</code>之后，就会被统一刷新，再写入文件当中。</p><blockquote><p>父进程角度</p></blockquote><p>在执行 fork 之前，代码中按照顺序先调用了 printf(“printf\n”);，此时 “printf\n” 字符串被放入了标准 I&#x2F;O 缓冲区，尚未真正输出（因为缓冲区未满且没遇到强制刷新等情况）。<br>接着执行fwrite(p1, strlen(p1), 1, stdout);，数据也被放入 fwrite 对应的标准 I&#x2F;O 缓冲区，同样没实际输出。<br>再执行 write(1, p2, strlen(p2));，由于write是系统调用，直接将 “write\n” 输出到了 output.txt 文件（因为标准输出已重定向到该文件），这就是为什么输出结果中第一个出现的是”write”。<br>当执行 fork 函数后，父进程继续往下执行，在父进程返回时（return 0; 之前），标准 I&#x2F;O 缓冲区中的数据（之前 printf 和 fwrite 缓冲的数据）会被刷新输出到 output.txt 文件，所以会输出 “printf” 和 “fwrite”。</p><blockquote><p>子进程角度</p></blockquote><p>子进程复制了父进程的状态，包括标准 I&#x2F;O 缓冲区的内容（是复制，不是共享，子进程有自己独立的缓冲区副本），当子进程继续执行到最后返回（return 0; 之前），同样会刷新自己的标准 I&#x2F;O 缓冲区，把缓冲的 “printf” 和 “fwrite” 也输出到 output.txt 文件，这就导致了后面又出现一次 “printf” 和 “fwrite” 的输出结果。</p><h1 id="linux如何管理文件"><a href="#linux如何管理文件" class="headerlink" title="linux如何管理文件"></a>linux如何管理文件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Linux系统中，文件系统以一种层次化的<code>树状结构</code>组织和描述所有的文件和目录。以<code>根目录</code>为起点，所有的文件和目录都从这里开始。<br>也许你听过一句话，<code>在Linux系统中，一切皆为文件</code>。这包括了普通文件、目录、设备文件、链接等等，并且不同类型的文件具有不同的属性和用途。<br>Linux将<code>硬件底层封装为文件</code>，并允许进程通过<code>文件指针</code>来进行调用和访问。<br>在Linux中，硬件设备通常由设备文件来表示，这些设备文件位于&#x2F;dev目录下。每个硬件设备都有一个相应的设备文件，例如硬盘设备可以表示为&#x2F;dev&#x2F;sda，串口可以表示为&#x2F;dev&#x2F;ttyS0等。<br>同时，每个进程都有一个文件描述符表，它是一个索引到文件的整数数组。文件描述符是进程用来访问文件的句柄。通常，标准输入、标准输出和标准错误分别对应文件描述符0、1和2。<br>进程可以通过系统调用来操作文件。例如，open系统调用用于打开一个文件，read和write用于读取和写入文件数据，close用于关闭文件。进程通过这些系统调用来请求操作文件或设备。<br>当进程打开一个文件时，操作系统维护一个文件指针（或文件偏移量），它指示文件中下一个读取或写入操作的位置。文件指针可以通过系统调用来移动，如lseek。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B61.png'>>可以这么认为，f#系列的函数，都是对系统调用的封装，方便二次开发。<p>在Linux中，每个文件都有一个<code>唯一的路径</code>，用于描述其在文件系统中的位置。路径可以是绝对路径（从根目录开始的完整路径）或相对路径（相对于当前工作目录的路径）。每个文件和目录都有权限设置，这确定了谁可以对其进行读、写和执行操作。此外，每个文件都有一个<code>所有者和所属的用户组</code>。<br>Linux支持多种文件系统类型，包括ext4、XFS、btrfs等。每个文件系统类型都具有不同的特性和性能。<br>Linux系统通过<code>系统调用</code>提供了一组API，用于<code>管理文件和目录</code>。这些系统调用包括打开、读取、写入、关闭、创建和删除文件，以及更改文件属性等。<br>以下几点作为了解：<br>链接和挂载： Linux支持硬链接和符号链接，允许多个文件名引用同一个文件。此外，Linux还支持文件系统挂载，使不同的文件系统可以被组合到同一个目录结构中。<br>特殊文件： Linux系统还包括特殊文件，如设备文件（用于与硬件设备通信）、套接字文件（用于进程间通信）和管道文件（用于进程间数据传输）。<br>文件系统维护： Linux系统中有一系列工具用于文件系统维护，如fsck用于文件系统检查和修复，du用于查看磁盘使用情况，df用于查看磁盘空间等。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>linux的文件都存储在磁盘上，那么谈文件系统就不能跳过磁盘。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B62.png'> <br><br>文件系统将文件数据分成小块（通常是扇区或块），这些块以逻辑方式组织在磁盘上，这样操作系统就可以进行有效地读取和写入。<br>当在Linux上进行创建、编辑或删除文件的操作时，实际上是在磁盘上进行操作。文件数据被写入到磁盘的数据块中，文件的元数据（如inode）被更新以反映文件的更改。</p><p>了解下磁盘的物理结构。</p><blockquote><p>一块磁盘通常由多个盘面（Platters）组成，每个盘面分为多个磁道（Tracks），而每个磁道又分为多个扇区（Sectors）。</p></blockquote><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B63.png'><p>扇区是磁盘上最小的可寻址存储单元，通常为512字节或4KB。<br>操作系统和文件系统使用扇区来读取和写入数据。<br>磁头则是用于读写数据的磁盘表面上的读&#x2F;写头。磁头的数量取决于磁盘驱动器的设计。</p><p>不知道大家小时候有没有用过播放英语听力的磁带，一圈圈的绕起来，和磁盘的结构很像。类比一下，磁盘也是如此，你可以想象磁盘上的磁道是一整条<code>磁带</code>，而数据就按照特定的顺序排列在上面。可以这么讲，磁盘的逻辑结构是<code>线性</code>的。而文件数据也线性地分布在上面。</p><blockquote><p>文件系统是一种在磁盘上创建的组织数据的结构，这样使得数据存储、访问和管理更加方便。磁盘则是实际的存储媒介，而文件系统为数据在磁盘上的组织和操作提供了接口和规则。</p></blockquote><p>以下是文件系统的组成图示以及每个组成部分的主要用途：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B64.png'></p><p>引导块(Boot Block)通常位于文件系统<code>之前</code>，是文件系统的前导部分。引导块的主要目的是<code>引导</code>操作系统，从而启动计算机。引导块与文件系统的关系在于它是文件系统之前的一部分，但不直接与文件系统的组件（如超级块、inode 表等）交互。引导块包含有关如何加载操作系统的信息，这个引导加载程序负责启动操作系统，并在需要时加载文件系统。在计算机开机时，会先去ROM中寻找自举装入程序，通过此程序再找到位于磁盘的引导块，将<code>完整的自举程序</code>对入内存，完成初始化。</p><p>而Block Group则是文件系统根据分区的大小划分为数个Block Group。每个Block Group都有着相同的结构组成。可以联想到国家设立省市来实行分级管理。</p><p>Superblock: 超级块包含文件系统的元数据，如文件系统大小、块大小、inode 数量或者一些磁盘数据，如磁道数，扇区数等。它是文件系统的核心信息存储，用于初始化和维护文件系统。</p><p>Group Descriptor Table (GDT): 组描述符表包含了关于每个数据块组(data blocks)的信息，如块位图、inode 位图和inode 表的位置。</p><p>Block Bitmaps: 块位图跟踪哪些数据块已经被使用，哪些还没有被使用。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/a181eeae1b6c82ba5e2528158b4c015.jpg'>  [图源王道操作系统强化讲义]<br><br>Inode Bitmaps: inode 位图用于跟踪哪些inode节点已被使用，哪些还没有被使用。原理图同Block Bitmaps。</p><p>Inode Table: inode 表存储文件和目录的元数据，如文件权限、拥有者、文件大小等。<code>每个文件和目录在inode表中都有一个对应的inode条目</code>（这点很重要）。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/aa184653c1dbbcec3301f5e998393cc.jpg'>[图源王道操作系统强化讲义] <br>拿inode1举例,inode1号节点存储着某个文件(暂称为目录文件A)的相关数据，如A的所有者是谁，什么时间创建，以及该文件占用几个块等。从图中可以得到信息，A共有两块，6号块和7号块。<p>Data Blocks: 数据块存储<code>实际的文件内容和目录结构</code>。它包含文件的实际数据，以及目录中文件和子目录的引用。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/d28ccc7052d925836418693cb52f916.jpg'><br>[图源王道操作系统强化讲义] <br><br>还是拿A举例，A如果是一个目录文件，那么A中就保存了该目录下的所有文件以及其对应的inode号。<br>如果A是一个普通文件，那么直接存储数据即可。</p><p>综上，文件系统遵循着将文件数据和属性<code>分开存放</code>的思想。数据通通存在data blocks中，而文件属性则单独放在inode表里。二者的联系则借助于GDT。</p><blockquote><p>如何从文件系统角度新建，删除文件？</p></blockquote><p>当需要新建文件时，首先会在Inode Bitmap中寻找一个<code>未使用</code>的索引节点。接着在Inode Table中分配这个索引节点，记录文件的元数据信息，比如文件名、权限等。然后会在Block Bitmap中寻找一些未使用的数据块（block Bitmaps也会随着更新）。最后，将文件的数据写入这些数据块中，完成文件的创建。</p><p>当需要删除文件时，首先会释放文件占用的数据块，在Block Bitmap中标记这些数据块为未使用状态。<br>然后释放文件的索引节点，在Inode Bitmap中标记这个索引节点为未使用状态。最后，在Inode Table中删除文件的元数据信息，完成文件的删除。</p><blockquote><p>打开文件</p></blockquote><p>文件都在磁盘中进行保存，当要打开指定文件时，操作系统会将文件(包括其inode与需要的文件内容)统统调入内存中。如果学习过计算机组成原理相关课程，应该不会对结构体page感到陌生，page也就是常说的<code>页</code>或者物理内存页，常取大小4KB。当文件被调入内存，操作系统会通过page结构体来对其进行描述和组织。一个文件常常会占用多个页(页之前可能不连续)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;         <span class="comment">/* 页的状态及属性标志，如锁定、脏页等标志位 */</span></span><br><span class="line">    <span class="type">atomic_t</span> _count;             <span class="comment">/* 页的引用计数 */</span></span><br><span class="line">    <span class="type">atomic_t</span> _mapcount;          <span class="comment">/* 页被映射的次数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;       <span class="comment">/* 根据具体情况存储特定相关数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>  <span class="comment">/* 所属的地址空间结构体指针 */</span></span><br><span class="line">    <span class="type">pgoff_t</span> index;               <span class="comment">/* 在所属地址空间中的偏移量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>        <span class="comment">/* 用于链接到LRU链表 */</span></span><br><span class="line">    <span class="type">void</span> *freelist;              <span class="comment">/* 空闲页链表相关指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head;  <span class="comment">/* 复合页的头部页指针 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_dtor;  <span class="comment">/* 复合页析构函数指针 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_mapcount;  <span class="comment">/* 复合页映射计数 */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> compound_order;  <span class="comment">/* 复合页的阶数 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>           <span class="comment">/* 所属的内存区域结构体指针 */</span></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>每一个struct page都构成内存数组(struct page mem_array[])的一部分！</strong><br>物理内存从整体上看是一个连续的字节数组，为了方便管理，内核将物理内存划分为固定大小的页，每个页对应一个 struct page 结构体来进行描述和管理。从这个角度看，所有的 struct page 结构体所代表的页，就像是连续排列的元素，共同构成了一个对整个物理内存进行描述的数组。<br>就像普通数组可以通过索引快速定位到特定的元素一样，在内存管理中，内核可以通过一定的机制将物理页框编号（PFN）等信息转换为 struct page mem_array[] 的索引，从而快速定位到对应的 struct page 结构体。也就是说只要给定一个物理内存地址，内核可以通过计算得到该地址所在页对应的 struct page 在 mem_array 中的位置，更通俗的讲，<code>访问内存就是在访问内存page数组</code>。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734848314495.png'></p><p>当应用程序发起对文件的访问请求时，操作系统借助文件系统来执行读取操作。文件系统首先查找文件的元数据，例如 inode，以此确定文件在磁盘上的物理位置。Linux 系统设有页缓存（Page Cache）机制，它会将文件系统中的数据缓存至内存。若所需文件数据已存在于页缓存中，则无需从磁盘重新读取；若不存在，则需从磁盘读取数据并缓存至内存。</p><p>物理内存与磁盘均以 4KB 作为基本存储单元来存储数据，出于效率考量，二者之间进行数据交换时亦以 4KB 为最小操作单位。例如，对于一台拥有 4GB 物理内存的计算机，以 4KB 为最小分片单位，可划分出约一百万个分片（可类比为具有一百万个下标的数组），这就是上文提到的内存页数组。操作系统通过特定的地址转换方法，能够实现虚拟地址与页下标的转换，进而精准定位到正确的物理地址空间以存放数据。这一过程遵循“先描述再组织”的设计理念，每个 4KB 的页均由 struct page 结构体进行描述，该结构体中存储着页的各类必要属性信息。</p><p>当一个进程尝试打开文件时，如前文所述，会在进程对应的文件描述符表中查找对应的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+         +------------------------+</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   Process (进程)  |         |   File Struct (file)   |</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   +------------+  |         |   +----------------+   |</span><br><span class="line">|   |  *files    |  |         |   | File*  0       |   |</span><br><span class="line">|   |  (指针数组) |----------&gt; |   | File*  1       |   |</span><br><span class="line">|   +------------+  |         |   | File*  2       |   |</span><br><span class="line">|                   |         |   +----------------+   |                  </span><br><span class="line">+-------------------+         +------------------------+</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>上文已经提到过，0,1,2 分别是这个指针数组的下标，从上往下依次指向 stdin，stdout，stderr 所代表的三个已打开的文件。更具体的说指向各自的struct file结构体。而file结构体里有指向inode结构体和address_space结构体的指针。<br>例如，当打开文件描述符fd为7的文件时，文件属性存储在 inode 结构体中，而文件内容则以特定形式封装于 address_space 结构体中。struct address_space 内部包含了一棵红黑树page_tree，用于组织和管理与该文件相关的所有页面缓存(也就是文件的页缓冲区)。通过这种树型结构，内核可以快速地查找、插入和删除页面缓存。当需要查找某个文件偏移量对应的页缓存时，可以通过红黑树快速定位到相应的 struct page 结构体。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734850251487.png'></p><h2 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h2><p>当使用ls -l命令时，会看到类似下图的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 654 &quot;11月 9 13:06&quot; chengzi.c</span><br></pre></td></tr></table></figure><p>从左到右，分别是：模式，硬链接数，文件所有者，组，大小，最后修改时间。inode是文件系统中的数据结构，包含着文件的属性信息。<br>硬链接（Hard Links）指一个文件可以有<code>多个文件名指向同一个inode</code>。inode作为文件系统中的数据结构，包含了文件的元数据（比如权限、所有者、文件大小等）以及指向实际数据块的指针。<br>所有硬链接文件都指向同一个inode，因此它们实际上共享相同的数据块。<br>删除任意一个硬链接并不影响其他硬链接，只有当所有链接都被删除时，inode的<code>引用计数</code>才会变为零，文件系统才会释放相关的数据块。<br>但硬链接也有自己的缺点，硬链接不能跨越文件系统，只能在同一文件系统内创建。也<code>不能对目录创建硬链接</code>。<br>不能对目录创建硬链接的主要原因是防止文件系统的树形结构出现<code>循环</code>。<br>举个例子：你在目录a下查找文件b，但同时目录a中存在目录c，目录c是指向目录a的硬链接，这会导致什么后果？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/user</span><br><span class="line">|-- a</span><br><span class="line">|   |-- directory_c (硬链接到 /home/user/a)</span><br><span class="line">  其他文件或目录</span><br><span class="line">|   |-- file_b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;home&#x2F;user&#x2F;b&#x2F;directory_c 和 &#x2F;home&#x2F;user&#x2F;a 实际上指向同一个目录，这就导致了在进行遍历查找时，可能会陷入循环的问题。</p><p>创建硬链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln source_file hard_link_name</span><br></pre></td></tr></table></figure><p><code>空</code>的文件夹引用计数是<code>2</code>。但空的文件夹其实并不是空的， 其中含有两个隐藏的文件.和..。这两个文件分别指向了本目录和上层目录，都是硬链接。如果一个目录引用计数是17，那就代表这个目录下还有15个子目录。</p><p>与硬链接相对应的就是软链接。<br>软链接可以类比成windows系统下的<code>快捷方式</code>。<br>软链接是一种特殊类型的文件(所以他有自己的inode)，它创建一个指向另一个文件或目录的符号链接。软链接类似于快捷方式，它只包含目标文件的<code>路径信息</code>，而不是实际的数据。如果源文件或目录被删除或移动，软链接将失效。</p><p>创建软链接:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /path/to/source /path/to/symlink</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列的简单模拟实现</title>
      <link href="/2024/12/15/cpp-priority_queue/"/>
      <url>/2024/12/15/cpp-priority_queue/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是优先级队列"><a href="#什么是优先级队列" class="headerlink" title="什么是优先级队列"></a>什么是优先级队列</h1><blockquote><p>在 C++ 中，std::priority_queue 是一个优先级队列的实现，它提供了按照优先级进行元素存储和访问的功能。与 Python 中的 PriorityQueue 类似，C++ 的 std::priority_queue 使用<code>堆数据结构</code>来实现。</p></blockquote><p>创建一个优先级队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// 创建一个存储 int 类型的优先级队列</span></span><br></pre></td></tr></table></figure><p>添加元素到队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pq.<span class="built_in">push</span>(<span class="number">5</span>);  <span class="comment">// 添加 5 到队列</span></span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">3</span>);  <span class="comment">// 添加 3 到队列</span></span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">8</span>);  <span class="comment">// 添加 8 到队列</span></span><br></pre></td></tr></table></figure><p>获取并移除最高优先级的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> topElement = pq.<span class="built_in">top</span>();  <span class="comment">// 获取最高优先级的元素（不移除）</span></span><br><span class="line">pq.<span class="built_in">pop</span>();  <span class="comment">// 移除最高优先级的元素</span></span><br></pre></td></tr></table></figure><p>检查队列是否为空：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isEmpty = pq.<span class="built_in">empty</span>();  <span class="comment">// 检查队列是否为空</span></span><br></pre></td></tr></table></figure><p>返回队列中元素的个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = pq.<span class="built_in">size</span>();  <span class="comment">// 返回队列中元素的个数</span></span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，std::priority_queue 的元素是按照<code>降序</code>排列的。也就是说，最大的元素拥有最高的优先级。如果想要实现最小值优先的队列，可以传递一个比较函数对象作为模板参数。</p></blockquote><h1 id="堆-预备知识"><a href="#堆-预备知识" class="headerlink" title="堆(预备知识)"></a>堆(预备知识)</h1><p>什么是堆？称为堆的前提得是一棵完全二叉树，且堆中某个结点的值总是不大于或不小于其父结点的值。</p><blockquote><p>类型</p></blockquote><p>最大堆（大根堆）：根结点最大的堆。<br>最小堆（小根堆）：根结点最小的堆。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734231016919.png'>[图片生成自'https://algo.hufeifei.cn/Heap.html']如图是一个小根堆。堆的存储方式采用顺序存储(常用数组)，从上到下，从左到右，这样的存储方式非常适合找到父节点或者孩子节点，其符合规律：<blockquote><p>任何一个节点*2就能得到它的左孩子下标，再+1就能得到它的右孩子下标(前提是孩子都存在)。<br>任何一个节点除2再<code>向下取整</code>就能得到父节点下标。<br>使用该规律前提是下标从<code>1</code>开始！</p></blockquote><blockquote><p>如何建堆？</p></blockquote><p>总结为：倒着建。从数组的最后往前走，每一个叶子结点都是一个独立的小堆，那么直接从<code>最后一个非叶结点</code>开始调整。为什么要倒着来？因为每检查到一个节点，它的子节点包括子节点的子节点都已经调整完毕了(随着父节点变动可能子节点还会有调整，在代码部分细讲)。<br>图中的最后一个节点是145，不难看出它的父节点12就是最后一个非叶结点。如果12的左子节点比它还大，就该进行调整，右子节点比他小也该进行调整。调整的准则就是目前节点为根的堆必须满足是大根堆或者小根堆。当这样一轮调整结束，最大(最小)的那个节点就被成功移到了堆顶。</p><p>构建最大堆：将数组重新组织成一个最大堆。</p><blockquote><p>建堆过程</p></blockquote><p>将堆顶元素（最大值）与堆的最后一个元素交换。<br>减小堆的大小（排除已经排好序的最大元素）。<br>重新调整堆，使其满足最大堆性质。<br>重复上述步骤，直到堆的大小为1。</p><p>对数组 <code>[3, 7, 2, 4, 1]</code> 构建大根堆:</p><blockquote><p>初始数组对应的完全二叉树表示</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      3</span><br><span class="line">    /   \</span><br><span class="line">  7      2</span><br><span class="line"> /  \    /</span><br><span class="line">4    1</span><br></pre></td></tr></table></figure><p>先计算最后一个非叶子节点的索引，对于长度为 <code>n = 5</code> 的数组，最后一个非叶子节点索引是 <code>n / 2 - 1 = 1</code>（对应元素 <code>7</code> 这个节点）。</p><blockquote><p>从最后一个非叶子节点（索引为1，值为7）开始调整</p></blockquote><ul><li>节点 <code>7</code> 的左子节点是 <code>4</code>，右子节点是 <code>1</code>，因为 <code>7</code> 大于 <code>4</code> 和 <code>1</code>，满足大根堆性质，无需调整。此时状态依然是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      3</span><br><span class="line">    /   \</span><br><span class="line">  7      2</span><br><span class="line"> /  \    /</span><br><span class="line">4    1</span><br></pre></td></tr></table></figure></li><li>接着处理索引为 <code>0</code> 的节点（值为 <code>3</code>），它的左子节点是 <code>7</code>，右子节点是 <code>2</code>。比较 <code>3</code> 与 <code>7</code> 和 <code>2</code>，发现 <code>7</code> 最大，所以交换 <code>3</code> 和 <code>7</code> 的位置，得到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      7</span><br><span class="line">    /   \</span><br><span class="line">  3      2</span><br><span class="line"> /  \    /</span><br><span class="line">4    1</span><br></pre></td></tr></table></figure></li><li>交换后，以 <code>3</code> 为根的子树可能不满足大根堆性质了，继续检查调整。此时 <code>3</code> 的左子节点 <code>4</code> 大于 <code>3</code>，所以再次交换 <code>3</code> 和 <code>4</code>，得到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      7</span><br><span class="line">    /   \</span><br><span class="line">  4      2</span><br><span class="line"> /  \    /</span><br><span class="line">3    1</span><br></pre></td></tr></table></figure></li></ul><p>此时整个二叉树就满足大根堆性质了，对应的数组 <code>[7, 4, 2, 3, 1]</code> 就是构建好的大根堆。</p><p>如果要进行整个数组的排序，还要进行多次调整。目前只是把7作为最大的数筛选出来，而其他元素还没有完成排序。</p><blockquote><p>交换堆顶元素和最后一个元素</p></blockquote><ul><li>初始大根堆对应的树状结构为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      7</span><br><span class="line">    /   \</span><br><span class="line">  4      2</span><br><span class="line"> /  \    /</span><br><span class="line">3    1</span><br></pre></td></tr></table></figure>对应的数组为 <code>[7, 4, 2, 3, 1]</code>。</li><li>交换堆顶元素 <code>7</code> 和最后一个元素 <code>1</code>，交换后的树状结构变为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">    /   \</span><br><span class="line">  4      2</span><br><span class="line"> /  \    /</span><br><span class="line">3    7</span><br></pre></td></tr></table></figure>对应的数组变为 <code>[1, 4, 2, 3, 7]</code>。此时最大元素 <code>7</code> 已经在数组末尾位置了，后续要对前面的元素（除了已确定位置的 <code>7</code>）重新调整为大根堆来继续确定次大元素等。</li></ul><blockquote><p>调整剩余元素为大根堆</p></blockquote><ul><li>把交换后的数组中前面 <code>n - 1</code> 个元素（这里 <code>n = 5</code>，即对前 <code>4</code> 个元素 <code>[1, 4, 2, 3]</code>）重新调整为大根堆。</li><li>从根节点（索引为 <code>0</code> ，值为 <code>1</code>）开始，其左子节点是 <code>4</code>，右子节点是 <code>2</code>，比较发现 <code>4</code> 最大，交换 <code>1</code> 和 <code>4</code>，得到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      4</span><br><span class="line">    /   \</span><br><span class="line">  1      2</span><br><span class="line"> /  \    /</span><br><span class="line">3    7</span><br></pre></td></tr></table></figure>对应的数组变为 <code>[4, 1, 2, 3, 7]</code>。</li><li>接着以 <code>1</code> 为根节点检查调整，<code>1</code> 的左子节点 <code>3</code> 大于 <code>1</code>，交换 <code>1</code> 和 <code>3</code>，得到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      4</span><br><span class="line">    /   \</span><br><span class="line">  3      2</span><br><span class="line"> /  \    /</span><br><span class="line">1    7</span><br></pre></td></tr></table></figure>对应的数组变为 <code>[4, 3, 2, 1, 7]</code>，此时前面 <code>4</code> 个元素又构成了大根堆。</li></ul><blockquote><p>重复上述交换和调整步骤</p></blockquote><ul><li>再次交换堆顶元素（此时堆顶元素为 <code>4</code>）和当前最后一个未确定位置的元素（即索引为 <code>3</code> 的元素 <code>1</code>），交换后的树状结构为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">    /   \</span><br><span class="line">  3      2</span><br><span class="line"> /  \    /</span><br><span class="line">4    7</span><br></pre></td></tr></table></figure>对应的数组变为 <code>[1, 3, 2, 4, 7]</code>。</li><li>然后对前面 <code>3</code> 个元素（<code>[1, 3, 2]</code>）重新调整为大根堆，从根节点（索引为 <code>0</code> ，值为 <code>1</code>）开始，其左子节点 <code>3</code> 大于 <code>1</code>，交换 <code>1</code> 和 <code>3</code>，得到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      3</span><br><span class="line">    /   \</span><br><span class="line">  1      2</span><br><span class="line"> /  \    /</span><br><span class="line">4    7</span><br></pre></td></tr></table></figure>对应的数组变为 <code>[3, 1, 2, 4, 7]</code>，此时 <code>1</code> 的左子节点 <code>4</code> 大于 <code>1</code>，但右子节点 <code>2</code> 小于 <code>1</code>，无需再交换，前面 <code>3</code> 个元素构成大根堆。</li></ul><blockquote><p>继续重复</p></blockquote><ul><li>交换堆顶元素（此时堆顶元素为 <code>3</code>）和当前最后一个未确定位置的元素（即索引为 <code>2</code> 的元素 <code>2</code>），交换后的树状结构为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      2</span><br><span class="line">    /   \</span><br><span class="line">  1      3</span><br><span class="line"> /  \    /</span><br><span class="line">4    7</span><br></pre></td></tr></table></figure>对应的数组变为 <code>[2, 1, 3, 4, 7]</code>。</li><li>对前面 <code>2</code> 个元素（<code>[2, 1]</code>），因为 <code>2</code> 大于 <code>1</code>，本身就满足大根堆性质。</li></ul><blockquote><p>最后一次交换</p></blockquote><ul><li>交换堆顶元素（此时堆顶元素为 <code>2</code>）和当前最后一个未确定位置的元素（即索引为 <code>1</code> 的元素 <code>1</code>），交换后的树状结构为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">    /   \</span><br><span class="line">  2      3</span><br><span class="line"> /  \    /</span><br><span class="line">4    7</span><br></pre></td></tr></table></figure>对应的数组变为 <code>[1, 2, 3, 4, 7]</code>，至此整个数组完成升序排序。</li></ul><p>总结：</p><ol><li>首先将给定数组构建成大根堆。</li><li>然后重复交换堆顶元素（最大元素）和当前未排序部分的最后一个元素，接着对交换后除去最后已确定位置元素的剩余元素重新调整为大根堆，不断循环这个交换和调整过程，直到所有元素都确定了最终位置，数组就完成了升序排序。</li></ol><h1 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h1><p>官方定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure><p>T 是存储在优先级队列中的元素类型；Container 是用于存储元素的底层容器类型，默认是 std::vector<T>；Compare 是一个比较对象类型，用于确定元素的优先级顺序，默认是 std::less<typename Container::value_type>，它会按照元素的小于关系来确定优先级，即值越大优先级越高，也可以自定义比较函数或函数对象来改变优先级的判定规则。</p><p>queue里可以塞入各种类型，所以比较大小还得借助模版参数来进行优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Less</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y;  <span class="comment">//具体比较逻辑就需要在各自类里实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就完成了最大值排列和最小值排列。</p><blockquote><p>建堆</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义优先级队列模板类，有三个模板参数</span></span><br><span class="line"><span class="comment">// T表示存储在优先级队列中的元素类型</span></span><br><span class="line"><span class="comment">// Container表示用于存储元素的底层容器类型，默认是vector&lt;T&gt;</span></span><br><span class="line"><span class="comment">// Compare表示用于确定元素优先级顺序的比较对象类型，默认是less&lt;T&gt;，用于按小于关系确定优先级（通常意味着值越大优先级越高）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 向下调整函数，用于维护堆的性质（大根堆为例），从给定的父节点开始向下调整元素位置</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">AdjustDown</span>(<span class="type">int</span> parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建比较对象，用于比较元素的优先级</span></span><br><span class="line">        Compare com;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算父节点parent的左孩子节点索引，在完全二叉树中，左孩子索引为 2 * parent + 1，因为下标此时从0开始</span></span><br><span class="line">        <span class="type">size_t</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只要孩子节点索引小于底层容器中元素个数，说明存在孩子节点，继续循环调整</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt; _con.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果右孩子节点存在（索引不越界），并且通过比较对象判断右孩子的优先级大于左孩子的优先级</span></span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; _con.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">com</span>(_con[child], _con[child + <span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将孩子索引指向右孩子，因为右孩子优先级更高，后续要和父节点比较并可能交换</span></span><br><span class="line">                ++child;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果通过比较对象判断父节点的优先级小于当前孩子节点的优先级（不符合大根堆性质）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">com</span>(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 交换父节点和当前孩子节点的值，以维护大根堆性质</span></span><br><span class="line">                <span class="built_in">swap</span>(_con[child], _con[parent]);</span><br><span class="line">                <span class="comment">// 更新父节点索引为当前孩子节点的索引，继续向下检查交换后的子树是否满足堆性质</span></span><br><span class="line">                parent = child;</span><br><span class="line">                <span class="comment">// 重新计算新的孩子节点索引，继续向下调整过程</span></span><br><span class="line">                child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果当前父节点和孩子节点满足堆性质，不需要再调整，直接退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上调整函数，用于在插入新元素后维护堆的性质，从给定的孩子节点开始向上调整元素位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建比较对象，用于比较元素的优先级</span></span><br><span class="line">        Compare com;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算孩子节点child的父节点索引，在完全二叉树中，父节点索引为 (child - 1) / 2</span></span><br><span class="line">        <span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 只要孩子节点索引大于0，说明不是根节点，继续向上循环调整</span></span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果通过比较对象判断父节点的优先级小于当前孩子节点的优先级（不符合堆性质）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">com</span>(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 交换父节点和当前孩子节点的值，以维护堆性质</span></span><br><span class="line">                <span class="built_in">swap</span>(_con[child], _con[parent]);</span><br><span class="line">                <span class="comment">// 更新孩子节点索引为当前父节点的索引，继续向上检查交换后的子树是否满足堆性质</span></span><br><span class="line">                child = parent;</span><br><span class="line">                <span class="comment">// 重新计算新的父节点索引，继续向上调整过程</span></span><br><span class="line">                parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果当前父节点和孩子节点满足堆性质，不需要再调整，直接退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数，不做任何特殊初始化操作，底层容器会使用其默认构造进行初始化</span></span><br><span class="line">    <span class="built_in">priority_queue</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围构造函数，接受两个迭代器，表示一个范围，用于初始化优先级队列</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">priority_queue</span><span class="params">(InputIterator first, InputIterator last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历给定的迭代器范围，将每个元素插入到底层容器_con中</span></span><br><span class="line">        <span class="keyword">while</span> (first!= last)</span><br><span class="line">        &#123;</span><br><span class="line">            _con.<span class="built_in">push_back</span>(*first);</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建堆，从倒数第一个非叶节点开始，对每个非叶节点调用AdjustDown函数进行向下调整，以构建大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (_con.<span class="built_in">size</span>() - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AdjustDown</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出函数，用于移除优先级队列中的最高优先级元素（队首元素）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将队首元素（根节点）和最后一个元素交换位置，方便移除最高优先级元素</span></span><br><span class="line">        <span class="built_in">swap</span>(_con[<span class="number">0</span>], _con[_con.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 移除最后一个元素，即原来的队首元素（最高优先级元素）</span></span><br><span class="line">        _con.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对新的根节点调用AdjustDown函数进行向下调整，以维护堆的性质</span></span><br><span class="line">        <span class="built_in">AdjustDown</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入函数，用于向优先级队列中插入一个新元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将新元素插入到底层容器的末尾</span></span><br><span class="line">        _con.<span class="built_in">push_back</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对新插入的元素（在容器末尾，即最后一个位置）调用AdjustUp函数进行向上调整，以维护堆的性质</span></span><br><span class="line">        <span class="built_in">AdjustUp</span>(_con.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最高优先级元素（队首元素）的函数，返回元素的常引用，不允许通过此引用修改元素</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断优先级队列是否为空的函数，如果底层容器为空则返回true，表示队列为空，否则返回false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取优先级队列中元素个数的函数，返回底层容器中元素的数量</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _con.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用于存储元素的底层容器，类型由模板参数Container指定，默认是vector&lt;T&gt;</span></span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List的简单模拟实现</title>
      <link href="/2024/12/15/cpp-list%20implement/"/>
      <url>/2024/12/15/cpp-list%20implement/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是list？"><a href="#什么是list？" class="headerlink" title="什么是list？"></a>什么是list？</h1><p>在C++中，list 是一种双向链表（doubly linked list）数据结构，它属于标准模板库（STL）的一部分。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734224872939.png'><blockquote><p>添加元素</p></blockquote><p>push_back(const T&amp; value): 在链表末尾添加一个元素。<br>push_front(const T&amp; value): 在链表开头添加一个元素。<br>insert(iterator pos, const T&amp; value): 在指定位置插入一个元素。</p><blockquote><p>删除元素</p></blockquote><p>pop_back(): 删除链表末尾的元素。<br>pop_front(): 删除链表开头的元素。<br>erase(iterator pos): 删除指定位置的元素。<br>erase(iterator first, iterator last): 删除指定范围内的元素。<br>remove(const T&amp; value): 删除所有等于指定值的元素。</p><blockquote><p>访问元素</p></blockquote><p>begin(): 返回指向链表第一个元素的迭代器。<br>end(): 返回指向链表末尾之后位置的迭代器（<code>哨兵迭代器，不指向有效元素</code>）。<br>rbegin(): 返回指向链表最后一个元素的反向迭代器。<br>rend(): 返回指向链表开头之前位置的反向迭代器。</p><blockquote><p>获取链表大小</p></blockquote><p>size(): 返回链表中元素的数量。</p><blockquote><p>判断链表是否为空</p></blockquote><p>empty(): 如果链表为空，则返回true；否则返回false。</p><blockquote><p>清空链表</p></blockquote><p>clear(): 删除链表中的所有元素，使链表变为空。</p><p>简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">    myList.<span class="built_in">insert</span>(myList.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">15</span>); <span class="comment">// 在第二个位置插入15</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出链表内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    myList.<span class="built_in">pop_back</span>(); <span class="comment">// 删除末尾元素</span></span><br><span class="line">    myList.<span class="built_in">erase</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 删除开头元素</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 再次输出链表内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 判断链表是否为空并清空链表</span></span><br><span class="line">    <span class="keyword">if</span> (!myList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        myList.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;链表是否为空: &quot;</span> &lt;&lt; (myList.<span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h1><h2 id="listnode类和list类"><a href="#listnode类和list类" class="headerlink" title="listnode类和list类"></a>listnode类和list类</h2><p>注意，listnode和list都是一个模板类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">listnode</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> listnode&lt;T&gt; node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">listnode</span>(<span class="type">const</span> T &amp; value):<span class="built_in">l_value</span>(value),<span class="built_in">prev</span>(<span class="literal">nullptr</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">~<span class="built_in">listnode</span>()&#123;&#125;;</span><br><span class="line">    <span class="comment">//这里为了方便直接把node的成员公开给list和iterator使用，也可以放弃class写法改用结构体</span></span><br><span class="line">T l_value;</span><br><span class="line">node* prev; <span class="comment">//每个节点都有自己的value，指向前后节点的指针</span></span><br><span class="line">node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> listnode&lt;T&gt; node;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">list</span>():<span class="built_in">l_head</span>(<span class="literal">nullptr</span>),<span class="built_in">l_tail</span>(<span class="literal">nullptr</span>),<span class="built_in">l_size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">~<span class="built_in">list</span>() &#123; <span class="built_in">clear</span>(); &#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">node* l_head;</span><br><span class="line">node* l_tail;  <span class="comment">//l_head和l_tail分别指向第一个和最后一个node</span></span><br><span class="line"><span class="type">int</span> l_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> newnode = <span class="keyword">new</span> <span class="built_in">node</span>(value); <span class="comment">//要插入就得先new一个node</span></span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>) &#123;</span><br><span class="line">l_head = l_tail = newnode;</span><br><span class="line">l_size++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;           <span class="comment">//指针的变换比较绕，建议初学在纸上画一画</span></span><br><span class="line">l_head-&gt;prev = newnode;  </span><br><span class="line">newnode-&gt;next = l_head;</span><br><span class="line">l_head = newnode;</span><br><span class="line">l_size++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> l_head;</span><br><span class="line">l_head = l_tail = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> head = l_head-&gt;next; <span class="comment">//要提前保存l_head的下个节点，不然删掉l_head所指的node后就找不到头</span></span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> l_head;</span><br><span class="line">l_head = head;</span><br><span class="line">l_size--;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> newnode = <span class="keyword">new</span> <span class="built_in">node</span>(value);</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>) &#123;</span><br><span class="line">l_head = l_tail = newnode;</span><br><span class="line">l_size++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">l_tail-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = l_tail;</span><br><span class="line">l_tail = newnode;</span><br><span class="line">l_size++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> l_tail;</span><br><span class="line">l_tail = l_head = <span class="literal">nullptr</span>;</span><br><span class="line">l_size--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> tail = l_tail-&gt;prev;</span><br><span class="line">tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> l_tail;</span><br><span class="line">l_tail = tail;</span><br><span class="line">l_size--;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">## 迭代器</span><br><span class="line"></span><br><span class="line">因为list是双向链表，想要实现list的+或者-等操作就必须借助迭代器的实现。</span><br><span class="line"></span><br><span class="line">&gt;正向迭代器</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">listiterator</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">list</span>&lt;T&gt;;  <span class="comment">//因为list会访问该类私有成员，所以做了友元的处理。</span></span><br><span class="line"><span class="keyword">typedef</span> listnode&lt;T&gt; node;</span><br><span class="line"><span class="keyword">typedef</span> listiterator iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">listiterator</span>() :<span class="built_in">l_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">listiterator</span>(node* pointer) :<span class="built_in">l_pointer</span>(pointer) &#123;&#125;;</span><br><span class="line">~<span class="built_in">listiterator</span>() &#123;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> iterator&amp; other) &#123;</span><br><span class="line"><span class="keyword">return</span> l_pointer == other.l_pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> iterator&amp; other) &#123;</span><br><span class="line"><span class="keyword">return</span> l_pointer != other.l_pointer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">iterator&amp; <span class="keyword">operator</span> =(<span class="type">const</span> iterator&amp; other) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">l_pointer = other.l_pointer;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iterator&amp; <span class="keyword">operator</span> ++() &#123;  <span class="comment">//前置++</span></span><br><span class="line">l_pointer = l_pointer-&gt;next;  <span class="comment">//先加了再用</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iterator&amp; <span class="keyword">operator</span> ++(<span class="type">int</span>) &#123;  <span class="comment">//后置++</span></span><br><span class="line">iterator it = *<span class="keyword">this</span>; </span><br><span class="line">++(*<span class="keyword">this</span>);   </span><br><span class="line"><span class="keyword">return</span> it;  <span class="comment">//返回的是没加的那个，先用了再加</span></span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> +(<span class="type">int</span> n) &#123;</span><br><span class="line">iterator it = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">++it;    <span class="comment">//先实现++，在实现+就可以复用++</span></span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> += (<span class="type">int</span> n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">++(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> -- () &#123;</span><br><span class="line">l_pointer = l_pointer-&gt;prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> --(<span class="type">int</span>) &#123;</span><br><span class="line">iterator it = *<span class="keyword">this</span>;</span><br><span class="line">--(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> -(<span class="type">int</span> n) &#123;</span><br><span class="line">iterator it = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">--it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> -=(<span class="type">int</span> n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">--(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span> *() &#123;</span><br><span class="line"><span class="keyword">return</span> l_pointer-&gt;l_value;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span> -&gt;() &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(l_pointer-&gt;l_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">node* l_pointer; <span class="comment">//迭代器包含一个指向node的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>反向迭代器</p></blockquote><p>照着正向的修改几个地方就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">listreverseiterator</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> listnode&lt;T&gt; node;</span><br><span class="line"><span class="keyword">typedef</span> listreverseiterator iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">listreverseiterator</span>() :<span class="built_in">l_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">listreverseiterator</span>(node* pointer) :<span class="built_in">l_pointer</span>(pointer) &#123;&#125;;</span><br><span class="line">~<span class="built_in">listreverseiterator</span>() &#123;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> iterator&amp; other) &#123;</span><br><span class="line"><span class="keyword">return</span> l_pointer == other.l_pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> iterator&amp; other) &#123;</span><br><span class="line"><span class="keyword">return</span> l_pointer != other.l_pointer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">iterator&amp; <span class="keyword">operator</span> =(<span class="type">const</span> iterator&amp; other) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">l_pointer = other.l_pointer;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iterator&amp; <span class="keyword">operator</span> ++() &#123;</span><br><span class="line">l_pointer = l_pointer-&gt;prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iterator&amp; <span class="keyword">operator</span> ++(<span class="type">int</span>) &#123;</span><br><span class="line">iterator it = *<span class="keyword">this</span>;</span><br><span class="line">++(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> +(<span class="type">int</span> n) &#123;</span><br><span class="line">iterator it = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">++it;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> += (<span class="type">int</span> n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">++(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> -- () &#123;</span><br><span class="line">l_pointer = l_pointer-&gt;next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> --(<span class="type">int</span>) &#123;</span><br><span class="line">iterator it = *<span class="keyword">this</span>;</span><br><span class="line">--(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> -(<span class="type">int</span> n) &#123;</span><br><span class="line">iterator it = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">--it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span> -=(<span class="type">int</span> n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">--(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span> *() &#123;</span><br><span class="line"><span class="keyword">return</span> l_pointer-&gt;l_value;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span> -&gt;() &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(l_pointer-&gt;l_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">node* l_pointer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来完善list：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> listnode&lt;T&gt; node;</span><br><span class="line"><span class="keyword">typedef</span> listiterator&lt;T&gt; iterator;  <span class="comment">//加入迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> listreverseiterator&lt;T&gt; rverseiterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(l_head);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>);  <span class="comment">//end指向list最后一个元素的后一个，也就是空，更严谨的写应该是l_tail-&gt;next</span></span><br><span class="line">        <span class="comment">//rbegin和rend就不再赘述</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="find，insert和erase函数"><a href="#find，insert和erase函数" class="headerlink" title="find，insert和erase函数"></a>find，insert和erase函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> newnode = l_head;</span><br><span class="line"><span class="keyword">while</span> (newnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (newnode-&gt;l_value == value)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(newnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(pos, <span class="number">1</span>, value); <span class="comment">//直接复用插入n个相同值的insert，见下面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">int</span> n,<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="built_in">begin</span>()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">push_front</span>(value);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> tail = l_tail;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">push_back</span>(value);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(tail-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">auto</span> newnode = <span class="keyword">new</span> <span class="built_in">node</span>(value);</span><br><span class="line"><span class="keyword">auto</span> tmpprev = pos.l_pointer-&gt;prev;</span><br><span class="line">newnode-&gt;prev = tmpprev;</span><br><span class="line">tmpprev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;next = pos.l_pointer;</span><br><span class="line">pos.l_pointer-&gt;prev = newnode;</span><br><span class="line">pos.l_pointer = newnode;</span><br><span class="line">&#125;</span><br><span class="line">l_size += n;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="built_in">begin</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> node = l_head;</span><br><span class="line"><span class="keyword">if</span> (l_size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">l_head = l_head-&gt;next;</span><br><span class="line">l_head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">delete</span> l_head;</span><br><span class="line">l_head = l_tail = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">l_size--;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="built_in">end</span>()) &#123; <span class="comment">//本来就是无效位置</span></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> newnode = pos.l_pointer;</span><br><span class="line"><span class="keyword">if</span> (newnode-&gt;prev != <span class="literal">nullptr</span>)</span><br><span class="line">newnode-&gt;prev-&gt;next = newnode-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (newnode-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">newnode-&gt;next-&gt;prev = newnode-&gt;prev;</span><br><span class="line"><span class="keyword">auto</span> tmp = newnode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> newnode;</span><br><span class="line">l_size--;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = first; it != last; it++) &#123;</span><br><span class="line"><span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="补充函数"><a href="#补充函数" class="headerlink" title="补充函数"></a>补充函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> l_size == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> l_size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;list is empty&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> l_head-&gt;l_value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;list is empty&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> l_head-&gt;l_value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;list is empty&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> l_tail-&gt;l_value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;list is empty&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> l_tail-&gt;l_value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">pop_back</span>();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> current = l_head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;l_value == value) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是头节点</span></span><br><span class="line">            <span class="keyword">if</span> (current == l_head) &#123;</span><br><span class="line">                <span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点是尾节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == l_tail) &#123;</span><br><span class="line">                <span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点在中间</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> prev = current-&gt;prev;</span><br><span class="line">                <span class="keyword">auto</span> next = current-&gt;next;</span><br><span class="line">                prev-&gt;next = next;</span><br><span class="line">                next-&gt;prev = prev;</span><br><span class="line">                <span class="keyword">delete</span> current;</span><br><span class="line">                l_size--;</span><br><span class="line">                current = next; <span class="comment">// 更新当前节点为下一个节点，因为上一个已被删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt; l_size) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l_size - size; i++)</span><br><span class="line"><span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &gt; l_size) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - l_size; i++)</span><br><span class="line"><span class="built_in">push_back</span>(<span class="built_in">T</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&lt;T&gt;&amp; other)</span> </span>&#123;</span><br><span class="line">l_tail-&gt;next = other.l_head;</span><br><span class="line">other.l_head-&gt;prev = l_tail;</span><br><span class="line">l_tail = other.l_tail;</span><br><span class="line">l_size += other.l_size;</span><br><span class="line">other.l_head = other.l_tail = <span class="literal">nullptr</span>;</span><br><span class="line">other.l_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(list&lt;T&gt;&amp; other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">auto</span> head = other.l_head;</span><br><span class="line"><span class="keyword">auto</span> tail = other.l_tail;</span><br><span class="line"><span class="keyword">auto</span> size = other.l_size;</span><br><span class="line">other.l_head = l_head;</span><br><span class="line">other.l_tail = l_tail;</span><br><span class="line">other.l_size = l_size;</span><br><span class="line">l_head = head;</span><br><span class="line">l_tail = tail;</span><br><span class="line">l_size = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l_size == <span class="number">0</span> || l_size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">auto</span> head = l_head;</span><br><span class="line"><span class="keyword">auto</span> tail = l_tail;</span><br><span class="line"><span class="keyword">auto</span> node = l_tail;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> tmpprev = node-&gt;prev;</span><br><span class="line"><span class="keyword">auto</span> tmpnext = node-&gt;next;</span><br><span class="line">node-&gt;next = tmpprev;</span><br><span class="line">node-&gt;prev = tmpnext;</span><br><span class="line">node = tmpprev;</span><br><span class="line">&#125;</span><br><span class="line">l_head = tail;</span><br><span class="line">l_tail = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个进程的诞生(bushi)</title>
      <link href="/2024/12/14/linux-createprocess/"/>
      <url>/2024/12/14/linux-createprocess/</url>
      
        <content type="html"><![CDATA[<blockquote><p>打开电脑手机，一个个app眼花缭乱地出现在程序坞里，外卖app，打车app，王者荣耀……在使用这些应用方便你的生活的同时，你是否好奇过这一串串代码是通过怎样的流程变成眼前的程序的呢？</p></blockquote><h1 id="程序的编译，链接与装入"><a href="#程序的编译，链接与装入" class="headerlink" title="程序的编译，链接与装入"></a>程序的编译，链接与装入</h1><p>当程序员编写好代码，源代码文件也就形成了。大到成千上万行，小到“hello world”，都是一个个源代码文件。经过<code>编译程序</code>将源代码编译成若干个目标模块，编译过程将高级语言翻译为机器语言，即生成CPU能够识别的指令。再由<code>链接程序</code>将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块（可执行文件）。链接过程将各个目标模块整合为一个整体，以便后续装入内存执行。这就是程序执行的第一步。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/224ca23b17cbde7ea18e99d4aa12c99.jpg'>[图源王道操作系统讲义]<p>可以看到，当编辑好不同的模块时，其逻辑地址都是独立的，从0开始。而链接的工作就是形成一个<code>完整的逻辑地址</code>。链接主要分为三种：静态链接，装入时动态链接，运行时动态链接，现在较为常用的是第三种。</p><p>运行时动态链接是指在程序运行时，由操作系统的装载程序（如Windows的Loader或Linux的ld.so）负责将程序的各个模块加载到内存中，并解析它们之间的引用关系。比如当程序需要调用某个库函数时，操作系统会查找并加载相应的动态链接库，然后通过<code>符号表</code>找到函数的入口地址，并进行跳转执行。</p><p>先讲讲静态链接。静态链接本质上就是将源文件a.c,b.c等文件打包成.o文件的集合，一个<code>.a</code>文件，再和要调用它们的.o文件(比如main.o)一起进行链接，形成一个可执行文件。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734844403478.png'><br>例如在Linux 环境下，创建一个简单的 <code>mymath</code> 库并在 <code>main</code> 函数中进行调用：</p><ol><li>创建 <code>mymath</code> 库的源文件<br>首先创建 <code>add.c</code> 文件和<code>sub.c</code>文件，代码如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sub.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建头文件<br>接着创建对应的头文件用于声明库中的函数，以便在其他源文件中可以正确调用这些函数。代码如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mymath.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>编译生成静态库（<code>.a</code> 文件）</li></ol><ul><li><p><strong>编译 <code>add.c</code> 文件生成目标文件（<code>.o</code> 文件）</strong>：<br>在命令行中执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc -c sub.c -o sub.o   //-c 选项表示只进行编译而不进行链接操作。</span><br></pre></td></tr></table></figure></li><li><p><strong>将目标文件打包成静态库</strong>：<br>使用 <code>ar</code> 命令将目标文件打包成静态库，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmymath.a add.o sub.o</span><br></pre></td></tr></table></figure><p><code>ar</code> 是用于创建、修改和提取归档文件（在 Linux 下静态库本质上就是一种归档文件）的工具，<code>rs</code>代表replace and create，<code>s</code> 选项表示生成索引以加快库的链接速度。最终生成的静态库文件名为 <code>libmymath.a</code>。</p></li></ul><ol start="4"><li>创建使用库的主程序文件<br>创建 <code>main.c</code> 文件来调用 <code>mymath</code> 库中的函数，代码如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymath.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result_add = add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> result_sub = sub(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The result of adding 5 and 3 is: %d\n&quot;</span>, result_add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The result of subtracting 3 from 5 is: %d\n&quot;</span>, result_sub);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>编译并链接主程序与库文件<br>在命令行中执行以下命令来编译并链接 <code>main.c</code> 和 <code>libmymath.a</code> 库：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -lmymath -o main</span><br></pre></td></tr></table></figure><code>-L.</code> 选项告诉编译器在当前目录（<code>.</code> 表示当前目录）下查找库文件，<code>-lmymath</code> 表示链接名为 <code>mymath</code> 的库（按照约定，编译器在链接时会自动在库名前添加 <code>lib</code> 前缀并寻找对应的 <code>.a</code> 或 <code>.so</code> 文件等），<code>-o main</code> 选项指定生成的可执行文件名为 <code>main</code>。</li></ol><p>最后，运行生成的可执行文件 <code>main</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>就可以看到程序输出计算的结果了。<br>而动态链接在程序编译时，并不会把库文件的代码和数据复制到可执行文件中，而是在程序运行时，当需要调用库中的函数或使用库中的数据时，才动态地加载库文件，并将所需的代码和数据链接到程序的内存空间中，这点和静态链接是不同的。<br>如果想创建动态共享库（<code>.so</code> 文件），步骤和静态相比稍有不同，大致流程如下：</p><ol><li>创建动态共享库</li></ol><ul><li><p><strong>编译生成位置无关代码（PIC）的目标文件</strong>：<br>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c mymath.c -o add.o</span><br><span class="line">gcc -fPIC -c mymath.c -o sub.o</span><br></pre></td></tr></table></figure><p><code>-fPIC</code>（Position Independent Code）选项用于生成位置无关的代码。</p></li><li><p><strong>创建动态共享库文件</strong>：<br>使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libmymath.so add.o sub.o</span><br></pre></td></tr></table></figure><p><code>-shared</code> 选项告诉编译器创建一个动态共享库，最终生成 <code>libmymath.so</code> 文件。</p></li></ul><ol start="2"><li>使用动态共享库</li></ol><ul><li><strong>编译主程序并链接动态共享库</strong>：<br>执行命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -lmymath -o main</span><br></pre></td></tr></table></figure>在运行程序时，需要确保动态库的路径能被系统找到，可以通过设置 <code>LD_LIBRARY_PATH</code> 环境变量来指定动态库所在路径，例如（假设当前目录就是动态库所在目录,所以以.来代表该路径）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:.  </span><br></pre></td></tr></table></figure><blockquote><p>补充：在Linux系统中，环境变量是一种用于存储系统或用户相关配置信息的机制。这些变量可以被系统中的各个程序访问，并且它们的值会影响程序运行时的行为。例如，PATH 环境变量就指定了系统在哪些目录下去查找可执行程序，当在终端输入命令时，系统会根据 PATH 中设定的目录顺序去查找对应的可执行文件来执行。<br>LD_LIBRARY_PATH 则是专门用于指定动态链接库搜索路径的环境变量。当一个程序在运行过程中需要加载动态链接库时，系统就会按照一定规则去查找这些库文件。</p></blockquote></li></ul><p>或者直接将动态库拷贝到系统默认的库搜索路径下（如 <code>/usr/lib</code> 等，需要管理员权限来操作）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> libmymath.so /usr/local/lib</span><br></pre></td></tr></table></figure><p>经过链接，程序也就形成了一个具备完整地址的源文件。<br>然后执行装入，顾名思义，装入就是将一整个模块装入内存运行。<br>装入也有三种类型：</p><blockquote><p>绝对装入</p></blockquote><p>在编译时，程序员必须知道目标程序在内存中的<code>起始地址</code>，并生成与这个地址绑定的绝对代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<br>这种方式仅适用于<code>单道程序</code>环境，因为在这种环境下，内存中只有一个程序在运行，内存位置是固定的。</p><blockquote><p>可重定位装入（静态重定位）</p></blockquote><p>编译时，生成的目标代码地址是相对地址，即相对于某个基准点的<code>偏移量</code>。<br>装入时，装入程序根据内存的当前情况，将相对地址转换为绝对地址。这一步通过内存管理部件(MMU)实现，此机制对用户是完全透明的。<br>如果装入后的内存空间不够，可以通过紧凑（将各个程序在内存中“搬家”，使它们紧凑地排列在一起）或覆盖（将程序划分为多个段，每次只将需要执行的段调入内存）等技术来解决。</p><blockquote><p>动态运行时装入（动态重定位）</p></blockquote><p>程序在内存中的起始地址在编译时和装入时都不确定，而是在程序执行时才确定。<br>装入程序将程序装入一个连续的内存区域，并设置一个重定位寄存器，用于存放程序的起始地址。<br>程序执行时，通过重定位寄存器和相对地址计算出实际的内存地址。</p><p>$静态重定位与动态重定位区别$<br>静态重定位是在程序装入内存时，<code>一次性</code>完成逻辑地址到物理地址的转换，之后程序在运行过程中<code>不再改变</code>这些地址。这种方式需要预先分配全部所需内存空间，并且程序在运行期间不能移动或再申请内存空间。而动态重定位则是在程序运行过程中，每当需要访问内存时，才进行逻辑地址到物理地址的转换。当程序装入内存时，只装入相对地址，<code>不立即进行地址转换</code>。在程序执行过程中，通过硬件地址转换机构（如重定位寄存器）和相应的软件支持，动态地完成地址转换。例如执行每条指令都需要从逻辑地址去算出它的物理地址，链接形成的逻辑地址加上规定寄存器(常用重定位寄存器，基址寄存器)的值就会得到真实的物理地址。</p><blockquote><p>TIPS:物理地址是内存物理单元的地址，所有进程运行时需要的指令和数据都需要通过物理地址从内存中取。而逻辑地址(不太严谨的话，可以将逻辑地址，虚拟地址，相对地址画等号)是在链接时从0单元开始编址的空间，是虚拟的。</p></blockquote><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>此时程序已经进入了内存，具备进程(进行中的程序)的雏形。操作系统为每个新进程创建一个PCB，这是操作系统管理和跟踪进程的核心数据结构。<br>在Linux系统里，task_struct就是PCB。task_struct是Linux内核中的<code>进程描述符</code>，用于存储与进程相关的信息。它是感知进程存在的唯一实体，包含了进程的各种属性和状态信息。<code>每个进程</code>在内核中都有一个对应的task_struct结构体。这个结构体包含了进程的标识符（PID）、进程状态、进程权限、进程调度信息、信号处理信息、内存管理信息（如指向mm_struct的指针）等。<br>在task_struct结构体中，有一个名为mm的字段，它是一个指向mm_struct结构体的指针。这个字段用于关联进程描述符和进程的内存描述符。对于普通的用户进程来说，mm字段指向该进程的<code>虚拟地址空间</code>的用户空间部分；而对于内核线程来说，这个字段为NULL，因为内核线程没有独立的内存地址空间（它们使用内核的地址空间，并且所有进程关于内核的映射都是一样的）。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734168410041.png'><br>如图，mm_struct包含了代码段，数据段，堆栈等区域的地址信息。<br>mm_struct是Linux内核中的<code>内存描述符</code>，用于描述进程的<code>虚拟地址空间</code>。它包含了与进程内存管理相关的各种信息，如进程的页表、内存区域的链表（通过vm_area_struct结构体描述）、内存映射的基地址和结束地址(如上图展示)、进程的内存使用情况统计等。</p><p>$虚拟地址空间$<br>进程的虚拟地址空间是地址空间的一个实例，特定于每个运行的进程。它是操作系统提供的虚拟内存管理的核心组成部分，用于将进程的<code>数据和指令</code>存放在内存中，并提供内存保护、地址映射、隔离等功能。每个进程的地址空间在逻辑上独立，允许多个进程<code>并发</code>执行，并且它们各自拥有自己的地址空间。<br>进程地址空间用于描述一个正在运行的进程在内存中的布局和管理方式。每个进程都有其自己的地址空间，它是虚拟内存的抽象表示，允许进程访问物理内存上的数据和指令。<br>本质上，进程地址空间就是在描述一个进程的<code>可视范围</code>的大小。同时在空间内必须要进行<code>区域的划分</code>。<br>进程地址空间通常包括以下组成部分：</p><blockquote><p>代码段（Text Segment）：也称为可执行段，包含进程的可执行指令。这是程序的机器代码，通常是<code>只读</code>的，因为它应该在运行时不被修改。<br>数据段（Data Segment）：用于<code>存储进程的全局和静态变量</code>。这包括初始化的全局变量和静态变量，通常是<code>可读写</code>的。<br>堆（Heap）：用于<code>动态分配内存</code>，通常在运行时通过函数（如malloc和free）来进行内存分配和释放。堆的大小通常是可变的，取决于进程的需求。<br>栈（Stack）：用于<code>存储函数调用的局部变量和函数的调用信息</code>。栈是一个后进先出（LIFO）数据结构，用于跟踪函数的调用和返回。栈的大小通常是固定的或者由操作系统动态管理。<br>堆栈区域之间的未映射空间（Unmapped Area Between Heap and Stack）：这是两者之间的空闲区域，用于防止堆和栈之间的溢出。<br>内核空间（Kernel Space）：这是由操作系统控制的部分内存，包含操作系统内核的代码和数据。<code>用户进程不能直接访问内核空间</code>，而必须通过<code>系统调用</code>来请求内核执行操作。</p></blockquote><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1dc771cc018a3392c4bdb491eee9593.png'><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734169782492.png'>[图源王道操作系统讲义]<blockquote><p>总结：task_struct就是Linux里的PCB，负责管理进程的运行。而在task_struct中存在一个mm字段指向mm_struct,其一个功能就是保存当前进程的虚拟地址空间的地址信息(内存映像)。</p></blockquote><p>这里的虚拟地址和链接时形成的逻辑地址又有区别。<br>进程的虚拟地址空间是操作系统为<code>每个进程</code>分配的一个<code>独立的、连续的</code>内存地址范围。它包含了进程的代码段、数据段、堆、栈等各个部分。虚拟地址空间的主要目的是提供内存隔离和保护，确保每个进程只能访问自己的内存空间，防止进程间相互干扰。<br>而链接时形成的逻辑地址是程序在编译或链接时由编译器或链接器生成的，用于在程序的运行过程中定位数据或指令。它并不直接对应物理内存中的实际位置，而是经过一系列转换后，才能映射到物理地址上。逻辑地址的主要作用是提供一个统一的、与物理内存无关的地址空间，<code>简化编程</code>工作。<br>每个进程的虚拟地址空间是独立的，且通常远大于物理内存的大小。操作系统通过虚拟内存技术（如分页和分段）将虚拟地址映射到物理地址上，实现内存的动态分配和访问控制。逻辑地址是程序内部的地址表示方式，它并不直接映射到物理地址上。在程序执行过程中，操作系统或硬件会将逻辑地址转换为物理地址，以实现数据的实际访问。</p><blockquote><p>TIPS:其实没必要太过纠结虚拟地址和逻辑地址的本质区别，想要深究就得多研读《深入理解linux内核》这样的书籍。</p></blockquote><p>创建完PCB，操作系统还会为进程分配额外的内存空间，如堆栈、数据区等。根据进程的初始执行需求，设置CPU寄存器的内容，如堆栈指针、指令指针等。如果进程是由另一个进程（父进程）创建的，操作系统会建立父子进程之间的关系，包括进程间的通信机制（如管道、消息队列等）和信号传递机制。</p><p>至此，一个基本的进程也就创建完成。每个进程的地址空间<code>都是虚拟</code>的，它将虚拟地址映射到物理内存上，这一步由操作系统的内存管理单元（MMU）来完成。<code>MMU负责将虚拟地址转换为物理地址（中间会用到页表）</code>，同时实现了内存保护和隔离，确保一个进程在执行时无法访问或干扰其他进程的地址空间。</p><h1 id="虚拟地址到物理地址的映射"><a href="#虚拟地址到物理地址的映射" class="headerlink" title="虚拟地址到物理地址的映射"></a>虚拟地址到物理地址的映射</h1><p>等待施工。。。。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识进程</title>
      <link href="/2024/12/13/linux-process/"/>
      <url>/2024/12/13/linux-process/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>在了解进程前，还得介绍一下操作系统。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>操作系统是计算机系统中的一种重要软件，它是计算机<code>硬件和软件</code>之间的桥梁，负责管理计算机系统的各种资源，如CPU、内存、输入输出设备等。操作系统可以被看作是计算机系统的管理者，它控制和协调计算机系统中各个部件的工作，使得应用程序能够正确地运行。</p><p>操作系统通常包括以下几个组成部分：</p><ol><li>内存管理：负责管理计算机系统的内存资源，包括内存的分配、释放和保护等。</li><li><code>进程管理</code>：负责管理计算机系统中的进程，包括进程的创建、调度、同步和通信等。</li><li>文件系统：负责管理计算机系统中的文件和目录，包括文件的读写、创建、删除和保护等。</li><li>输入输出管理：负责管理计算机系统中的输入输出设备，包括输入输出的缓存、设备的分配和释放等。</li></ol><p>维基百科这样总结操作系统：<code>操作系统</code>（Operating System，缩写：OS）是一组<code>主管并控制</code>计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的<code>内核</code>与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。<br>操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统。许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了<code>图形用户界面</code>，而有些仅使用<code>命令行界面</code>，将图形用户界面视为一种非必要的应用程序。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png'><br>计算机系统中都包含且存在的一个基本的<code>程序集合</code>，就被称为操作系统。其根本目的就在于为用户<code>提供一个相对方便的操作环境，管理计算机的软硬件资源</code>。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>在20世纪40年代初期，计算机系统还处于非常初级的阶段，计算机的应用也非常有限。直到1945年，约翰·冯·诺伊曼提出了<code>冯洛伊曼体系</code>，这一体系彻底改变了计算机系统的结构和设计，开创了计算机技术的新时代。</p><p>随着计算机技术的不断发展，计算机系统的规模和复杂度也不断增加，操作系统的概念也随之出现。20世纪60年代初期，IBM公司发布了第一款商用操作系统——OS&#x2F;360，这标志着操作系统开始进入商用化阶段。</p><p>从此以后，操作系统和冯洛伊曼体系的发展就开始了新的篇章。随着计算机技术的不断进步，操作系统和冯洛伊曼体系也不断更新和演化，逐步适应了现代计算机系统的各种应用场景和技术需求。<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">[冯诺依曼体系结构设计概念]</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>我们如今所能使用的<code>大部分计算机</code>，都遵循这冯诺依曼体系。但冯诺依曼结构并非这一节的重点，我们只需要知道，memory指的是存储器，也就是常谈的<code>内存</code>！</p><blockquote><p>所有程序都是必须放到内存中去进行的！</p></blockquote><p>这是因为计算机的<code>CPU只能直接访问内存中的数据和指令</code>，而无法直接访问硬盘等外部存储设备中的数据和指令。因此，为了使程序能够被CPU执行，必须先将程序加载到内存中。<br>当程序被加载到内存中后，CPU可以通过<code>内存地址</code>来访问程序的指令和数据。而内存的访问速度比硬盘等外部存储设备的访问速度要快很多，所以将程序加载到内存中可以提高程序的运行效率。<br>程序加载到内存中运行是计算机系统必须遵循的<code>基本原则</code>，也是现代计算机系统高效运行的重要保障。这样做也可以提高程序间的并发能力，也提高了程序的安全性与稳定性。</p><blockquote><p>而内存的管理，又正好是操作系统的工作。</p></blockquote><p>而要谈的主题——进程，简单的说就是<code>运行的程序</code>，也就是加载到内存中的程序，这是需要操作系统进行协调控制的。<br>计算机作为<code>管理者</code>，驱动程序就是<code>执行者</code>，各种软硬件资源就是<code>被管理者</code>。管理者和被管理者并不需要见面，就像学校里你不用与校长见面，在公司也大概率不会见老板，你们之间的协调是通过辅导员或组长来完成的，而在计算机系统中，这个过程就交由程序作为执行者来完成。<br><code>系统调用</code>则作为操作系统与程序之间的<code>接口</code>，它将操作系统的底层功能暴露给程序，使得程序可以直接调用操作系统提供的服务和资源。系统调用是程序实现系统级别功能的重要手段之一。</p><p>操作系统在进程方面的作用可以简单的概括为：<code>先描述进程，再组织进程</code>。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>何为描述？又何为组织？</p><blockquote><p>进程是指正在运行的程序实例，它包含了程序代码、数据和执行状态等信息。操作系统需要对进程进行管理，包括创建、调度、终止、通信等操作。为了对进程进行管理，操作系统需要<code>先对进程进行描述</code>，即确定进程的<code>属性和状态</code>，如进程ID、优先级、状态等。进程描述通常由<code>进程控制块（Process Control Block，PCB）</code>来完成。</p></blockquote><p>在进程描述的基础上，操作系统需要对进程进行组织，以便<code>进行管理和调度</code>。进程可以组织成多种形式，如进程队列、进程树等。进程队列是指将同类进程组织到一起，如就绪队列、等待队列等。进程树是指将进程按照父子关系组织起来，形成树形结构。<br>举个例子，当一个进程需要被调度时，操作系统可以根据进程的属性和状态，选择合适的调度算法将进程调度到CPU上执行。同时，操作系统还可以通过进程间通信等机制，实现进程之间的数据共享和协作。</p><blockquote><p>一个进程等于<code>PCB</code>加上自己的<code>数据与代码</code>。</p></blockquote><p>当一个进程需要被加载到内存中去时，首先会创建一个描述进程的结构体对象，也就是PCB。</p><p>PCB通常包含以下信息：</p><ol><li>进程状态：表示进程当前的状态，如就绪、运行、等待等。</li><li>进程标识：标识进程的唯一标识符，如<code>进程ID、父进程ID</code>等。</li><li>寄存器值：保存进程在执行过程中各个寄存器的值，如程序计数器、堆栈指针等。</li><li>进程优先级：表示进程的优先级，用于调度器进行进程调度。</li><li>进程资源：表示进程所占用的资源，如打开的文件、分配的内存等。</li><li>进程调度信息：包含了进程的调度信息，如进程的调度时间片、已执行的CPU时间等。</li></ol><p>Linux操作系统下的PCB叫做<code>task_struct</code>。<br>task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里且包含着进程的信息。</p><p>在task_struct里常有以下的内容：<br>标示符: 描述本进程的唯一标示符，用来区别其他进程。<br>状态: 任务状态。<br>优先级: 相对于其他进程的优先级。<br>程序计数器: 程序中即将被执行的<code>下一条</code>指令的地址。<br>内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</p><p>除此之外还有上下文数据，记账信息等等。</p><p>可以通过proc指令查看进程,或者ps，top等用户级工具。<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B3.png"></p><p>也可以通过系统调用的方法来获取进程的<code>pid（进程id）</code>以及<code>ppid（父进程id）</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>, getpid());</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;ppid: %d\n&quot;</span>, getppid());</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此程序得到如下结果：<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B4.png"></p><p>在操作系统中，父进程和子进程指的是进程之间的关系。</p><blockquote><p>父进程是生成其他进程的进程，而子进程是由父进程生成的进程。</p></blockquote><p>当一个进程创建一个新的进程的时候，创建者进程就被叫做父进程，而新创建的进程被称为子进程。父进程会通过<code>系统调用fork()</code>来创建子进程。在创建子进程后，父进程和子进程就会拥有相同的代码段、数据段和堆栈等资源，但是它们具备<code>各自独立</code>的执行空间。</p><p>子进程会从父进程那里继承部分的属性，包括进程ID,文件描述符等。子进程可以通过系统调用exec()来加载新的程序代码，从而替换掉原有的代码段，从而开始执行新的程序。子进程还可以通过系统调用exit()来终止自己的执行。</p><p>父进程和子进程的关系是一种层次结构，可以形成进程树。父进程可以创建多个子进程，而子进程也可以再次创建新的子进程，形成<code>多层级的进程树结构</code>。</p><p>接下来就认识一下如何用fork创建进程。</p><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>fork()是一个系统调用，作用是创建一个新的进程。它会<code>复制当前进程，创建一个新的子进程</code>。在调用fork()时，操作系统会为子进程创建一个新的进程控制块（PCB），并将父进程的PCB的副本复制给子进程。</p><p>头文件为：unistd.h<br>函数原型：pid_t fork(void);</p><blockquote><p>fork()函数<code>返回两次</code>，一次在父进程中返回子进程的进程ID（PID），一次在子进程中返回0。这样可以通过<code>返回值的不同</code>来区分父进程和子进程的执行路径。</p></blockquote><p>在fork()函数执行后，父进程和子进程会继续执行fork()调用之后的代码。父进程和子进程会拥有“相同”的代码段、数据段和堆栈等资源，但是它们有各自独立的执行空间。</p><blockquote><p>在Unix-like系统（如Linux）中，当父进程通过某种方式（如fork()系统调用）创建一个子进程时，子进程会继承父进程的地址空间的一个副本。这个副本包括了代码段（即程序的机器指令部分）。如果父进程和子进程都还没有对各自的代码段进行修改（这是非常罕见的，因为代码段通常是只读的），它们实际上可能指向相同的物理内存页（通过虚拟内存机制），但从进程的角度来看，每个进程都有自己的虚拟地址空间中的代码段副本。而对于数据段（包括全局变量和静态变量）和堆栈（用于函数调用和局部变量），情况就不同了。当子进程被创建时，它会得到父进程数据段和堆栈的一个独立副本。这意味着虽然初始值可能相同（因为是复制过来的），但这两个进程对这些内存区域所做的任何修改都是独立的，不会影响到对方。</p></blockquote><p>子进程会继承父进程的很多属性,同时子进程也会有一些独属于自己的属性，例如它的父进程ID会是父进程的进程ID，而子进程的进程ID会是一个新的唯一值。</p><p>如何做到返回两次？</p><blockquote><p>fork()函数可以创建一个新的进程，该新进程是原始进程的一个副本。通过fork()函数，原始进程就会被复制一份，包括代码、数据、堆栈等，并且在两个进程中返回不同的值。<br>具体的讲,fork()函数被调用时，操作系统会创建一个新的进程（称为子进程），并将子进程的副本返回给父进程。<code>父进程会收到子进程的进程ID（PID），而子进程会收到0</code>。这样就实现了fork()函数返回两次的效果。<br>在fork()函数被调用后，父进程和子进程会在<code>fork()函数调用的位置</code>继续执行。它们会完全<code>独立</code>地运行，并且有各自的进程ID（PID）。子进程会继承父进程的文件描述符、用户ID等属性，但它们的执行环境是相互独立的。<br>通过fork()函数的返回值，父进程和子进程可以根据不同的返回值来执行不同的代码逻辑。且它们的执行顺序是不确定的，取决于操作系统如何调度。</p></blockquote><p>总结一下fork：</p><ol><li>fork有两个返回值。</li><li>父子进程<code>代码共享</code>，<code>数据各自开辟空间</code>，私有一份（采用写时拷贝）。</li></ol><p>使用fork时常用if进行分流。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret = fork();</span><br><span class="line"> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;I am child : %d!, ret: %d\n&quot;</span>, getpid(), ret);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;I am father : %d!, ret: %d\n&quot;</span>, getpid(), ret);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B5.png"></p><p>fork()函数的作用是创建一个新的进程，使得父进程和子进程可以并发执行、进行进程间通信、共享和隔离资源，并形成进程树结构，实现进程的管理和控制。具体的使用会在后面介绍。</p><p>在Linux环境下，父进程创建子进程的常用方法是使用fork()函数，但除了fork()函数，还有其他的方式可以创建子进程(了解)。</p><p>vfork()函数：与fork()函数类似，但是vfork()函数创建的子进程会与父进程共享相同的地址空间，子进程在调用exec()函数或者exit()函数之前必须要调用exec()函数或者_exit()函数来替换或退出，否则可能会导致数据不一致的问题。</p><p>clone()函数：clone()函数是Linux特有的系统调用，可以创建一个新的进程，并允许在创建时指定各种选项，例如共享地址空间、共享文件描述符等。</p><p>pthread_create()函数：该函数用于在一个进程内创建一个新的线程，这个线程可以看作是一个轻量级的子进程。线程共享父进程的地址空间和资源，但是有独立的栈空间和线程ID。</p><p>还有一些特殊情况下可以创建子进程，例如通过system()函数调用shell命令，或者通过exec()函数在当前进程内启动一个新的程序。但是这些方式实际上都是<code>通过fork()或者clone()等底层机制</code>来实现的。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>在Linux中，进程有主要存在以下几个状态：</p><ol><li>运行（Running）：进程正在执行或等待执行。</li><li>就绪（Ready）：进程已经准备好执行，但还没有得到CPU的执行时间。</li><li>等待（Waiting）：进程正在等待某个事件的发生，如IO操作的完成、信号的到达等。</li><li>停止（Stopped）：进程被暂停执行，通常是由于接收到一个信号或被调试器所控制。</li><li>僵尸（Zombie）：进程已经执行结束，但其父进程还没有调用wait()或waitpid()来获取其状态信息，所以进程的退出状态还没有被收集。</li></ol><blockquote><p>Linux中的进程状态是动态变化的，进程可以在不同的状态之间切换。</p></blockquote><p>查看进程状态可以使用<code>ps aux</code>指令。</p><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B6.png"><p>而在其中的僵尸状态是很特殊的一个。</p><blockquote><p>在Linux中，僵尸（Zombie）状态是指一个已经退出的进程，但父进程还<code>没有调用wait()或waitpid()</code>来获取其退出状态信息的进程。当一个进程结束时，它的退出状态信息会保存在内核的<code>进程表</code>中，直到其父进程调用wait()或waitpid()来获取这些信息。如果父进程没有及时处理，那么该子进程就会成为僵尸进程。</p></blockquote><p>僵尸进程因为已经结束所以不会占用系统资源，只有一个进程表的槽位和一个进程ID。但是，如果系统中存在大量的僵尸进程，也会占用过多的进程表资源，从而导致系统性能下降。</p><p>僵尸进程的产生通常有以下几种情况：</p><ol><li>父进程没有及时调用wait()或waitpid()来获取子进程的退出状态信息。</li><li>父进程已经终止，但是没有正常处理子进程的退出状态信息。</li><li>父进程忽略了SIGCHLD信号，该信号是子进程终止时向父进程发送的信号。</li></ol><p>简单的说，父进程交给了子进程工作，那么子进程就需要一个途径来向父进程反馈任务的完成情况，可父进程如果一直不读取其状态信息，那子进程就就一直处于Z状态。<br>维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，Z状态如果一直不退出，PCB一直都要维护。<br>那一个父进程创建了很多子进程，但是不进行回收，就会造成内存的浪费，甚至更严重的后果——内存泄漏。</p><p><code>进程切换</code>是操作系统进行多任务处理的基本机制之一。<br>当我们在使用电脑时，不会只使用一个软件，同时会有大量的进程在进行交替执行！这种现象我们称为<code>并发</code>。尽管在宏观下我们发现软件是在同时运行，比如听歌打游戏可以被同时进行，但微观上是由处理器快速的切换进程并交替执行所完成的。</p><p>当有多个进程同时进行,若系统是单CPU,那么它只能把CPU运行时间划分成若干个<code>时间片</code>,再将时间段分配给各个进程执行,在一个时间段的进程代码运行时,其它线程处于挂起状态.这种方式称为并发(Concurrent)。</p><p>当系统有多个CPU时，进程互不抢占CPU资源,可以同时进行,这种方式称为并行(Parallel)。</p><p>下面是一个简化的图示来解释Linux下进程的切换过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+                   +-------------------------+</span><br><span class="line">|        进程A            |                   |        进程B            |</span><br><span class="line">|-------------------------|                   |-------------------------|</span><br><span class="line">|       寄存器状态A        |                   |       寄存器状态B        |</span><br><span class="line">|                         |                   |                         |</span><br><span class="line">|          代码           |                   |          代码           |</span><br><span class="line">|          数据           |                   |          数据           |</span><br><span class="line">|          堆栈           |                   |          堆栈           |</span><br><span class="line">|                         |                   |                         |</span><br><span class="line">|-------------------------|                   |-------------------------|</span><br><span class="line">|        进程控制块A       |                   |       进程控制块B        |</span><br><span class="line">+-------------------------+                   +-------------------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当进程A正在执行时，它的寄存器状态A（包括程序计数器、栈指针等）和相关数据存储在进程A的内存空间中。</p><p>当<code>操作系统调度器</code>决定要切换到进程B时，它会保存进程A的寄存器状态A和其他重要的信息（例如堆栈指针等），并将这些信息存储在进程A的进程控制块中。</p><p>操作系统会将进程B的进程控制块B中存储的寄存器状态B和其他信息加载到对应的寄存器中，来恢复进程B的执行环境。</p><p>进程切换完成后，操作系统会将CPU的控制权转移到进程B，让进程B继续执行。</p><p>在进程切换过程中，操作系统会保存和恢复进程的寄存器状态、堆栈指针等重要信息，以确保进程的执行环境得以保存和恢复。这样，操作系统能够在不同进程之间快速切换，实现多任务处理和资源共享。</p><h2 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getpid());</span><br><span class="line">       <span class="type">pid_t</span> pid = fork();<span class="comment">//此时就创建了子进程</span></span><br><span class="line">      <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">      &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;I am child——%d\n&quot;</span>,getpid());</span><br><span class="line">          sleep(<span class="number">5</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);                                                                                                                                                                        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="comment">//父进程</span></span><br><span class="line">      &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;I am father——%d\n&quot;</span>,getpid());</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getpid());</span><br><span class="line">          sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">14110</span><br><span class="line">I am father——14110</span><br><span class="line">14110</span><br><span class="line">I am child——14111</span><br><span class="line">14110</span><br><span class="line">14110</span><br><span class="line">14110</span><br><span class="line">14110</span><br></pre></td></tr></table></figure><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B8.png"><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。如果是前台进程的话，我们在前台将无法输入命令，但是如果变成孤儿进程的话，就会变成<code>后台的进程</code>，依然可以运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getpid());</span><br><span class="line">       <span class="type">pid_t</span> pid = fork();</span><br><span class="line">       <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          sleep(<span class="number">5</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);                                                                                                                                                                        </span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getppid());</span><br><span class="line">          sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B9.png"></p><p>此时孤儿进程将被init进程(进程号为1)所收养。只有通过kill才能杀死它。</p><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><blockquote><p>题1.下面有关孤儿进程和僵尸进程的描述，说法错误的是？<br>A.孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。<br>B.僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。<br>C.孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。<br>D.孤儿进程和僵尸进程都可能使系统不能产生新的进程，都应该避免。</p></blockquote><p>如果进程不调用wait或者waitpid，那么保留信息就不会被释放，其进程号就会一直被占用，如果大量的产生僵尸进程，会产生内存浪费的现象，应当避免。<br>而孤儿进程是没有父进程的进程，孤儿进程的管理这个重任就落到了init进程身上 ，init进程专门负责处理孤儿进程的善后。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，当一个孤儿进程结束其生命周期时，init进程就会去处理它， 因此孤儿进程并不会有什么危害。</p><blockquote><p>题2.关于僵尸进程，以下描述正确的有？<br>A.僵尸进程必须使用waitpid&#x2F;wait接口进行等待<br>B.僵尸进程最终会自动退出<br>C.僵尸进程可以被kill命令杀死<br>D.僵尸进程是因为父进程先于子进程退出而产生的</p></blockquote><p>A选项正确，僵尸进程会造成资源泄露，必须使用wait&#x2F;waitpid接口进行等待处理。<br>B选项错误，僵尸进程不会完全释放资源退出。<br>C选项错误，僵尸进程是已经退出运行的进程，无法被杀死。<br>D选项错误，僵尸进程是子进程先于父进程退出。</p><blockquote><p>题3.以下关于孤儿进程的描述正确的有<br>A.父进程先于子进程退出，则子进程成为孤儿进程<br>B.孤儿进程会产生资源泄漏<br>C.孤儿进程运行在系统后台<br>D.孤儿进程没有父进程</p></blockquote><p>A选项正确：父进程先于子进程退出，子进程就会成为孤儿进程。<br>B选项错误：孤儿进程退出不会成为僵尸进程，因此也不会资源泄露。<br>C选项正确：孤儿进程是运行在后台的。<br>D选项错误：孤儿进程也有父进程，父进程是1号进程。</p><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>既然进程可以切换，那么到底谁在前面谁又在后面呢？操作系统的调度器是以什么标准来判断：何时一个进程该被执行，何时一个进程该被阻塞呢？</p><blockquote><p>cpu<code>资源分配</code>的先后顺序，就是指进程的优先权（priority）。优先权高的进程有优先执行权利。</p></blockquote><p>可以通过<code>ps -l</code>指令获取优先级。<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B7.png"></p><ol><li>UID : 执行者</li><li>PID : 这个进程的代号</li><li>PPID ：父进程的代号</li><li>PRI ：代表这个进程可被执行的优先级，其值越<code>小</code>越早被执行</li><li>NI ：代表这个进程的nice值</li></ol><p>PRI是进程的优先级，就是程序被CPU执行的先后顺序，此值越小，进程的优先级别越高。<br>NI，也就是nice值，其表示进程可被执行的优先级的<code>修正数值</code>，PRI值越小越快被执行，那么加入nice值后，PRI则变为<code>PRI(new)=PRI(old)+nice</code>。当nice值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行。调整进程优先级，在Linux下，就是<code>调整进程nice值</code>。</p><p>调整nice值可以通过nice命令来实现。nice值是一个整数，其取值范围是<code>-20（最高优先级）到19（最低优先级）</code>。默认情况下，新进程的nice值为0。</p><blockquote><p>设置进程的nice值</p></blockquote><p>当启动一个新进程时，可以使用nice命令来设置它的nice值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n 10 ./my_program</span><br></pre></td></tr></table></figure><p>这条命令将启动名为my_program的程序，并将其nice值设置为10。</p><blockquote><p>查看当前shell的nice值</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span></span><br></pre></td></tr></table></figure><p>返回当前shell的nice值，通常是0（除非之前已经使用renice命令或类似工具更改过）。</p><blockquote><p>修改已运行进程的nice值</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n 5 -p 1234</span><br></pre></td></tr></table></figure><p>这条命令将把进程ID为1234的进程的nice值修改为5。只有具有足够权限的用户（如root用户或进程的所有者）才能降低进程的nice值（即增加优先级）。普通用户只能提高进程的nice值（降低优先级）。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile——高效的自动编译工具</title>
      <link href="/2024/12/13/linux-makefile/"/>
      <url>/2024/12/13/linux-makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>在Linux系统中，<code>gcc/g++</code>是一款非常常用的编译器。它可以将C&#x2F;C++的源代码<code>编译、汇编、链接</code>，生成可执行文件或库文件。</p><p>在编译过程中，一个代码文件需要经过预处理、编译、汇编、连接等步骤才能转化为可执行的程序。</p><ol><li><p>预处理：主要进行<code>宏替换、文件包含、条件编译、去注释</code>等操作。预处理指令以#号开头。</p></li><li><p>编译：在这个阶段中，gcc&#x2F;g++ 首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，然后将代码<code>翻译成汇编语言</code>。</p></li><li><p>汇编：汇编阶段是将编译阶段生成的“.s”文件转成<code>目标文件</code>。</p></li><li><p>链接：在成功编译之后，就进入了链接阶段，将目标文件链接成可执行文件或库文件。<br>可能有人很早就有疑惑：在我们的C程序中，并没有定义“printf”的函数实现,且在预编译中包含的“stdio.h”中也<code>只有该函数的声明,而没有定义函数的实现</code>,那么到底printf是在哪里实现的？<br>系统把这些函数实现都被写到名为 libc.so.6 的库文件中,在没有特别指定时,gcc会到系统默认的搜索路径“&#x2F;usr&#x2F;lib”下进行查找,也就是链接到 libc.so.6 库函数中去,这样就能实现函数“printf”了,而这也就是链接的作用。</p></li></ol><p>函数库一般分为<code>静态库和动态库</code>两种。</p><ol><li>静态库是指编译链接时,把库文件的代码<code>全部加入到可执行文件</code>中,因此生成的文件比较大,但在运行时也<br>就不再需要库文件了。其后缀名一般为“.a”</li><li>动态库与之相反,在编译链接时并没有把库文件的代码加入到可执行文件中,而是在程序执行时<code>由运行时 链接文件加载库</code>,这样可以节省系统的开销。动态库一般后缀名为“.so”,如前面所述的 libc.so.6 就是动态<br>库。gcc 在编译时默认使用动态库。完成了链接之后,gcc 就可以生成可执行文件。</li></ol><p>二者可以看作是网吧的电脑（动）和自己家的电脑（静），想玩电脑时，可以选择玩家里的或者去网吧上网，一旦网吧停业，就会有大批家里没有电脑的人无法上网，但自己买一台电脑价格也是高昂的。<br>总的来说，动态库虽然有效的节约了资源（不用自己买电脑），但一旦缺失，几乎各个程序都会无法运行（都上不了网）。而静态库虽然可以让程序独立的运行，但体积大比较消耗资源（单独买电脑价格高昂）是他的弊病。</p><p>这么说了一大串可能对初次接触的同学有些困难，可以结合图片来看一下。<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/makefile1.png"><br>可以看到从我们写出来的源文件到变成一个可执行的exe文件，大概经过了什么步骤。</p><p>在linux中，我们使用这样的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc/g++的使用格式为：gcc [选项] 要编译的文件 [选项] [目标文件]</span><br></pre></td></tr></table></figure><p>预处理：使用选项“-E”，该选项的作用是让 gcc 在预处理结束后停止编译过程。例如，要将hello.c文件预处理成hello.i文件，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure><p>编译：使用选项“-S”，该选项只进行编译而不进行汇编，生成汇编代码。例如，要将hello.i文件编译成hello.s文件，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –S hello.i –o hello.s</span><br></pre></td></tr></table></figure><p>汇编：使用选项“-c”，将汇编代码转化为“.o”的二进制目标代码。例如，要将hello.s文件汇编成hello.o文件，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –c hello.s –o hello.o</span><br></pre></td></tr></table></figure><p>连接：将目标文件链接成可执行文件或库文件。例如，要将hello.o文件链接成hello可执行文件，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o –o hello</span><br></pre></td></tr></table></figure><h1 id="什么是make-makefile？"><a href="#什么是make-makefile？" class="headerlink" title="什么是make&#x2F;makefile？"></a>什么是make&#x2F;makefile？</h1><p>Make是一个在软件开发中所使用的<code>构建工具</code>，用于自动化建构软件。 它通过一个名为 Makefile 的<code>文本文件</code>来描述源代码文件之间的依赖关系和构建规则。 Make 会根据这些规则和依赖关系，判断哪些文件需要重新编译，并执行相应的编译命令，以确保最终生成可执行文件或其他目标文件（这些目标被称为“target”）。 大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。(以上摘自维基百科)</p><p>一个特别大的项目，一般来说会有很多的源文件，被分门别类的放在不同的目录中，有时候也会在一个目录里存放了多个程序的源代码。这时，如何对这些代码的编译就成了个问题。Makefile就是为这个问题而生的，它定义了一套规则，<code>决定了哪些文件要先编译，哪些文件后编译，哪些文件要重新编译</code>。</p><blockquote><p>简单地说，Make通过读取Makefile的文件中所定义的规则来执行一个项目的构建过程。</p></blockquote><p>目标文件（Target）：Makefile中定义的<code>要生成的</code>文件或<code>执行的</code>操作。目标可以是可执行文件、对象文件（.o）、库文件或任何其他类型的文件。<br>依赖文件（Dependencies）：生成目标文件所需的其他文件。如果依赖文件<code>发生了变化</code>，那么目标文件就需要重新生成。<br>要执行的命令（Commands）：用于生成目标文件的命令，这些命令会在目标文件或其依赖文件<code>发生变化</code>时被执行。<br>其基本格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: dependencies </span><br><span class="line">    <span class="built_in">command</span>...[other commands]</span><br></pre></td></tr></table></figure><p>command为生成目标文件需要执行的命令，这些命令以<code>Tab键</code>开始，而不是空格(这点需要注意！)。</p><p>Makefile的基本规则如上，接下来用几个实例深入学习。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="简单文件编译"><a href="#简单文件编译" class="headerlink" title="简单文件编译"></a>简单文件编译</h2><p>新建test.c与makefile文件。使用vim编辑test.c与makefile：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//makefile</span></span><br><span class="line">test:test.c</span><br><span class="line">    gcc test.c -o test</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再输入make命令行，此时就会先检查test.c文件是否存在，若存在则执行gcc test.c -o test命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-3ad5 ~]# make  </span><br><span class="line">gcc test.c -o test</span><br><span class="line">[root@hcss-ecs-3ad5 ~]# ls -a</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  .cshrc  .history  makefile  .ssh  .tcshrc  test  test.c  .viminfo</span><br><span class="line">[root@hcss-ecs-3ad5 ~]# ./test</span><br><span class="line">hello world[root@hcss-ecs-3ad5 ~]# </span><br></pre></td></tr></table></figure><p>如果再次执行make，文件不会有任何变化。而当touch操作test.c后，再执行make就会重新编译。<br>也可以同时编译多个文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:test1.c test2.c //用空格隔开即可</span><br><span class="line">    gcc test1.c test2.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这样就会出现一个问题，如果test1.c被修改，那么test2.c也会跟着重新编译。<br>所以更规范的makefile写法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:test1.o test2.o</span><br><span class="line">    gcc test1.o test2.o -o <span class="built_in">test</span></span><br><span class="line">test1.o: test1.c</span><br><span class="line">    gcc -c test1.c</span><br><span class="line">test2.o: test2.c</span><br><span class="line">    gcc -c test2.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就先把两个test文件先编译成.o文件，最后再一起链接。</p><blockquote><p>稍微提一提工作原理：<br>当运行make命令（不带任何目标）时：<br>Make会查找Makefile中的<code>第一个</code>目标，如果没有指定目标，它会尝试构建第一个定义的目标（在这个例子中是test）。如果指定如make test1.o ，那么就只会构建test1.o。<br>构建test目标：<br>Make看到test目标<code>依赖于</code>test1.o和test2.o。<br>它会检查这两个对象文件是否<code>已经存在且是最新</code>的（即它们的修改时间是否晚于它们的依赖源文件或任何其他相关的文件）。<br>如果test1.o或test2.o中的任何一个不存在或不是最新的，make会构建它们。<br>构建test1.o目标：<br>如果test1.o需要被构建（因为它不存在或不是最新的），make会查找test1.o的规则。<br>它看到test1.o依赖于test1.c。<br>然后，它会执行用于生成test1.o的命令：gcc -c test1.c。<br>构建test2.o目标：<br>与test1类似，如果test2.o需要被构建，make会查找test2.o的规则并执行相应的命令：gcc -c test2.c。<br>链接生成test：<br>一旦test1.o和test2.o都是最新的或已经被成功构建，make会执行用于生成test的命令：gcc test1.o test2.o -o test。<br>这将链接test1.o和test2.o生成最终的可执行文件test。</p></blockquote><p>当执行一些清理临时文件或者打包等不需要生成文件的操作，就会用到<code>伪目标</code>来定义规则。伪目标就是不生成文件的操作。<br>例如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">`<span class="built_in">rm</span> -f *.o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>当执行make clean时，就会删除所有.o文件与test文件。</p><blockquote><p>要是有一个文件恰好叫clean呢？那执行make clean不就有两层意思：一层是构建clean文件，一层是执行伪目标clean。</p></blockquote><p>为了避免此情况，会使用如下语法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY： clean</span><br></pre></td></tr></table></figure><p>此时再执行make clean就可以达到删除文件的预期效果。<br>再加入all：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean all</span><br><span class="line">all: hello chengzi</span><br><span class="line"></span><br><span class="line">hello:test.c</span><br><span class="line">        gcc test.c -o hello</span><br><span class="line">chengzi:test.c</span><br><span class="line">        gcc test.c -o chengzi</span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> -f *.o hello</span><br></pre></td></tr></table></figure><p>命令行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-3ad5 ~]# make all  //构建hello和chengzi两个文件</span><br><span class="line">gcc test.c -o hello</span><br><span class="line">gcc test.c -o chengzi</span><br><span class="line">[root@hcss-ecs-3ad5 ~]# ls -a  //查看当前目录下文件</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  chengzi  .cshrc  hello  .history  makefile  .ssh  .tcshrc  test  test.c  .viminfo</span><br><span class="line">[root@hcss-ecs-3ad5 ~]# make clean //清除所有.o文件与hello文件</span><br><span class="line">rm -f *.o hello</span><br><span class="line">[root@hcss-ecs-3ad5 ~]# ls -a //再次查看目录下文件</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  chengzi  .cshrc  .history  makefile  .ssh  .tcshrc  test  test.c  .viminfo</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用变量对hello，chengzi等文件进行替换，有利于整体的修改和维护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译器和编译选项</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标文件</span></span><br><span class="line">TARGETS = hello chengzi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义源文件</span></span><br><span class="line">SRC = test.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line">all: $(TARGETS)  //使用变量的规则就是$加上(变量名)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则：如何生成每个目标</span></span><br><span class="line">$(TARGETS): $(SRC)</span><br><span class="line">$(CC) $(CFLAGS) $(SRC) -o <span class="variable">$@</span>  </span><br><span class="line"><span class="comment"># 清理规则</span></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f *.o $(TARGETS)</span><br></pre></td></tr></table></figure><blockquote><p>$@ 是一个<code>自动变量</code>，它代表当前规则的目标文件名。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello: test.c</span><br><span class="line">    gcc test.c -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>$@ 会被替换成 hello，所以实际的命令会是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o hello</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vector的简单模拟实现</title>
      <link href="/2024/12/13/cpp-vector%20implement/"/>
      <url>/2024/12/13/cpp-vector%20implement/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是vector？"><a href="#什么是vector？" class="headerlink" title="什么是vector？"></a>什么是vector？</h1><p>在C++中，vector是一个非常有用的<code>容器类</code>，用于<code>存储一组元素</code>，类似于数组。它提供了动态大小的数组功能，使得在运行时可以轻松地添加、删除和访问元素。vector是C++标准模板库（STL）的一部分，因此只需包含<code>头文件&lt;vector&gt;</code>即可使用。</p><p>vector主要有以下几种作用：</p><ol><li><p>动态大小: vector可以根据需要<code>动态增长或缩小其大小</code>。这意味着<code>不需要在创建时指定其大小</code>，而是可以在运行时根据需要添加或删除元素。</p></li><li><p>随机访问: 类似于数组可以使用<code>索引</code>来直接访问vector中的元素。</p></li><li><p>自动内存管理: vector会自动进行<code>内存管理</code>，我们也就不用担心内存分配和释放的细节。</p></li><li><p>元素操作: vector提供了许多用于操作元素的函数，例如在尾部添加元素（push_back()）、删除尾部元素（pop_back()）、插入元素（insert()）、删除指定位置元素（erase()）等等。</p></li></ol><p>一个使用vector的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector; <span class="comment">// 创建一个空的整数向量</span></span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">// 在尾部添加元素</span></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector size: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 输出元素个数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector capacity: &quot;</span> &lt;&lt; myVector.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出容量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 随机访问元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector size: <span class="number">3</span></span><br><span class="line">Vector capacity: <span class="number">4</span></span><br><span class="line">Elements: <span class="number">10</span> <span class="number">20</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><h1 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h1><h2 id="构造函数与迭代器"><a href="#构造函数与迭代器" class="headerlink" title="构造函数与迭代器"></a>构造函数与迭代器</h2><p>在C++中，vector是一个模板类（template class），它通过<code>模板参数</code>来指定所存储元素的类型。这意味着vector可以存放各种类型的值。<br>例如，如果想要存储整数类型的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; intVector; <span class="comment">// 存放整数类型的元素</span></span><br></pre></td></tr></table></figure><p>如果想存储浮点数类型的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span>&gt; floatVector; <span class="comment">// 存放浮点数类型的元素</span></span><br></pre></td></tr></table></figure><p>简而言之，vector是通过模板参数生成不同类型的容器。<br>在上面的示例中，vector的行为是相同的，只是存储的元素类型不同。模板类让我们可以轻松创建存储不同类型元素的向量容器。</p><p>vector容器类通常使用两个指针来表示元素范围，<code>start和finish</code>，即有效元素的<code>起始位置和结束位置</code>。还使用一个指针来表示内存中可用于<code>存储元素的结束位置</code>，这个指针通常称为<code>endofstorage</code>，指向存储在内存中的元素数组的指针，指向当前 vector 对象的<code>内存缓冲区的末尾位置</code>。</p><ol><li><p>start: 指向vector中的<code>第一个有效元素</code>的位置。通常，它指向存储在内存中的元素数组的首地址。</p></li><li><p>finish: 指向<code>vector中最后一个有效元素的下一个位置</code>。换句话说，它指向存储在内存中的元素数组中的下一个可用位置。</p></li><li><p>endofstorage: 指向可用存储空间的最后一个位置。</p></li></ol><blockquote><p>这三个指针共同定义了vector中存储元素的范围。有效的元素是从start指针开始，一直到finish指针之前的位置（即<code>左闭右开</code>区间）。因此，vector中的实际存储元素数量可以通过 <code>finish - start </code>来计算。<br>当添加或删除元素时，指针会<code>随之更新</code>，以反映vector中元素的当前范围。如果 vector 的元素数量超过当前内存缓冲区的容量，vector 将会重新分配<code>更大</code>的内存空间，并更新 endofstorage 指针为新内存缓冲区的末尾位置。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;   </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T* const_iterator;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">iterator _start = <span class="literal">nullptr</span>;</span><br><span class="line">iterator _finish = <span class="literal">nullptr</span>;</span><br><span class="line">iterator _endofstorage = <span class="literal">nullptr</span>;       </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//在函数后加上 const 关键字，表示这个成员函数是一个常量成员函数（const member function）。这样的设计告诉编译器这个函数不会修改类对象的成员变量。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//有参和无参构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">resize</span>(n, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; v)  </span><br><span class="line">&#123;</span><br><span class="line">_start = <span class="keyword">new</span> T[v.<span class="built_in">capacity</span>()]; <span class="comment">//C++ STL 的标准容器已经对内存管理和容量调整进行了优化，可以正确地处理不同类型的元素，包括自定义类型。所以在这里哪怕T是自定义类型也无所谓。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">_start[i] = v._start[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_finish = _start + v.<span class="built_in">size</span>();</span><br><span class="line">_endofstorage = _start + v.<span class="built_in">capacity</span>();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">_start = _finish = _endofstorage = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为篇幅较长，所以拎出来单独解释一下这个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br></pre></td></tr></table></figure><p>第一个参数是 size_t n，表示要创建的 vector 的大小，即其中包含的元素数量。第二个参数是 const T&amp; val，表示要用来初始化 vector 中元素的值，它可以作为一个常量引用来<code>接收内置类型的调用</code>，同时也可以接收自己写的类，比如上一篇文章重写的string类。</p><p>当我们使用类似 vector<int> myVector(10, 1); 这样的调用时，它是有效的，因为这其实是一个<code>隐式的类型转换</code>。<br>1 是一个整数常量，而不是 const int&amp; 类型的常量引用。然而，C++ 允许进行隐式类型转换，可以将 1 转换为 const int&amp; 类型的常量引用，以匹配构造函数的参数类型。当我们传递 1 作为第二个参数时，虽然 1 是一个<code>临时的常量值</code>，但它会被绑定到构造函数参数 const T&amp; val 上的常量引用。这样做可以延长 1 的生命周期，确保它在 vector 的构造函数中被正确使用，即在 vector 对象创建过程中可以通过常量引用访问这个值。</p><h2 id="一些其他常用的函数"><a href="#一些其他常用的函数" class="headerlink" title="一些其他常用的函数"></a>一些其他常用的函数</h2><p>其实和string类的模拟实现大差不差，就不单独一个一个的写了（懒）。<br>单独提一下insert和erase函数。<br>在 C++ STL 中，std::vector 的 insert 函数是用于在指定位置插入元素的成员函数。它<code>返回一个迭代器</code>（iterator），指向插入的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的参数如下：<br>pos：一个迭代器，表示插入元素的位置。<br>value：要插入的元素的值。<br>insert 函数的作用是将新元素插入到指定位置，它会改变 vector 的大小和容量，可能导致内部的数据重新分配。为了方便使用者处理插入后的元素，函数返回一个指向插入元素的迭代器，这样用户就可以继续对新元素进行操作，或者在需要时获取其位置或修改其值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在位置 2 插入新元素 100</span></span><br><span class="line">    <span class="keyword">auto</span> insertPos = myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">100</span>);  <span class="comment">//因为vector本质上还是顺序存储的，所以+2可以顺利读取到第三个元素，而重写list也这样简单带过就不行了，其底层逻辑是链表，到时候详细讲。</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inserted Element: &quot;</span> &lt;&lt; *insertPos &lt;&lt; std::endl; <span class="comment">// 输出：100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert和erase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_finish == _endofstorage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = pos - _start;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="built_in">capacity</span>() == <span class="number">0</span> ? <span class="number">4</span> : <span class="built_in">capacity</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决pos迭代器失效问题</span></span><br><span class="line">pos = _start + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterator end = _finish - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos)</span><br><span class="line">&#123;</span><br><span class="line">*(end + <span class="number">1</span>) = *end;</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pos = x;</span><br><span class="line">++_finish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &gt;= _start &amp;&amp; pos &lt; _finish);</span><br><span class="line"></span><br><span class="line">iterator it = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (it != _finish)</span><br><span class="line">&#123;</span><br><span class="line">*(it - <span class="number">1</span>) = *it;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--_finish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释了我提到了<code>迭代器失效</code>。为什么迭代器会失效？<br>这里的迭代器失效指的是在向 vector 中<code>插入新元素</code>后，之前的迭代器可能会变得无效。<br>在 vector 中插入元素可能会导致<code>内部数据重新分配</code>，这涉及到扩容操作。如果扩容后，原先的内存块不够存放所有元素，vector 就会在新的内存地址上<code>重新分配内存</code>，并将原先的元素复制到新的位置。这样一来，原先指向vector 中元素的迭代器就会失效，<code>因为它们指向了之前的内存地址，而这些地址现在已经不再有效</code>。</p><p>为了解决这个问题，首先会检查插入新元素后是否需要扩容。如果需要扩容，就会重新分配更大的内存块，并将原先的元素复制到新的位置。然后，为了使原先的迭代器仍然有效，会将 pos 这个迭代器重新设置为插入元素后的位置，即 _start + len。这样一来，之前的迭代器 pos 就仍然指向正确的位置，不会失效。</p><p>其他的一些函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(vector&lt;T&gt; v)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_start, v._start);</span><br><span class="line">std::<span class="built_in">swap</span>(_finish, v._finish);</span><br><span class="line">std::<span class="built_in">swap</span>(_endofstorage, v._endofstorage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="built_in">capacity</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="built_in">size</span>();</span><br><span class="line">T* tmp = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="keyword">if</span> (_start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp[i] = _start[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_start = tmp;</span><br><span class="line">_finish = _start + sz;</span><br><span class="line">_endofstorage = _start + n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; val = T())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">_finish = _start + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_finish != _start + n)</span><br><span class="line">&#123;</span><br><span class="line">*_finish = val;</span><br><span class="line">++_finish;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _endofstorage - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; <span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _start[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; <span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _start[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些碎碎念</title>
      <link href="/2024/11/06/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2024/11/06/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于c++的inline关键字,以下说法正确的是( ) </p></blockquote><p>A.使用inline关键字的函数会被编译器在调用处展开<br>B.头文件中可以包含inline函数的声明<br>C.可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数<br>D.递归函数也都可以成为inline函数</p><p>A.inline只是一种建议，需要看此函数是否能够成为内联函数，具体看编译器。</p><p>B. inline函数<code>不支持声明和定义分离</code>，编译器一旦将一个函数作为内联函数处理，就会在调用位置展开，即该函数是<code>没有地址</code>的，也不能在其他源文件中调用，故一般都是直接在源文件中定义内联函数的。</p><p>C.inline函数会在调用的地方展开，所以符号表中不会有inline函数的符号名，不存在链接冲突。</p><p>D.比较长的函数，递归函数就算定义为inline，也会被编译器忽略。</p><p>故选C。</p><blockquote><p>下面描述错误的是( )</p></blockquote><p>A.this指针是非静态成员函数的隐含形参.<br>B.每个非静态的成员函数都有一个this指针.<br>C.this指针是存在对象里面的.<br>D.this指针可以为空</p><p>A.静态成员函数没有this指针，只有非静态成员函数才有，且为隐藏指针。</p><p>B.非静态成员函数的第一个参数就是隐藏的this指针。</p><p>C.this指针在非静态的成员函数里面，对象的内存布局中并没有一个专门的字段用来存储this指针。this指针在成员函数被调用时，指向调用该成员函数的对象。</p><p>D.单纯的对this赋空是不可以的，但可以强转直接赋空(不建议)。</p><p>故选C。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
            <tag> 易错点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>木星卫星上可能存在生命</title>
      <link href="/2024/11/06/Life%20may%20exist%20on%20Jupiter/"/>
      <url>/2024/11/06/Life%20may%20exist%20on%20Jupiter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>经济学人-科技</p></blockquote><h1 id="木星卫星上可能存在生命-上"><a href="#木星卫星上可能存在生命-上" class="headerlink" title="木星卫星上可能存在生命(上)"></a>木星卫星上可能存在生命(上)</h1><p><em><strong>506词</strong></em><br>Besides Earth itself, Mars is the most-studied planet in the <code>solar</code>(adj.太阳的;日光的;利用太阳光的;与太阳相关的n.日光浴室)system.<br>除了地球，火星是太阳系中研究最多的行星。<br>One reason for the abundance (n. 大量,充足) of probes and landers, of course, is that Mars is relatively (adv.<br>相对地,比较而言;相当 相对来说;相比较而言)close.<br>探测器和着陆器数量众多的原因之一当然是火星距离地球相对较近<br>Another is that Mars appears to have once had plenty of liquid(adj.液体的;清澈的;明亮的;易变的n.液体，流体;[语]流音) water on its surface(n.表面;外观;表层 adj.表面的，肤浅的).另一个原因是火星表面似乎曾经有大量液态水。<br>And where there is water, astrobiologists whisper(n.私语;谣传;飒飒的声音 v.耳语;密谈;飒飒地响) about thepossibility(n.可能;可能性;可能的事情;潜在的价值)oflife.<br>而哪里有水，天体生物学家就会悄悄谈论生命存在的可能性。<br>But Mars and Earth are not the only places in the solar system that either have, or have had, water但火星和地球并不是太阳系中唯一有水或曾经有水的地方。<br>On October 14th a NASA probe (n.探针;调查 vi.调查;探测) called Europa Clipper blasted off from Florida10月14日，美国宇航局的“欧罗巴快船”号探测器从佛罗里达州发射升空。<br>As its name suggests, the mission’s target is Europa, one of the biggest of jupiter’s 95 known moonsEuropa is a snowball slightly smaller than Earth’s moon.<br>顾名思义，该任务的目标是欧罗巴，它是木星95颗已知卫星中最大的卫星之一。欧罗巴是一个比月球略小的雪球。<br>It has an atmosphere (n.大气;空气;气氛;气压)that is thin(adj.薄的;瘦的;稀薄的;微弱的v.使淡;使瘦;使稀疏) to the point of non-existence,a crust(n.面包皮;外壳;坚硬外皮 .结硬皮;结成外壳) of water ice and asurface temperature (n.温度, 气温 高烧,发烧,发热) of around -180°C.<br>它的大气层稀薄到几乎不存在，地壳由水冰组成，表面温度约为-180°C<br>But scientists (n.科学家) think a vast(adj.巨大的;广阔的;大量的;巨额的 n.浩瀚;广阔无垠的空间)ocean existsbeneath (prep.在…之下 adv. 在下方) the ice, kept liquid by friction (n.摩擦，摩擦力)produced as Europa iskneaded by Jupiter’s powerful gravity(n.重力，地心引力;庄严;严重性).<br>但科学家认为，冰层之下存在着一片浩瀚的海洋，欧罗巴在木星强大的引力作用下产生摩擦，使之保持液态。<br>Over the past few decades scientists have become steadily more excited (adi. 激动的;兴奋的;活跃的 v. 激动;唤起(excite的过去分词))about the life-bearing potential(adj,潜在的,有可能的n.潜力;电位;电势;可能性) ofsuch “icy moons”.<br>在过去的几十年里，科学家们对这种“冰卫星”孕育生命的可能性越来越感兴趣<br>Besides Europa, these include Ganymede and Callisto, two other Jovian moons; Enceladus, which orbits (r轨道;眼眶;势力范围;生活常规 v.盘旋;绕轨道运行)Saturn; and Triton,the biggest satellite(n.卫星人造卫星卫星国,附庸国,卫星都市) of Neptune.<br>除了欧罗巴，这些卫星还包括:另外两颗木星卫星木卫三和木卫四;绕土星运行的土卫二;海王星最大的卫星海卫一。<br>Europa’s icy crust is thought to be tens of kilometres (n.千米,公里)thick (adj. 厚的;浓密的;粗的;愚笨的).Europa Clipperwill, therefore, not be able to tell whether there actually are any aliens swimming around inthe depths(n.深度;深奥).<br>欧罗巴的冰壳被认为有数十公里厚。因此，欧罗巴快船将无法判断是否真的有外星人在深处游动。<br>Instead, its job is to assess (vt. 评定;估价;对..征税) whether the moon is the sort of place where life mightplausibly arise(v.发生;产生;出现;起身，起来;起床).<br>相反，它的工作是评估这颗卫星是否是生命可能出现的地方<br>One of the probe’s tasks will be to characterise the size and saltiness of the ocean.探测器的任务之一是描述海洋的大小和盐度，<br>NASA’s present best guess is that it varies from 60km to 150km deep.<br>美国宇航局目前最好的猜测是，海洋深度从60公里到150公里不等<br>lf that is right, then, despite its small size, Europa would have about twice as much liquid water as Earthdoes.<br>如果这是正确的，那么尽管欧罗巴体积很小，但其液态水量却是地球的两倍<br>But although water is thought to be extremely useful (adj. 有用的，有益的;有帮助的)(and possibly even vita(adj.生死攸关的;至关重要的;有活力的))to the development of life,it is not enough on its own.但是，尽管人们认为水对生命的发展极其有用(甚至可能至关重要)，但仅靠水是不够的。<br>To qualify (vt.使具有资格;证明..合格;限制 v.取得资格，有资格) as habitable(adj.适于居住的),a world needsenough other elements to allow complex(adj.复杂的;合成的 n.复合体;综合设施)chemistry(n.化学).要成为宜居星球，一个星球需要足够多的其他元素才能进行复杂的化学反应。<br>Besides the hydrogen (n.氢) and oxygen (n.氧气，氧) in water, a common shortlist (vt.把.….列入决选名单) addscarbon (n.碳;碳棒;复写纸 adj.碳的;碳处理的),nitrogen (n.[化]氮),phosphorus (n.磷) and sulphur(n.[化]硫磺;硫磺色 vt.用硫磺处理;使硫化).<br>除了水中的氢和氧之外，常见的元素还包括碳、氮、磷和硫。<br>All of these have already been found on a different icy moon-Enceladus.所有这些都已在另一颗冰卫星土卫二上发现，<br>On Enceladus, plumes (vt. 用羽毛装饰 n. 羽毛) of ocean water jet out into space through cracks in the crust.在土卫二上，海水羽流通过地壳裂缝喷入太空，<br>In 2008 Cassini, another American spacecraft (n. 字宙飞船), flew straight through one of those plumes,discovering six of the elements on the astrobiological list.2008年，另一艘美国航天器卡西尼号直接飞过其中一个羽流，发现了天体生物学名单上的六种元素<br>Whether such plumes exist on Europa is an open question, says Robert Pappalardo, Europa Clipper’s chiefscientist.<br>欧罗巴快船首席科学家罗伯特·帕帕拉多(Robert Pappalardo)表示，欧罗巴上是否存在这样的羽流仍是一个悬而未决的问题。<br>Europa’s ice shell (n.壳，贝壳;外形;炮弹 vi.剥落;[计]设定命令行解释器的位置) is much thicker than Enceladus’she says, which makes it less likely that surface cracks or fissures would reach all the way to the ocean.他说，欧罗巴的冰壳比土卫二的厚得多，因此表面裂缝不太可能一直延伸到海洋。<br>Some tantalising-but uncertain-images from telescopes (n.望远镜v. 缩短;压缩;套叠) nevertheless (adv. 仍然然而,不过 coni. 尽管如此,然而) show things that look plume-like.<br>一些令人着迷但不确定的望远镜图像显示了类似羽状的东西。<br>But follow-up observations (n.观察;观察力;注意;评论) with the space-based James Webb Space Telescope have so far failed to spot any.但太空中的詹姆斯·韦布空间望远镜的后续观测迄今为止未能发现任何羽状物.</p><h1 id="木星卫星上可能存在生命-下"><a href="#木星卫星上可能存在生命-下" class="headerlink" title="木星卫星上可能存在生命(下)"></a>木星卫星上可能存在生命(下)</h1><p><em><strong>447词</strong></em><br>If plumes (n.李子;洋李;紫红色;梅子 adj.人所希望的;有利的;上等的) do not exist,then Europa Clipperwill haveto content itself with examining (vt.调查;考试;检査;[计算机]检测 vi.检查;调查)the moon’s surface(n.表面;外观;表层 adj.表面的，肤浅的).<br>如果不存在羽状物，那么欧罗巴快船就只能满足于检测卫星表面，<br>That surface is notably(adv.显著地;尤其)smooth(adj.光滑的;顺利的;平稳的 .使光滑;缓和;消除(障碍等);使优雅) and relatively(adv.相对地,比较而言;相当 相对来说;相比较而言)free from impact craters,which suggestsit is regularly renewed by processes a bit like plate tectonics on Earth.欧罗巴表面非常光滑，相对没有撞击坑，这表明它定期通过类似地球板块构造的过程进行更新。<br>That, in turn, suggests that chemicals that form on Europa’s surface might have a way down to the ocean,and vice (n,堕落，恶习;(尤指与性或毒品有关的)罪行，道德败坏行为;老虎钳 pref,副职的;副的)versa.这反过来又表明，欧罗巴表面形成的化学物质可能有通往海洋的途径，反之亦然。<br>Studying Europa’s surface mav, therefore, qive valuable (adi.贵重的;有价值的;可估价的n. 贵重物品) clues asto what lies beneath(prep.在…之下 adv. 在下方).因此，研究欧罗巴表面可能会为了解其下方情况提供有价值的线索。<br>The final ingredient (n.混合物的组成部分;配料) for a habitable (adj. 适于居住的) world is a source of energy forife to exploit(vt.开发，开拓;剥削;开采 n.勋绩;功绩).<br>宜居世界的最后一个要素是可供生命利用的能量来源。<br>Whatever that might be on Europa-far from the Sun, and beneath kilometres (n, 千米,公里) of ice-it will notbe sunlight. That is a bit of a problem.<br>欧罗巴远离太阳，在数公里厚的冰层之下，因此，无论欧罗巴上有什么，它都不会有阳光。这有点问题<br>On Earth almost every living thing ultimately (ady,最后:最终) depends (yi, 依赖，依靠;相信，信赖;取决干) onphotosynthesis for its energy, including the rich ecosystems (n. 生态系统) in the ocean depths (n. 深度;深奥),discovered in the 1980s and which helped the idea of life on Europa gain (n.收获;增加;利润 v.获得;增加;<br>赚到) a foothold(n.立足处;据点).在地球上，几乎所有生物最终都依赖光合作用获取能量，包括20世纪80年代发现的丰富的海洋深处生态系统，这有助于欧罗巴上存在生命的观点获得立足点。<br>Their inhabitants (n, 居民) do not benefit from sunlight directlv, but their metabolisms (n, 新陈代谢) arepowered by chemicals created in the photosynthesising, oxygen-rich surface oceans far above.那里的居民并不直接受益于阳光，但他们的新陈代谢是由远在天上、进行光合作用、氧气丰富的海洋表面产生的化学物质提供能量的。<br>There’s none of that on Europa. But there does not have to be欧罗巴上没有这些。但也不一定要有。<br>Some of the microbes living in fissures in the earth’s sea bed make use of chemicals that come entirelyfrom below, rather than above.<br>一些生活在地球海床裂缝中的微生物利用完全来自下方而不是上方的化学物质<br>It is a scant (adj.不足的;缺乏的;勉强够的 vt.减少;节省;限制)source of energy, but areal one. And Europamight offer much the same.<br>这是一种稀少的能量来源，但却是真实存在的。欧罗巴可能也提供类似的能量<br>Analysing (vt. 分析;分解;细察) Europa’s surface chemistry (n. 化学) may give clues as to whether somethingsimilar could, at least in principle (n.原理;原则;主义;信念),be happening on its ocean floor分析欧罗巴的表面化学成分可能会提供线索，说明类似的事情是否至少在原则上可能发生在其海底。<br>And Europa Clipperwil not be the only probe (n. 探针;调查 vi. 调查;探测) hanging out at Jupiter.欧罗巴快船将不是唯一在木星上停留的探测器<br>_ast year saw the launch (vt.发射(导弹、火箭等);发起，发动;使….下水 v.下水;开始;起飞)ofa Europeanprobe called the Jupiter lcy Moons Explorer(n.探测者，探测器;探险家)(JUICE(n.果汁;(水果)汁，液))<br>去年，欧洲发射了一个名为木星冰卫星探测器(JUICE)的探测器。<br>It will likewise (adv, 也; 同样地) examine Europa, as well as Callisto and Ganymede, two other moons that arealso thought to have oceans.<br>它还将研究欧罗巴，以及另外两颗被认为也拥有海洋的卫星木卫四和木卫三<br>The vagaries of orbital (adj. 轨道的;眼窝的) mechanics mean that, despite its later departure (n.离开,离去)Europa Clipperwill arrive in 2030, a year before JUlCE.<br>轨道力学的变化意味着，尽管欧罗巴快船较晚离开，但它将于2030年抵达，比JUICE早一年。<br>If the findings from the two missions are sufficiently (ady,足够地,充分地)exciting (adi,使人激动的;令人兴奋的 v激动;唤起;刺激(excite的ing形式)),then the next step could be to send alander.如果这两次任务的发现足够令人兴奋，那么下一步可能是发射着陆器。<br>Scouting for landing sites on Europa is another of Europa Clipper’s goals.<br>寻找欧罗巴上的着陆点是欧罗巴快船的另一个目标。<br>But the probe will not be able to build a perfect map of the moon’s surface.<br>但探测器无法绘制出完美的月球表面地图。<br>Jupiter’s powerful maqnetic (adi.有吸引力的;有磁性的;地磁的) field produces areas of intense (adi. 强烈的;紧张的;热情的;非常的)radiation(n.辐射能;放射 放射物) near the planet, enough to fry any spacecraft (n.宇宙飞船) that dingers (vi. 逗留, 徘徊 缓慢消失) too long.<br>木星强大的磁场在木星附近产生强烈辐射区，足以摧毁任何停留时间过长的航天器，<br>Europa Clipper wil, instead, make 49 looping flybys, gathering as much data as possible each time beforeretreating to a safe distance.<br>相反，欧罗巴快船将进行49次循环飞行，每次在撤退到安全距离之前收集尽可能多的数据，<br>The world’s alien-hunters will be hoping it survives.<br>全世界的外星人猎人都希望它能幸存下来。</p>]]></content>
      
      
      <categories>
          
          <category> 经济学人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学人2024 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类的简单模拟实现</title>
      <link href="/2024/11/04/cpp-String%20implement/"/>
      <url>/2024/11/04/cpp-String%20implement/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近学到了string的相关的库，于是为了加深对函数的理解便打算模拟实现一下常用的string库函数。</p></blockquote><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>这是一个简单的string类的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The length of the string is: &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上可见，string类是C++标准库中的一个类，它定义在<code>std命名空间</code>中。因此，当使用string类时，需要指定其命名空间为std，若未定义，则可能被认为是未定义的标识符，从而导致错误。</p><blockquote><p>std是C++标准库中定义的命名空间，它包含了许多C++标准库中的类、函数和类型定义。在C++中，命名空间提供了一种将名称隔离开来以<code>避免名称冲突</code>的机制。这样，不同库中的同名函数或类就可以在同一个程序中共存，而不会发生冲突。</p></blockquote><p>所以我想进行模拟的string类实现，为了避免与std的string类冲突，就自定义了一个新的namespace——newstring。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> newstring &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line"><span class="type">size_t</span> _capacity;</span><br><span class="line"><span class="type">char</span>* _str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在newstring这块命名空间中，我创建了自己的string类，有三个基本元素：</p><ol><li>字符串_str</li><li>容量_capacity</li><li>目前大小_size</li></ol><p>设置容量和大小的目的主要是为了方便内存的管理，同时需要注意，字符串虽然是以’\0’结尾，但在string类中，是否结束的标志是size。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;123\\01212121&quot;</span>;</span><br><span class="line">   <span class="type">size_t</span> len = str<span class="number">1.</span><span class="built_in">size</span>(); <span class="comment">// 获取字符串的长度，不包括 null 结尾符</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> c : str1) &#123; <span class="comment">// 遍历字符串，包括 null 字符和换行符</span></span><br><span class="line">       std::cout &lt;&lt; c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上，输出的结果是123\01212121，并没有遇到\0就终止。</p><h1 id="函数模拟实现"><a href="#函数模拟实现" class="headerlink" title="函数模拟实现"></a>函数模拟实现</h1><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>首先要实现的是构造和析构函数，其重要性不必多说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">_capacity = _size;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[_size + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(_str, str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">string</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = <span class="literal">nullptr</span>;</span><br><span class="line">_size = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里还有一点要注意，虽然常见的输入都是以’\0’为结尾的字符串，但有时候仍然会遇见<br>中间出现’\0’的串，这时使用这里的构造函数就会出现问题了。</p></blockquote><p>比如，一个串为”hello\0world”,在进行strcpy时就只会copy到<code>第一个遇到的\0</code>为止，后面的内容就会遗失，所以为了避免这种情况，可以考虑将strcpy换成<code>memcpy</code>。</p><p>不清楚的可以看下这里的对比分析。</p><p>strcpy 和 memcpy 都是 C&#x2F;C++ 中常用的<code>字符串/内存拷贝</code>函数。<br>strcpy 函数用于将一个以 <code>null</code> 结尾的字符串从源地址拷贝到目标地址，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，dest 是<code>目标地址</code>，src 是<code>源地址</code>。strcpy 函数会将源地址（包括 null 结尾符）中的所有字符拷贝到目标地址中，并<code>返回目标地址的指针</code>。strcpy 函数<code>不会检查目标地址是否有足够的空间</code>来存储源地址中的所有字符，如果目标地址不够大，可能会导致内存溢出和程序崩溃的问题。</p><p>例如，下面的代码使用 strcpy 函数将字符串 “Hello, world!” 拷贝到字符数组 str 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>memcpy 函数用于将<code>指定长度的内存块</code>从源地址拷贝到目标地址，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，dest 是目标地址，src 是源地址，count 是要拷贝的字节数。memcpy 函数会将源地址中的指定长度的内存块拷贝到目标地址中，并返回目标地址的指针。与 strcpy 不同，memcpy 函数<code>不会自动添加 null 结尾符</code>，而且要求目标地址有足够的空间来存储拷贝的数据。</p><p>例如，下面的代码使用 memcpy 函数将长度为 10 的内存块从数组 src 中拷贝到数组 dest 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> src[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dest, src, <span class="built_in">sizeof</span>(src));</span><br></pre></td></tr></table></figure><p>下面这一点非常重要！</p><blockquote><p>由于 memcpy 函数<code>不会自动添加 null 结尾符</code>，如果使用 memcpy 函数拷贝字符串时，需要手动添加 null 结尾符，例如：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span>* src = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(str, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>); <span class="comment">//将原字符串带的\0一起复制到新的空间。</span></span><br></pre></td></tr></table></figure><h2 id="snowflake-获取其长度，容量，内容"><a href="#snowflake-获取其长度，容量，内容" class="headerlink" title=":snowflake:获取其长度，容量，内容"></a>:snowflake:获取其长度，容量，内容</h2><p>由于是自定义的类，无法直接使用cout来输出，那么就可以考虑实现c_str来获取字符串内容。长度和容量由于在其他函数中复用很多，也就一并拿出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 获取字符串长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">//这里的 const 表示该成员函数是一个常量成员函数。这意味着它不会修改类的任何成员变量。因此，这个成员函数可以在常量对象上被调用，也可以在被声明为 const 的对象指针或引用上被调用。</span></span><br><span class="line"><span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串容量</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串内容</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">//这里的 const 表示返回的指针指向的字符数组是常量，即通过这个指针不能修改字符数组的内容。</span></span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="reserve函数"><a href="#reserve函数" class="headerlink" title="reserve函数"></a>reserve函数</h2><p>reserve 函数用于为<code>字符串预分配内存空间</code>，以提高字符串操作的效率和性能。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(size_type new_cap)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，new_cap 是要预分配的内存空间大小，以字节为单位。reserve 函数会尝试为字符串分配至少 new_cap 个字节的内存空间，如果当前已经分配的内存空间足够大，则不会进行分配，如果分配失败，则会抛出 <code>std::bad_alloc</code> 异常。</p><p>下面的代码使用 reserve 函数为字符串 str 预分配 100 个字节的内存空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">str.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>调用reserve函数仅仅是为字符串预分配内存空间，并<code>不会改变字符串的长度</code>。如果要修改字符串的长度，可以使用 resize 函数或者直接对字符串进行赋值操作。<br>另外，由于 C++ STL 中的 std::string 类已经封装了内存管理的细节，因此在大多数情况下不需要手动调用 reserve 函数进行内存管理，只需要使用字符串类提供的成员函数和操作符即可。只有在特殊的性能优化或者内存限制的情况下，才需要手动调用 reserve 函数。</p><p>模拟实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; _capacity) <span class="comment">//只有当预留空间大于当前分配空间才会进行</span></span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">//核心思路就是开辟一个新的空间，让旧指针指向他</span></span><br><span class="line"><span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(tmp, _str);</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = tmp;</span><br><span class="line">_capacity = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="push-back和append函数"><a href="#push-back和append函数" class="headerlink" title="push_back和append函数"></a>push_back和append函数</h2><p>push_back 和 append用于向字符串<code>末尾</code>添加新的字符或字符串。它们的区别和用法如下：</p><h3 id="cyclone-push-back"><a href="#cyclone-push-back" class="headerlink" title=":cyclone:push_back"></a>:cyclone:push_back</h3><p>push_back 函数用于向字符串末尾添加<code>一个字符</code>。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，ch 是要添加的字符。例如，下面的代码使用 push_back 函数向字符串 str 中添加字符 ‘a’：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，push_back 函数将字符 ‘a’ 添加到字符串 str 的末尾。<br>模拟实现为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2倍扩容</span></span><br><span class="line"><span class="built_in">reserve</span>(_capacity == <span class="number">0</span> ? <span class="number">4</span> : _capacity * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_str[_size] = ch;</span><br><span class="line"></span><br><span class="line">++_size;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//不要忘记\0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>append 函数用于向字符串末尾添加<code>一个字符串</code>。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> basic_string&amp; str)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，str 是要添加的字符串，s 是要添加的字符数组，n 是要添加的字符个数，c 是要添加的字符。例如，下面的代码使用 append 函数向字符串 str 中添加一个字符串和一个字符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot; - C++&quot;</span>, <span class="number">5</span>).<span class="built_in">append</span>(<span class="number">1</span>, <span class="string">&#x27;!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，append 函数先将字符串 “ - C++” 中的前 5 个字符（即 “ - C”）添加到字符串 str 的末尾，然后再将字符 ‘!’ 添加到字符串 str 的末尾。<br>append 函数可以一次性向字符串中添加多个字符和字符串，比 push_back 函数更加灵活。</p><p>模拟实现为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 至少扩容到_size + len</span></span><br><span class="line"><span class="built_in">reserve</span>(_size + len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(_str + _size, str);</span><br><span class="line">_size += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="+&#x3D;操作符"></a>+&#x3D;操作符</h2><p>有了append和push_back，+&#x3D;直接复用就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(ch);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str)  <span class="comment">//思考为什么要加const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">append</span>(str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二个函数如果去掉const，使用str+&#x3D;”abc”这样的语句，编译器会报错:没有与这些操作数匹配的 “+&#x3D;” 运算符。原因是”abc”的类型是const char，同时被<code>隐式转换为const char*</code>，参数却希望接受char*，这样的结果当然是编译器所不希望的，也就是所谓的权限放大。明明是不可以更改的常量串，传个参还变成可更改了，这自然不被允许。</p></blockquote><h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2><p>insert用于向字符串中插入字符或字符串。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> basic_string&amp; str)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> basic_string&amp; str, size_type subpos, size_type sublen)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> <span class="type">char</span>* s, size_type n)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, size_type n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator p, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator p, size_type n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator p, InputIt first, InputIt last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 是要插入的位置，str 是要插入的字符串，subpos 和 sublen 是要插入的子字符串的起始位置和长度，s 是要插入的字符数组，n 是要插入的字符个数，c 是要插入的字符，p 是要插入的位置，first 和 last 是要插入的字符序列的起始和结束迭代器。</p><p>在指定位置插入一个字符或一个字符序列。<br>例如，下面的代码使用 insert 函数在字符串 str 的第 5 个位置插入字符 ‘a’：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，insert 函数将字符 ‘a’ 插入到字符串 str 的第 5 个位置。</p><p>insert 函数还可以插入一个字符序列，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot; - C++&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，insert 函数将字符串 “ - C++” 插入到字符串 str 的第 5 个位置。</p><p>常用的也就是上面两种。<br>模拟实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_size + n &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 至少扩容到_size + len</span></span><br><span class="line"><span class="built_in">reserve</span>(_size + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end = _size;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos &amp;&amp; end&lt;_size)<span class="comment">//重要的地方</span></span><br><span class="line">&#123;</span><br><span class="line">_str[end + n] = _str[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos + i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_size += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* str)</span>  <span class="comment">//同理要加const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 至少扩容到_size + len</span></span><br><span class="line"><span class="built_in">reserve</span>(_size + len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end = _size;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos &amp;&amp; end != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">_str[end + len] = _str[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos + i] = str[i]; <span class="comment">//别写成了_sre[end]，此时enb比pos还小1</span></span><br><span class="line">&#125;   <span class="comment">//不用for循环同样可以用memcpy或者strcpy，</span></span><br><span class="line">    <span class="comment">//示例:memcpy(_str + pos, str, len);</span></span><br><span class="line"></span><br><span class="line">_size += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert的模拟实现就是先判定空间是否够大，不够大就扩容，然后把插入位置pos后面的元素都往后挪n个位置，再回到pos插入指定的元素。</p><blockquote><p>while (end &gt;&#x3D; pos &amp;&amp; end&lt;&#x3D;_size)</p></blockquote><p>这个地方单独提一下，因为end存在减为0继续减到-1的情况，但这里end是size_t类型，是一个<code>无符号整型</code>，当0再减1时，end就变成了一个<code>极大数</code>，此时需要end&lt;&#x3D;_size来终止循环。</p><h2 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h2><p>find用于在字符串中查找指定子串的位置。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> basic_string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>其中，str 是要查找的子串，s 是要查找的字符数组，n 是要查找的字符个数，c 是要查找的字符，pos 是查找起始位置。具体用法如下：</p><p>查找指定字符串在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找子串 “world” 的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，find 函数查找字符串 “world” 在字符串 str 中第一次出现的位置，并将其返回。如果字符串 “world” 不在字符串 str 中，find 函数将返回 std::string::npos。</p><p>查找指定字符数组在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找字符数组 “world” 的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，find 函数在字符串 str 的第 7 个位置开始查找字符数组 “world” 的前 5 个字符，并将其返回。如果字符数组 “world” 不在字符串 str 中，find 函数将返回 std::string::npos。</p><p>查找指定字符在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找字符 ‘o’ 的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，find 函数在字符串 str 的第 5 个位置开始查找字符 ‘o’ 的位置，并将其返回。如果字符 ‘o’ 不在字符串 str 中，find 函数将返回 std::string::npos。</p><blockquote><p>在string类中存在<code>npos</code>这个<code>特殊的常量</code>。在字符串操作中，通常使用 find 等函数来查找指定子串或字符在原字符串中的位置。如果查找失败，这些函数会<code>返回一个特殊的值 npos</code>，以表示查找失败的情况。</p></blockquote><p>以下是两种常用形式的模拟实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> ch, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = pos; i &lt; _size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_str[i] == ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//也可以是npos，不过需要自己新定义一个，npos 是 std::string::npos 的一个静态成员变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = <span class="built_in">strstr</span>(_str + pos, str); <span class="comment">//strstr 是 C 语言标准库中的一个函数，用于在一个字符串中查找另一个字符串的第一次出现位置。</span></span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ptr - _str; <span class="comment">//返回偏移量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重要必看-substr函数"><a href="#重要必看-substr函数" class="headerlink" title="(重要必看)substr函数"></a>(重要必看)substr函数</h2><p>substr用于从一个字符串中提取子串。其函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> count = npos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 是子串的起始位置，count 是子串的长度。如果省略 count 参数，则返回从 pos 开始到字符串末尾的所有字符。如果 pos 大于等于字符串的长度，或者 count 为 0，那么函数返回一个空字符串。</p><p>下面是一个使用 substr 函数提取子串的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>);  <span class="comment">// 从位置 7 开始提取长度为 5 的子串</span></span><br><span class="line">    std::cout &lt;&lt; sub &lt;&lt; std::endl;  <span class="comment">// 输出 &quot;world&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，substr 函数从字符串 str 中提取了一个子串，其起始位置是 7，长度是 5。提取出的子串是 “world”，并赋值给了变量 sub。<br>模拟实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line"><span class="type">size_t</span> n = length;</span><br><span class="line"><span class="keyword">if</span> (pos + length &gt; size)</span><br><span class="line">n = size - pos;</span><br><span class="line">string tmp;</span><br><span class="line"><span class="type">char</span>* s = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];</span><br><span class="line">tmp._str = s;</span><br><span class="line">tmp._capacity = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">tmp += _str[pos + i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里有几个需要注意的点。第一是string tmp并未传入参数，所以此处调用<code>无参构造</code>。而上文还未实现无参构造。第二，return时会调用拷贝构造函数，上文也没写拷贝构造。</p></blockquote><p><em><strong>敲重点！非常重要</strong></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value) &#123;&#125; <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">data</span>(other.data) &#123;&#125; <span class="comment">// 拷贝构造函数  </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> data;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用构造函数  </span></span><br><span class="line">MyClass* objPtr = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">20</span>); <span class="comment">// 调用构造函数，在堆上创建对象并初始化data为20</span></span><br><span class="line">MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数，创建obj2作为obj1的副本  </span></span><br><span class="line"><span class="function">MyClass <span class="title">obj3</span><span class="params">(obj1)</span></span>; <span class="comment">// 同样调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>return时返回类型是string，所以该返回一份副本，应该调用拷贝构造函数。如果是引用或者指针的形式，就不会创建副本，也就不会调用拷贝构造，但这个行为非常危险！</p><p>完善无参构造与拷贝构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">string</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">capacity</span>(<span class="number">0</span>),_str(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数  </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; other) &#123;</span><br><span class="line">size = other.size;</span><br><span class="line">capacity = other.capacity;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[capacity + <span class="number">1</span>];</span><br><span class="line">std::<span class="built_in">memcpy</span>(_str, other._str, size + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>因为是自己实现的类，所以如果要用到范围for这样的代码，就得自己实现迭代器。注意有无const的情况最好都写一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">//必须要加const，单纯返回类型不一致无法构成重载！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//同理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用范围for等需要迭代器的用法了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : s1) &#123;</span><br><span class="line">       std::cout &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果你的类支持正向遍历和反向遍历，你可能需要实现两个迭代器：一个<code>正向迭代器和一个反向迭代器</code>。</p><p>一旦你实现了迭代器，你的自定义类就可以像标准容器一样使用范围for语句了。在范围for语句中，你需要使用 <code>begin() </code>方法返回你的类的起始迭代器，使用<code>end()</code> 方法返回你的类的结束迭代器。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回正向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回正向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">ReverseIterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回反向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">ReverseIterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回反向迭代器 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyContainer container;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : container) &#123;</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : std::<span class="built_in">reverse</span>(container)) &#123;</span><br><span class="line">    <span class="comment">// 反向遍历元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h2><p>resize() 是 C++ 标准库中容器和字符串类中的一个成员函数，用于改变容器或字符串的大小。<br>resize() 会<code>改变容器中元素的个数</code>。<br>对容器而言：</p><ol><li>如果新的大小<code>小于</code>当前大小，那么超出新大小的元素将被截断；</li><li>如果新的大小<code>大于</code>当前大小，那么容器将增加新元素，并使用默认构造函数初始化这些新元素。</li></ol><p>对于字符串：</p><ol><li>如果新的大小<code>小于</code>当前大小，那么超出新大小的字符将被截断；</li><li>如果新的大小<code>大于</code>当前大小，那么字符串将增加新字符，并使用<code> &#39;\0&#39; 字符</code>填充这些新字符。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> ch = <span class="string">&#x27;\0&#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; _size)</span><br><span class="line">&#123;</span><br><span class="line">_size = n;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = _size; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_size = n;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些运算符"><a href="#一些运算符" class="headerlink" title="一些运算符"></a>一些运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">memcmp</span>(_str, s._str, _size &lt; s._size ? _size : s._size); <span class="comment">//第三个参数确定要比较的字节数</span></span><br><span class="line"><span class="comment">//_str比s._str大则返回正数，小则返回负数，相等则返回0</span></span><br><span class="line"><span class="keyword">return</span> ret == <span class="number">0</span> ? _size &lt; s._size : ret &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 const 修饰的是<code>函数参数 s</code>，表示该参数是一个常量引用，避免了对参数进行修改。而第二个 const 修饰的是<code>函数自身</code>，表示该成员函数不会修改对象的状态，即不会修改该对象的成员变量。<br>用一个写好的运算符在其他的运算符中进行复用也是一个常见的技巧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _size == s._size </span><br><span class="line">&amp;&amp; <span class="built_in">memcmp</span>(_str, s._str, _size) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> &lt; s || *<span class="keyword">this</span> == s;  <span class="comment">//像这个，直接就复用了才写好的&lt;和==</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="&lt;&lt;与&gt;&gt;"></a>&lt;&lt;与&gt;&gt;</h2><p>要实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>这样的效果，就需要重载&gt;&gt;与&lt;&lt;操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = in.<span class="built_in">get</span>(); <span class="comment">//从输入流中读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">//检查此字符是否是空字符或者&#x27;\0&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">ch = in.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch != <span class="string">&#x27; &#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff[i++] = ch;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">127</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">s += buff;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch = in.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">s += buff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这两个重载需要放在全局情况中，不要放到string类中！</p></blockquote><p>这是因为在 C++ 中，运算符重载是一种基于函数重载的机制，它允许自定义类对象的行为，并支持与内置类型的相同语义。在大多数情况下可以重载任何运算符，包括 &lt;, &gt;, &#x3D;&#x3D;, &lt;&lt; 和 &gt;&gt; 等。<br>然而，对于 &lt;&lt; 和 &gt;&gt; 运算符，它们具有特殊的语义，通常用于<code>输入和输出</code>操作，因此在重载时需要特别注意。如果将 &lt;&lt; 或 &gt;&gt; 运算符<code>作为成员函数</code>来定义，其左操作数将被隐式地设置为<code>该类的对象</code>，而右操作数则需要作为<code>函数参数</code>传入。但是，对于输入流对象和输出流对象，它们是作为<code>全局对象</code>存在的，而不是作为类的成员对象存在的，因此需要使用全局函数来重载这些运算符。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态</title>
      <link href="/2024/11/03/cpp-Inheritance%20and%20polymorphism/"/>
      <url>/2024/11/03/cpp-Inheritance%20and%20polymorphism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学到了cpp的继承和多态这块，感觉知识点还是很细碎繁杂的，所以就写了一篇博客记录一下在这一块遇到的一些容易搞错的问题。</p></blockquote><h1 id="三种继承"><a href="#三种继承" class="headerlink" title="三种继承"></a>三种继承</h1><blockquote><p>cpp的三种继承：public（公有继承）、protected（保护继承）和private（私有继承）。</p></blockquote><h2 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h2><p>公有继承是最常见的继承方式，基类的公有成员在派生类中仍然是公有的，保护成员在派生类中变为保护的，私有成员在派生类中是不可访问的。<br>使用public关键字来表示公有继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::publicFunc()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPublic</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar 是公有的</span></span><br><span class="line">    <span class="comment">// publicFunc() 是公有的</span></span><br><span class="line">    <span class="comment">// protectedVar 变为保护的</span></span><br><span class="line">    <span class="comment">// privateVar 不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DerivedPublic derived;</span><br><span class="line">    derived.publicVar = <span class="number">42</span>; <span class="comment">// 可访问</span></span><br><span class="line">    derived.<span class="built_in">publicFunc</span>();  <span class="comment">// 可访问</span></span><br><span class="line">    <span class="comment">//derived.protectedVar = 10; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.privateVar = 20; // 错误，不能访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><p>保护继承使得基类的公有和保护成员在派生类中变为保护的，私有成员在派生类中是不可访问的。<br>使用protected关键字来表示保护继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::publicFunc()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedProtected</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar 变为保护的</span></span><br><span class="line">    <span class="comment">// publicFunc() 变为保护的</span></span><br><span class="line">    <span class="comment">// protectedVar 变为保护的</span></span><br><span class="line">    <span class="comment">// privateVar 不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DerivedProtected derived;</span><br><span class="line">    <span class="comment">//derived.publicVar = 42; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.publicFunc();  // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.protectedVar = 10; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.privateVar = 20; // 错误，不能访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>私有继承使得基类的公有和保护成员在派生类中变为私有的，私有成员在派生类中是不可访问的。<br>使用private关键字来表示私有继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::publicFunc()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPrivate</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar 变为私有的</span></span><br><span class="line">    <span class="comment">// publicFunc() 变为私有的</span></span><br><span class="line">    <span class="comment">// protectedVar 变为私有的</span></span><br><span class="line">    <span class="comment">// privateVar 不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DerivedPrivate derived;</span><br><span class="line">    <span class="comment">//derived.publicVar = 42; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.publicFunc();  // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.protectedVar = 10; // 错误，不能访问</span></span><br><span class="line">    <span class="comment">//derived.privateVar = 20; // 错误，不能访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：基类private成员在派生类中不管怎么继承<code>都是不可见</code>的。<br>使用关键字<code>class</code>时默认的继承方式是<code>private</code>，使用<code>struct</code>时默认的继承方式是<code>public</code>，不过最好直接了当地写出继承方式。<br>在实际运用中一般使用都是public继承，几乎很少使用protetced&#x2F;private继承，也不提倡使用protetced&#x2F;private继承，因为protetced&#x2F;private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。</p><h1 id="基类和派生类的赋值转换"><a href="#基类和派生类的赋值转换" class="headerlink" title="基类和派生类的赋值转换"></a>基类和派生类的赋值转换</h1><blockquote><p>基类和派生类之间的对象赋值转换包括两种类型：向上转换（Upcasting）和向下转换（Downcasting）。</p></blockquote><h2 id="向上转换（Upcasting）"><a href="#向上转换（Upcasting）" class="headerlink" title="向上转换（Upcasting）"></a>向上转换（Upcasting）</h2><p>向上转换是将<code>派生类</code>的指针或引用赋值给<code>基类</code>指针或引用的过程。由于派生类<code>包含了基类的部分</code>，所以向上转换是安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    Base* basePtr = &amp;derivedObj; <span class="comment">// 向上转换</span></span><br><span class="line"></span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 输出 &quot;Base class&quot;，即使是派生类对象，调用的也是基类的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要把这个和多态搞混了，实现多态需要使用<code>虚函数</code>。这个在后面会提。<br>之所以会出现子类对象调用父类函数的原因是因为：在向上转换的情况下，将派生类对象的地址赋值给基类指针basePtr，调用basePtr-&gt;display()时，编译器会根据<code>指针的静态类型（即基类指针）</code>来确定调用的函数。因为静态类型是<code>Base*</code>，编译器会查找Base类中是否有名为display的成员函数。即使在派生类Derived中也存在名为display的成员函数，编译器也只会在Base类中查找。</p><p>这种行为称为<code>静态绑定或早绑定</code>，因为编译器在编译时就确定了要调用的成员函数，不考虑运行时对象的实际类型。</p><h2 id="向下转换（Downcasting）"><a href="#向下转换（Downcasting）" class="headerlink" title="向下转换（Downcasting）"></a>向下转换（Downcasting）</h2><p>向下转换是将基类的指针或引用赋值给派生类指针或引用的过程。由于基类可能不是派生类的对象，因此向下转换需要进行类型检查，确保转换是有效的。<br>但是实际中很少会用到向下转换。<br>为了进行向下转换（从基类到派生类），可以使用<code>dynamic_cast</code>运算符，但是这种转换要求基类指针指向的对象必须是<code>派生类的实例</code>，否则转换会失败并返回nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;   <span class="comment">//虚函数，实现了多态。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base baseObj;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    Base* basePtr = &amp;derivedObj;</span><br><span class="line"></span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 因为base里的displya是虚函数，所以输出 &quot;Derived class&quot;，通过基类指针调用派生类的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下转换，几乎不会使用！看看就行了</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line">    <span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        derivedPtr-&gt;<span class="built_in">display</span>(); <span class="comment">// 输出 &quot;Derived class&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to downcast&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重载和隐藏"><a href="#重载和隐藏" class="headerlink" title="重载和隐藏"></a>重载和隐藏</h1><blockquote><p>重载（Overloading）和隐藏（Hiding）是两种不同的概念，用于描述函数和成员变量在继承关系中的行为。</p></blockquote><h2 id="函数重载（Function-Overloading）"><a href="#函数重载（Function-Overloading）" class="headerlink" title="函数重载（Function Overloading）"></a>函数重载（Function Overloading）</h2><p>函数重载是指在<code>同一个作用域</code>内，定义了多个函数，它们具有<code>相同的名称但具有不同的参数列表</code>。函数重载的目的是为了提供一种简洁和直观的方式来处理不同类型或数量的参数，以实现相似的功能。在进行函数调用时，编译器根据调用的函数参数类型和数量来决定要调用的具体函数。</p><ol><li>函数重载发生在<code>同一个作用域</code>内。</li><li>函数重载根据<code>函数的参数列表</code>来区分函数。</li><li>返回值类型不会影响函数重载的判定。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);      <span class="comment">// 调用 void print(int num)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2.1</span>);    <span class="comment">// 调用 void print(double num)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数隐藏（Member-Function-Hiding）"><a href="#成员函数隐藏（Member-Function-Hiding）" class="headerlink" title="成员函数隐藏（Member Function Hiding）"></a>成员函数隐藏（Member Function Hiding）</h2><p>成员函数隐藏是指在派生类中定义一个<code>与基类中成员函数名称相同</code>的函数，该派生类函数会<code>隐藏</code>基类中的同名函数，使得在派生类对象上<code>无法直接访问</code>基类的同名函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    derivedObj.<span class="built_in">display</span>(); <span class="comment">// 输出 &quot;Derived class&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏了基类的 display() 函数，无法直接通过派生类对象调用基类函数</span></span><br><span class="line">    <span class="comment">// derivedObj.Base::display(); // 通过限定作用域可以访问基类的同名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一波：在继承体系中基类和派生类都有<code>独立</code>的作用域。子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。如果是成员函数的隐藏，<code>只需要函数名相同</code>就构成隐藏。</p><h1 id="默认成员函数"><a href="#默认成员函数" class="headerlink" title="默认成员函数"></a>默认成员函数</h1><p>默认成员函数的本意就是如果我们不写，那么编译器会自动为我们生成。<br>派生类的成员函数会遵循这样的规则：</p><blockquote><p>派生类的构造函数负责初始化派生类<code>自己的成员以及基类的成员</code>。在派生类的构造函数中，需要在构造函数的初始化列表中<code>显式调用基类的构造函数</code>来初始化基类的成员。如果基类没有默认构造函数（无参构造函数），则必须通过派生类构造函数的初始化列表来调用基类构造函数，并传递必要的参数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// Base类构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">Base</span>(x) &#123;</span><br><span class="line">        <span class="comment">// Derived类构造函数</span></span><br><span class="line">        <span class="comment">// Base类的构造函数通过初始化列表调用，传递参数 x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</p></blockquote><p>当使用派生类对象初始化另一个派生类对象或将派生类对象传递给函数时，需要调用拷贝构造函数。在派生类的拷贝构造函数中，必须<code>调用基类的拷贝构造函数</code>来完成基类成员的拷贝初始化，以确保基类部分正确地复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        <span class="comment">// Base类拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> Derived&amp; other) : <span class="built_in">Base</span>(other) &#123;</span><br><span class="line">        <span class="comment">// Derived类拷贝构造函数</span></span><br><span class="line">        <span class="comment">// Base类的拷贝构造函数通过初始化列表调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>派生类的operator&#x3D;必须要调用基类的operator&#x3D;完成基类的复制。</p></blockquote><p>类的赋值运算符（operator&#x3D;）用于将一个对象的值赋给另一个对象。当派生类需要赋值运算符时，应该在派生类的operator&#x3D;中<code>调用基类的operator=</code>来完成基类部分的复制操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        <span class="comment">// Base类赋值运算符</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; other) &#123;</span><br><span class="line">        <span class="comment">// Derived类赋值运算符</span></span><br><span class="line">        Base::<span class="keyword">operator</span>=(other); <span class="comment">// 调用基类的赋值运算符</span></span><br><span class="line">        <span class="comment">// 处理派生类的赋值操作</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>派生类的析构函数会在被调用完成后<code>自动调用基类的析构函数</code>清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        <span class="comment">// Base类析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        <span class="comment">// Derived类析构函数</span></span><br><span class="line">        <span class="comment">// 在析构函数执行完毕后，会自动调用Base类的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="友元和静态成员"><a href="#友元和静态成员" class="headerlink" title="友元和静态成员"></a>友元和静态成员</h1><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元关系<code>不能继承</code>，也就是说基类友元不能访问子类私有和保护成员 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() : <span class="built_in">privateData</span>(<span class="number">1</span>), <span class="built_in">protectedData</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(Base&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendFunction</span><span class="params">(Base&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在友元函数中可以访问Base类的私有和保护成员</span></span><br><span class="line">    <span class="type">int</span> a = obj.privateData;    <span class="comment">// 可以访问私有成员</span></span><br><span class="line">    <span class="type">int</span> b = obj.protectedData;  <span class="comment">// 可以访问保护成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> derivedPrivateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : <span class="built_in">derivedPrivateData</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base baseObj;</span><br><span class="line">    <span class="built_in">friendFunction</span>(baseObj); <span class="comment">// 友元函数可以访问Base类的私有和保护成员</span></span><br><span class="line"></span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    <span class="built_in">friendFunction</span>(derivedObj); <span class="comment">// error！友元关系不能继承，不能直接访问Derived类的私有和保护成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Base类声明了一个友元函数friendFunction，该函数可以访问Base类的私有和保护成员。当我们创建一个Base类对象baseObj时，friendFunction可以访问baseObj的私有和保护成员。<br>当创建一个Derived类对象derivedObj时，尝试调用friendFunction(derivedObj)，会抛出异常。因为派生类Derived继承了Base类的友元关系，但是这个继承并不会使friendFunction可以直接访问Derived类的私有和保护成员。<code>友元关系只对声明为友元的类有效，不会在继承层次中传递</code>。</p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>运行下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; ++_count; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _stuNum; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graduate</span> : <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _seminarCourse; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">        Student s1;</span><br><span class="line">        Student s2;</span><br><span class="line">        Student s3;</span><br><span class="line">        Graduate s4;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到结果：4。因为基类定义了static静态成员，则整个继承体系里面<code>只有一个这样的成员</code>。</p><h1 id="菱形虚拟继承"><a href="#菱形虚拟继承" class="headerlink" title="菱形虚拟继承"></a>菱形虚拟继承</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>菱形虚拟继承是指在多重继承中，通过使用虚拟继承来解决由于多个基类共同派生同一个中间基类而导致的二义性和资源浪费问题。</p></blockquote><p>假设有一个基类Animal，两个派生类Bird和Fish，以及一个继承自Bird和Fish的派生类FlyingFish。此时，如果Bird和Fish都派生自Animal，而FlyingFish又同时继承自Bird和Fish，那么会形成一个菱形继承的结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Animal</span><br><span class="line">  /    \</span><br><span class="line">Bird   Fish</span><br><span class="line">  \    /</span><br><span class="line"> FlyingFish</span><br></pre></td></tr></table></figure><p>在这种情况下，FlyingFish类会同时继承自Bird和Fish，而Bird和Fish都继承自Animal。这样就会导致FlyingFish类中<code>有两份Animal类的副本</code>，而这两份副本实际上是<code>同一个类的不同实例</code>，造成了资源浪费。</p><p>此外，如果Bird和Fish分别定义了相同名称的成员函数或成员变量，那么在FlyingFish中使用这些名称时将会产生<code>二义性</code>。</p><p>C++提供了虚拟继承（virtual inheritance）的机制。在虚拟继承中，使用<code>关键字virtual</code>来声明继承，使得派生类只继承基类的一个<code>共同基类的单一实例</code>，而不是每个直接或间接基类都有一份实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Animal 类定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Bird 类定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Fish 类定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingFish</span> : <span class="keyword">public</span> Bird, <span class="keyword">public</span> Fish &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FlyingFish 类定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过在Bird和Fish类的继承中使用virtual关键字，FlyingFish类将只继承一份Animal类的实例，从而避免了资源浪费和二义性。</p><blockquote><p>二义性？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal is eating.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bird is flying.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fish is swimming.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingFish</span> : <span class="keyword">public</span> Bird, <span class="keyword">public</span> Fish &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FlyingFish 类继承自 Bird 和 Fish</span></span><br><span class="line">    <span class="comment">// Bird 和 Fish 类虚拟继承自 Animal</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个类层次结构中，FlyingFish类继承自Bird和Fish，而Bird和Fish类都虚拟继承自Animal。</p><p>如果没有使用虚拟继承，FlyingFish类将同时继承来自Bird和Fish的各自实例的Animal部分。这样，在FlyingFish类中调用eat()函数时，会发生二义性，因为存在两个Animal的实例。</p><blockquote><p>问题代表本质就在于<code>编译器无法确定应该调用哪个Animal类的eat()函数</code>，从而导致了二义性。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果不用虚拟继承，那么如果有下列结构，会出现数据冗余。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line"><span class="comment">//class B : virtual public A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line"><span class="comment">//class C : virtual public A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>D里会有两个A的_a,这样对内存是一种浪费，也造成了二义性。当改用<code>虚拟继承</code>后，D就只会继承到一个公用的_a了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">2</span>;</span><br><span class="line">    d.C::_a = <span class="number">9</span>;</span><br><span class="line">    std::cout &lt;&lt; d._a;  <span class="comment">//输出9而不是2,2被9覆盖。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; d._a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不采用虚拟继承时：<br>打开内存窗口，监视d的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x000000E2788FF968  01 00 00 00  ....    //d.B::_a</span><br><span class="line">0x000000E2788FF96C  03 00 00 00  ....</span><br><span class="line">0x000000E2788FF970  02 00 00 00  ....    //d.C::_a</span><br><span class="line">0x000000E2788FF974  04 00 00 00  ....</span><br><span class="line">0x000000E2788FF978  05 00 00 00  ....</span><br></pre></td></tr></table></figure><p>可以看到存在两个不同的_a。</p><p>当采用虚拟继承时：</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%811.png'><p>可以看到，此时只存在唯一的_a了。</p><p>当一个类进行虚继承（virtual inheritance），意味着该类继承自一个虚基类。</p><p>虚继承的实现依赖于<code>虚基表（virtual table）和虚基表指针（vptr）</code>：</p><blockquote><p>虚基表（virtual table）</p></blockquote><p>虚基表是一个数据结构，包含了虚基类的相关信息，如虚基类的<code>数据成员偏移量</code>和虚函数表的指针（如果存在虚函数）。<br>对于每个虚基类，编译器会生成一个虚基表。虚基表中的条目和顺序与虚基类的声明顺序一致。<br>图中的0060cd4c和0060cbac就是两个虚基表的地址。</p><blockquote><p>虚基表指针（vptr）</p></blockquote><p>每个含有虚函数或者继承了虚基类的类都会在其对象中包含一个<code>指向虚基表的指针</code>，称为虚基表指针（vptr）。<br>vptr 存储着对应类的虚基表的地址。编译器会在每个对象的<code>起始位置</code>（通常是对象的内存布局的开头）存储这个指针。</p><p>class D 对象中的内存布局包含<code>两个虚基表指针</code>，其中一个指向 class B 的虚基表，另一个指向 class C 的虚基表(如图中蓝线所指，两个指针分别指向两张虚基表)。通过查询各自的虚基表中所存放的<code>偏移量</code>，再和各自指向虚基表的指针的地址相加，就可以获取到_a的真实位置了！</p><blockquote><p>如图，第一个虚基表地址为0060cd4c，偏移量为14 00 00 00，也就是20个字节，正好一行是4字节偏移，往下数四行不正好就是_a的存储位置了吗？0060cbac也是同理，偏移量是12个字节，往下数三行即可。</p></blockquote><h1 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h1><h2 id="构成条件"><a href="#构成条件" class="headerlink" title="构成条件"></a>构成条件</h2><blockquote><p>多态（polymorphism）的构成条件：继承（inheritance）和虚函数（virtual function）。</p></blockquote><p>继承关系（Inheritance）：多态是通过<code>继承关系</code>来实现的。在 C++ 中，基类（父类）可以派生出派生类（子类）。子类可以继承基类的成员变量和成员函数。这样就可以使用<code>基类的指针或引用</code>来操作派生类的对象。</p><p>虚函数（Virtual Function）：通过使用虚函数，可以在基类中声明一个虚函数，然后在派生类中进行<code>重写（覆盖）</code>。虚函数使得在运行时动态地确定要调用的函数，而非静态绑定。<br>在基类中，使用 virtual 关键字声明虚函数。<br>在派生类中，使用 override 关键字来明确地重写基类中的虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Square square;</span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;circle;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a circle.</span></span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;square;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a square.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个要点：</p><ol><li>必须通过<code>基类的指针或者引用</code>调用虚函数。</li><li>被调用的函数必须是<code>虚函数</code>，且派生类必须对基类的虚函数进行重写。</li></ol><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>那么何为虚函数？</p><blockquote><p>虚函数是一种用于实现运行时多态性的特殊函数，可以在基类中声明一个函数为虚函数，然后在派生类中进行<code>重写（覆盖）</code>。这使得在运行时能够<code>动态地确定</code>要调用的函数版本。</p></blockquote><p>在基类中，使用 <code>virtual 关键字</code>来声明虚函数。当在基类中将一个成员函数声明为虚函数时，C++ 编译器会为该类创建一个<code>虚函数表（vtable）</code>（也可以称为虚表），其中保存了指向派生类重写函数的指针。这个虚函数表使得在运行时能够确定调用的是哪个函数版本。</p><p>在派生类中，使用 override 关键字来明确地重写基类中的虚函数。通过重写，派生类提供了一个<code>与基类虚函数同名、参数列表相同</code>的新实现。</p><p>通过基类的指针或引用来调用虚函数时，实际上会在运行时根据对象的类型<code>动态绑定</code>到正确的函数版本。这使得能够调用到派生类中的重写函数，而不是基类的实现。</p><p>虚函数的重写(覆盖)：派生类中有一个跟基类<code>完全相同</code>的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。</p><p>构成条件部分的代码基本展示了虚函数用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Square square;</span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;circle;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a circle.</span></span><br><span class="line"></span><br><span class="line">    shapePtr = &amp;square;</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// Output: Drawing a square.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果基类的<code>析构函数</code>为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析构函数构成重写，虽然函数名不相同，但可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成<code>destructor</code>。</p><h1 id="虚函数表和虚基表的区别"><a href="#虚函数表和虚基表的区别" class="headerlink" title="虚函数表和虚基表的区别"></a>虚函数表和虚基表的区别</h1><p>别把这两个东西给搞混了。</p><blockquote><p>虚基表</p></blockquote><p>在上面的部分已经提到过，在C++中，虚基表是用于解决菱形继承问题的一种机制。菱形继承指的是一个类同时继承了两个共同基类，而派生类又继承了这两个共同基类，导致派生类中<code>含有两份基类成员的副本</code>，造成冗余和二义性。</p><p>为了解决这个问题，C++引入了虚基类的概念。虚基类是在多重继承中声明为虚拟的基类，这样在派生类中就只会包含一个共同的基类子对象，而不会出现冗余。</p><blockquote><p>虚函数表(虚表)</p></blockquote><p>虚函数表是数据库中一种用于<code>实现多态性</code>的机制，通常用于支持对象关系映射和继承关系。<br>其中包含了对象的虚函数指针,对象的虚函数通过虚表来实现动态绑定（Dynamic Binding），也就是在运行时确定调用哪个实际函数，实现多态性。</p><p>当一个对象被创建时，会根据其实际类型初始化虚表指针，以便正确调用属于该对象实际类型的虚函数。这样，即使通过基类指针或引用来调用虚函数，也能够正确地执行派生类中相应的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Draw a circle.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Draw a square.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，Shape类是一个抽象基类，它包含一个虚函数draw。Circle和Square是Shape的派生类，它们都实现了draw函数。每个对象的虚表中存储着<code>对应的虚函数指针</code>，确保在运行时能正确调用相应的派生类的draw函数。</p><p>这么讲可能还是有点不清楚，得从原理下手才行。</p><p>先看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调一下内存窗口：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%812.png'></p><p>可以看到这里多出了一个<code>__vfptr</code>，对象中的这个指针我们叫做<code>虚函数表指针</code>(v代表virtual，f代表function)。一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，所以一定会有__vfptr。</p><p>再写一个派生类出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Base::print1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Base::print2()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Base::print3()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base::print1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Base b;</span><br><span class="line"> Derive d;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调出内存窗口：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%813.png'></p><p>派生类对象d中同样包含一个虚表指针。d对象由两部分构成：一部分是<code>继承自父类的成员</code>，包括虚表指针，这部分可以称为继承部分；另一部分是派生类<code>自己的成员</code>，即新增的成员。基类b对象和派生类d对象的虚表是<code>不相同</code>的。在派生类d中，我们发现print1函数被重写（覆盖）。因此，d的虚表中存储的是重写后的Derive::print1，这也是虚函数的重写和覆盖的两种叫法，分别是语法层和原理层的称呼。</p><p>另外，虚表中还包含继承自基类的其他虚函数，例如print2。由于print2是基类中的虚函数，在派生类中也被继承下来，因此被放进了派生类d的虚表中。但是print3并不是虚函数，因此不会放进派生类d的虚表中。</p><p>虚函数表本质上是一个<code>存放虚函数指针</code>的指针数组，通常在数组的最后面会放置一个nullptr，表示虚函数表的结束。</p><p>总结一下派生类虚表的生成过程：</p><ol><li>首先将基类中的虚表内容拷贝一份到派生类的虚表中；</li><li>如果派生类重写了基类中的某个虚函数，就用派生类自己的虚函数<code>覆盖</code>虚表中基类的虚函数；</li><li>派生类自己新增加的虚函数按照在派生类中的声明次序增加到派生类虚表的最后。</li></ol><p>这样，派生类的虚表就包含了基类的虚函数和派生类自己的虚函数，构成了完整的虚函数表。</p><blockquote><p>虚表存的是<code>虚函数指针</code>，不是虚函数，虚函数和普通函数一样的，都是存在<code>代码段</code>的，只是他的指针又存到了虚表中。</p></blockquote><p>虚表和虚函数也是产生多态的基本条件。<br>满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到<code>对象</code>里去找的。不满足多态的函数调用时是<code>编译</code>时就确认好的。<br>也就是常说的静态绑定与动态绑定。静态绑定常见的就是函数重载，动态则是多态。</p><p>有兴趣的还可以自行研究下多继承里虚基表与虚函数的位置关系，还有复杂的菱形继承情况。在这里就不多赘述了，以后有机会再补一篇关于这方面的博客。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 友元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的内存管理</title>
      <link href="/2024/11/03/cpp-Memory%20management/"/>
      <url>/2024/11/03/cpp-Memory%20management/</url>
      
        <content type="html"><![CDATA[<h1 id="在c-c-内存如何分布"><a href="#在c-c-内存如何分布" class="headerlink" title="在c&#x2F;c++内存如何分布"></a>在c&#x2F;c++内存如何分布</h1><p>在一个程序的运行过程中，总是需要存储一些数据。这些数据可以粗略的被分为：</p><ol><li>常量数据</li><li>局部数据</li><li>静态数据与全局数据</li><li>动态申请数据</li></ol><p>在c&#x2F;c++中，内存可以分为四个区域：<code>栈区、堆区、静态区和常量区</code>。它们分别用于存储不同类型的数据，如下所示：</p><p>栈区：栈区是由编译器<code>自动分配和释放的内存区域</code>。它用于存储<code>局部变量、函数参数和函数返回地址</code>等。栈区是一个连续的内存块，它的大小是固定的。当程序执行离开一个函数时，栈中的内存就会被<code>自动释放</code>。为什么形参是实参的拷贝就与栈帧(栈帧也叫过程活动记录，是编译器用来实现过程&#x2F;函数调用的一种数据结构。每一次函数的调用，都会在调用栈（call stack）上维护一个独立的栈帧（stack frame）。)有关，二者是通过栈帧与寄存器的一些操作来实现数据传输的。并且建立栈帧的主要目的就是<code>存储局部的数据</code>。</p><p>堆区：堆区是由程序员手动分配和释放的内存区域。它用于存储<code>动态分配</code>的对象，如new操作符创建的对象。堆区是一个不连续的内存块，它的大小可以动态地调整。因此，堆区的内存容量比栈区大得多。程序员需要<code>手动释放</code>堆区中的内存，否则就会出现<code>内存泄漏</code>的问题。</p><p>静态区：静态区是用于存储<code>全局变量和静态变量</code>的内存区域。它在程序<code>启动时被分配，直到程序结束才被释放</code>。静态区也是一个连续的内存块，它的大小是固定的。</p><p>常量区：常量区是用于存储<code>常量数据</code>的内存区域。它包括字符串常量和其他类型的常量数据。常量区是一个不连续的内存块，它的大小固定不变。程序员<code>不能修改</code>常量区中的数据。</p><p>这些都是需要重点掌握的知识。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%86%85%E5%AD%981.png'><p>以一道题来巩固下知识：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> d=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> f[<span class="number">3</span>]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* g=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* p1=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别指出以上8个变量所存储的内存位置。<br>a：全局变量存储在静态区。<br>b：静态变量存储在静态区。<br>c：c也是存储在静态区。<br>d：d是一个局部变量只在main内可用，所以存储在栈区。<br>e：数组存储在栈区。<br>f：同上。<br>g：g是指向常量区的一个指针，但本身仍然存储在栈区内。<br>p1：p1是指向堆区的一个指针，但本身仍然存储在栈区内。<br>*p1： 对p1解引用，那么就是在堆区内。<br>*g1： 同理，解引用后在常量区。</p><h1 id="c-的动态内存分配"><a href="#c-的动态内存分配" class="headerlink" title="c++的动态内存分配"></a>c++的动态内存分配</h1><p>c语言里的内存分配函数如malloc，calloc等都可以在c++中使用，且可以满足大部分的功能，那为何c++要自行开发自己的动态内存管理方式呢？<br>在c中，内存管理主要是通过malloc和free函数进行的，这种方式对于简单程序来说非常有效。但是，在c++中，对象的构造和析构需要进行特殊的处理，而c中的内存管理方式无法满足这些要求。<br>因此，c++引入了new和delete运算符，这些运算符可以执行对象的构造和析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=<span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>上述的代码段就完成了动态申请一个int类型的空间。还可以扩展如下的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);  <span class="comment">//动态申请一个int空间且初始化为10。 </span></span><br><span class="line"><span class="type">int</span>* p2=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>];   <span class="comment">//动态申请4个int类型的空间。</span></span><br><span class="line"><span class="type">int</span>* p3=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//动态申请4个int类型空间其初始化为1,2,3,4</span></span><br></pre></td></tr></table></figure><p>不过在使用完后记得使用delete将其销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure><h1 id="malloc-free，new-delete有何异同？"><a href="#malloc-free，new-delete有何异同？" class="headerlink" title="malloc&#x2F;free，new&#x2F;delete有何异同？"></a>malloc&#x2F;free，new&#x2F;delete有何异同？</h1><p>相同点在于malloc与new都是从<code>堆上</code>去申请空间，且完成其使命后都要<code>手动销毁</code>，否则可能造成内存泄漏。<br>而不同点就比较多了。<br>第一，malloc无法完成初始化，这也是c++要使用新的内存管理方式的重要原因。<br>例如在写栈的函数时，使用malloc就只能完成申请空间的功能，而new可以在申请空间后<code>调用构造函数</code>对对象进行初始化。<br>第二，同上，free也只是完成空间的释放，而不会像delete一样会调用析构函数。<br>第三，new的<code>抛出异常机制</code>更适合在c++中使用，而malloc在空间申请失败时返回的是NULL。<br>第四，malloc与free是<code>函数</code>，而new和delete则是被定义为<code>操作符</code>。</p><p>既然讲到就简单谈谈<code>内存泄漏</code>。<br>内存泄漏，就是在应用程序分配某段内存后，因为某些失误，失去了对该段内存的控制，造成内存的浪费。如果内存不断的泄漏，那么由于其导致的响应速度会越来越慢，最终可能会造成崩溃。<br>也许有的人会有疑惑，为何自己在写动态分配内存时，有时候会忘记free或者delete，但好像也没什么事。这是因为现阶段我们写的代码都是在编译器上完成的，当程序停止，所有被用到的内存也都被释放了，包括我们失去控制的那段内存。但服务器就不一样了，例如游戏的服务器，是不能随意开关机的，那么如果有内存泄漏，势必会让服务器内存越来越慢，从而导致运行变慢，最终崩溃。</p><p>再说说new和delete，二者在底层的实现上都用到了malloc和free，只是除此之外调用了析构和构造而已。<br>new和delete是用户进行动态内存申请和释放的操作符，<code>operator new 和operator delete</code>是<br>系统提供的全局函数，new在<code>底层</code>调用operator new全局函数来申请空间，delete在<code>底层</code>通过<br>operator delete全局函数来释放空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间</span></span><br><span class="line"><span class="comment">失败，尝试执行空               间不足应对措施，如果改应对措施用户设置了，则继续申请，否</span></span><br><span class="line"><span class="comment">则抛异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try to allocate size bytes</span></span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line"><span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// report no memory</span></span><br><span class="line">         <span class="comment">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常</span></span><br><span class="line">         <span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">         _RAISE(nomem);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">operator delete: 该函数最终是通过free来释放空间的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *pUserData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     _CrtMemBlockHeader * pHead;</span><br><span class="line">     <span class="built_in">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class="number">0</span>));</span><br><span class="line">     <span class="keyword">if</span> (pUserData == <span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     _mlock(_HEAP_LOCK);  <span class="comment">/* block other threads */</span></span><br><span class="line">     __TRY</span><br><span class="line">         <span class="comment">/* get a pointer to memory block header */</span></span><br><span class="line">         pHead = <span class="built_in">pHdr</span>(pUserData);</span><br><span class="line">          <span class="comment">/* verify block type */</span></span><br><span class="line">         _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line">         _free_dbg( pUserData, pHead-&gt;nBlockUse );</span><br><span class="line">     __FINALLY</span><br><span class="line">         _munlock(_HEAP_LOCK);  <span class="comment">/* release other threads */</span></span><br><span class="line">     __END_TRY_FINALLY</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">free的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   free(p)               _free_dbg(p, _NORMAL_BLOCK)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上述两个全局函数的实现知道，operator new 实际也是通过malloc来申请空间，如果<br>malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete 最终是通过free来释放空间的。</p><p>new等于开空间加调用构造函数。<br>delete等于调用析构函数加释放空间。</p><p>例如我们new了一个stack类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span>&#123;</span><br><span class="line"> <span class="type">int</span>* arr;</span><br><span class="line"> <span class="type">int</span> capacity;</span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line">stack *p=<span class="keyword">new</span> stack;</span><br></pre></td></tr></table></figure><p>开空间就是在堆上为其开辟了指定的一块stack大小的空间。这点和malloc是一致的。而调用构造函数就是malloc无法办到的事情了，如果我们为stack类写了一个无参构造，那么此时申请完空间就会去调用无参构造，为stack类里的arr申请一块空间。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%86%85%E5%AD%983.png'><br>同样的，free也无法调用析构函数，并且delete里<code>析构执行顺序先于free</code>！<br>free能办到什么事呢？有这样一个有趣的比喻，你是一个需要水桶的人，管理水桶的我们暂且称为管家，malloc就是你对管家说：请给我xx个水桶，而free就是你对管家说：这xx个我用完了，还给你。而是否桶里的水有没有用完，管家也<code>不会去处理</code>。c语言程序中，在free后将指针<code>指向NULL</code>，也不过是提醒自己：这些水桶<code>不再属于我</code>了，我不能再往里面进行操作了。如果你free了还要执意使用水桶，别人拿去装饮料，你却往里面撒尿，这样做肯定会引起管家的不满啦！</p><p>总之free后你<code>仍然可以使用</code>这个指针，但操作系统认为这块内存已经还给了他，他会毫不犹豫的<code>分配给其他程序</code>，当你下一次在使用时就会有内容改变的风险！</p><p>所以free一个stack只是将arr，size，capacity从堆区中抹掉了，而arr指向的那块空间是free无法染指的，也就是桶里的水还在，这需要我们手动的去写析构函数才行。</p><h1 id="delete和delete"><a href="#delete和delete" class="headerlink" title="delete和delete[]"></a>delete和delete[]</h1><p>C++中，delete和delete[]都是用来释放动态分配的内存的关键字，但是它们的使用方式和释放的内存类型有所不同。<br>delete用于释放单个对象所占用的内存，即释放使用new关键字动态分配的单个对象的内存。当我们使用new来分配一个单个对象的内存时，需要使用delete来释放这个对象的内存。<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>delete[]用于释放数组对象所占用的内存，即释放使用new[]关键字动态分配的数组对象的内存。当我们使用new[]来分配一个数组对象的内存时，需要使用delete[]来释放这个数组对象的内存。<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><p>需要注意，如果我们使用delete来释放使用new[]关键字动态分配的数组对象的内存，或者使用delete[]来释放使用new关键字动态分配的单个对象的内存，都会导致未定义的行为，可能会出现内存泄漏或其他错误。因此，在使用动态内存分配时，需要根据对象类型选择合适的释放方式，以避免出现内存错误。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈初始化列表</title>
      <link href="/2024/11/03/cpp-initlist/"/>
      <url>/2024/11/03/cpp-initlist/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在之前的成员函数一文中谈到过构造函数，在创建对象时，编译器会调用构造函数，为成员变量进行赋值。但这个操作<code>并不是初始化</code>，初始化只能有<code>一次</code>，而在构造函数里面是可以进行多次赋值的。初始化的工作通常可以交由初始化列表来执行。</p></blockquote><h1 id="什么是初始化列表？"><a href="#什么是初始化列表？" class="headerlink" title="什么是初始化列表？"></a>什么是初始化列表？</h1><p>C++的<code>初始化列表</code>是一种在创建对象时<code>初始化成员变量</code>的特殊语法。它的存在可以显著的提高代码的可读性和性能。<br>在C++中，当我们创建一个对象时，我们需要为其成员变量<code>赋值</code>。通常情况下，我们会在构造函数中对成员变量赋值。但是，当对象中有大量成员变量时，这种方法可能会让代码变得冗长。<br>C++的初始化列表提供了一种更简洁、更清晰的方法来初始化成员变量。它使用<code>冒号分隔符</code>来定义一个初始化列表，并在其中列出成员变量及其初始值。<br>下面是一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> a;</span><br><span class="line">      <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>(<span class="type">int</span> a1,<span class="type">int</span> b1)</span><br><span class="line">        : <span class="built_in">a</span>(a1),<span class="built_in">b</span>(b1)</span><br><span class="line">      &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述的代码里，使用了初始化列表来为a与b赋值而没有经过构造函数体内。这就是初始化列表的基础用法。</p><p>使用初始化列表有一些需要注意的地方：</p><ol><li>成员变量在初始化列表里只可以有一次。</li><li>当类中包含<code>引用成员变量，const成员变量，自定义类型成员变量(该类没有默认构造函数时)</code>时，必须放在初始化列表里进行初始化。</li></ol><h1 id="初始化列表的使用"><a href="#初始化列表的使用" class="headerlink" title="初始化列表的使用"></a>初始化列表的使用</h1><p>在需要注意的第二点中我们提到了一旦包含上面的三个成员，就要放入初始化列表中进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">    : <span class="built_in">eternity</span>(a),<span class="built_in">reference</span>(b)</span><br><span class="line">    &#123;&#125; </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span>&amp; reference;</span><br><span class="line">     <span class="type">const</span> <span class="type">int</span> eternity;</span><br><span class="line">     B b1; <span class="comment">// B是另一个自定义类型，如果有默认构造函数，可不必放在初始化列表。</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果B类不存在默认构造函数，那么就需要在A的初始化列表中对b1进行一个显式的调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> x) : <span class="built_in">eternity</span>(a), <span class="built_in">reference</span>(b), <span class="built_in">b1</span>(x) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; reference;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> eternity;</span><br><span class="line">    B b1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在创建A对象时，编译器需要为其成员变量<code>分配内存并初始化</code>，如果B没有默认构造函数，那么编译器不知道<code>如何为b1分配内存</code>并初始化，从而产生编译错误。</p><p>并且请注意：成员变量在<code>类中的声明次序</code>就是其在初始化列表中的初始化顺序，而与其在初始化列表的顺序是<code>无关</code>的！</p><p>一个很经典的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">a1</span>(a),<span class="built_in">a2</span>(a1)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">      <span class="type">int</span> a2;</span><br><span class="line">      <span class="type">int</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在初始化列表中的顺序是a1，a2，但真正的执行顺序是a2，a1，也就是a2的初始化是一个随机值（因为此时a1就是随机的），在a2初始化完成之后a1才会被a赋值。</p><h1 id="为什么引用，const或者类变量必须在初始化列表中？"><a href="#为什么引用，const或者类变量必须在初始化列表中？" class="headerlink" title="为什么引用，const或者类变量必须在初始化列表中？"></a>为什么引用，const或者类变量必须在初始化列表中？</h1><p>const，引用类型或者类的成员变量必须要放在<code>初始化列表</code>里面，因为它们在创建对象时需要被初始化，而且只能在初始化时被赋值，不能在构造函数中再次被赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; reference;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> eternity;</span><br><span class="line">    B b1;       <span class="comment">//这里的都是声明！！！</span></span><br></pre></td></tr></table></figure><p>上面三个变量的特征就是<code>在定义时就必须被初始化</code>！</p><p>在C++中，对象的创建分为两个步骤：<code>分配内存和初始化</code>。在分配内存的过程中，编译器会为对象中的每一个成员变量分配内存空间；在初始化的过程中，编译器会调用构造函数来初始化每一个成员变量。对于const或者引用类型的成员变量，其值必须在初始化时被赋值，因此<code>必须在构造函数的初始化列表中进行初始化</code>，否则会导致编译错误。<br>另外，const或者引用类型的成员变量在对象的<code>整个生命周期中都不能被修改</code>，因此也不能在构造函数中再次被赋值。因此，将其放在初始化列表中进行初始化，可以确保它们的值只被赋值一次，并且在对象的整个生命周期中保持不变。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 对象 </tag>
            
            <tag> 类 </tag>
            
            <tag> 初始化列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>默认成员函数那些事儿</title>
      <link href="/2024/11/03/cpp-Member%20functions/"/>
      <url>/2024/11/03/cpp-Member%20functions/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在C++中，有许多<code>默认成员函数</code>，如默认构造函数、拷贝构造函数和析构函数等。这些默认成员函数在代码中扮演着重要的角色，它们可以帮助开发者快速<code>构建对象、复制对象和释放对象</code>。然而，这些默认成员函数的使用也有一些需要注意的细节和技巧。本文将详细介绍C++中的默认成员函数，包括其作用、使用方法、注意事项和实例说明等，旨在帮助读者深入了解和掌握这些重要的语言特性，从而写出更加高效可靠的代码。</p></blockquote><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>一个类没有成员，称为<code>空类</code>。但一个空类却并不为空。<br>编译器会在其中为开发者默认生成了两大类成员函数。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B01.png'></p><p>构造函数：当<code>创建</code>一个对象时，如果没有<code>显式地</code>提供构造函数，编译器会自动生成一个默认构造函数。默认构造函数的主要功能是<code>初始化成员变量</code>，使对象能够正确地工作。</p><p>析构函数：当一个对象<code>生命周期结束</code>时，如果没有<code>显式地</code>提供析构函数，编译器会自动生成一个默认的析构函数。析构函数的主要功能是<code>释放对象占用的资源</code>，如释放动态分配的内存等。</p><p>拷贝构造函数：当一个对象要被<code>复制</code>到另一个对象中时，如果没有<code>显式地</code>提供拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。拷贝构造函数的主要功能是将一个已有对象的值复制到新的对象中。</p><p>拷贝赋值运算符：当一个对象要被<code>赋值</code>给另一个对象时，如果没有<code>显式地</code>提供拷贝赋值运算符，编译器会自动生成一个默认的拷贝赋值运算符。拷贝赋值运算符的主要功能是将一个已有对象的值赋值给另一个对象。</p><blockquote><p>如果我们在类中显式地定义了这些成员函数，则编译器不会再生成默认版本。而且，如果我们定义了其中的某一个成员函数，则最好<code>也定义其它成员函数</code>，以保证它们能够协同工作，避免出现一些难以预料的问题。</p></blockquote><p><code>取地址重载</code>也可以算作默认成员函数的成员。主要是普通对象和const对象取地址，在文章后面也会提到。</p><p>创建一个class data，作为示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">data</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>再未了解构造函数前，我们想要对类中private修饰的成员变量赋值，需要写一个函数来访问它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date d1;</span><br><span class="line">d<span class="number">1.</span>_day = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这样的案例是错误的，编译器报错：<code>成员不可访问</code>。因为此时的_day成员被private所修饰，只能在类里对其进行访问。<br>使用private的好处是极多的。建议将类中的<code>成员变量</code>用<code>private</code>来修饰实现封装，是因为这样能够有效地<code>保护数据，防止外部的非法访问和修改</code>，从而提高程序的安全性和可靠性。<br>封装可以做到：</p><ol><li><p>隐藏实现细节：将成员变量封装在类的私有部分，可以隐藏实现细节，避免外部直接访问和修改，从而保证数据的<code>安全性和完整性</code>。</p></li><li><p>提高代码复用性：类的成员变量只有在<code>类的内部</code>才能访问，所以可以在类的内部定义一些公共的成员函数，通过这些函数来访问和修改成员变量，从而实现代码的复用。</p></li><li><p>方便代码维护：成员变量只能通过类的公共接口来访问，所以如果需要修改成员变量或者添加新的成员变量，只需要<code>修改类的公共接口</code>，而不需要修改外部的代码。</p></li></ol><p>那么此时我们可能会采取写一个init函数来对成员变量进行初始化。这也正是<code>构造函数</code>的职能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">_day = day;</span><br><span class="line">_month = month;</span><br><span class="line">_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数并不是如他的名字——去创建一个对象，而是参与了<code>对象中成员变量的初始化</code>。</p><blockquote><p>构造函数是一个特殊的函数，<code>名字与类名是相同</code>的，在创建对象时就由编译器<code>直接调用</code>，且在对象整个生命周期内<code>只调用一次</code>。</p></blockquote><p>构造函数有这样的几个特点：</p><ol><li>函数名与类名是<code>相同</code>的。比如date类的构造函数就叫date。</li><li>构造函数是<code>没有返回值</code>的。</li><li>当对象进行实例化时，编译器会<code>自动</code>调用此函数。</li><li>构造函数是可以进行重载的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">date</span>(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year) &#123;</span><br><span class="line">_day = day;</span><br><span class="line">_month = month;</span><br><span class="line">_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，这样就实现了两个构造函数——一个<code>有参构造</code>，一个<code>无参构造</code>。因为其支持重载，所以这样设置是没问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">date <span class="title">d1</span><span class="params">(<span class="number">12</span>,<span class="number">1</span>,<span class="number">2012</span>)</span></span>;  <span class="comment">//调用有参构造</span></span><br><span class="line">date d2;  <span class="comment">//调用无参构造,注意不能写成date d2()</span></span><br></pre></td></tr></table></figure><blockquote><p>当用户未进行显示定义时，编译器会<code>自动</code>生成一个<code>无参</code>构造函数。但一旦用户定义了，编译器就不会生成了。</p></blockquote><p>在c++中，类型可以被分为两种：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B02.png'></p><p>像int，double这样的类型就是内置类型，也被称作基本类型。<br>而像上面定义的date类，就被叫做自定义类型。</p><p>编译器在调用无参构造时，内置类型可能是随机值，也可能是0这样的值，这点<code>取决于编译器</code>。而自定义类型就一定会调用该类自己的<code>默认成员函数</code>。<br>我们又创建了一个类——student，并将其放在date类中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">student</span>() &#123;</span><br><span class="line">age = <span class="number">10</span>;</span><br><span class="line">name = <span class="string">&quot;chengzi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">_day = day;</span><br><span class="line">_month = month;</span><br><span class="line">_year = year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//date() &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//date(int day, int month, int year) &#123;</span></span><br><span class="line"><span class="comment">//_day = day;</span></span><br><span class="line"><span class="comment">//_month = month;</span></span><br><span class="line"><span class="comment">//_year = year;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line">student stu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行截图如下（vs2022）：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B03.png'><br>可以看到，虽然date的几个基本类型是随机值，但stu里带的成员变量因为<code>调用了自身的默认构造</code>，所以不是随机值。注意，调用的<code>必须</code>是默认构造也就是无参的哦。</p><p>在c++11中规定： 内置类型可以在类中声明时给出默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       <span class="type">int</span> _day=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _month=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _year=<span class="number">1</span>;</span><br><span class="line">student stu;</span><br></pre></td></tr></table></figure><p>运行截图：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B04.png'></p><p><code>无参构造</code>和<code>全缺省</code>都被称为默认构造，但两者只能存在一个，否则编译器不知道调用哪一个。</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>析构函数负责对象的<code>销毁</code>。<br>但析构函数不是对对象本身进行销毁，而是在编译器<code>出手销毁</code>时，作为一个强有力的工具，来帮助完成<code>对象资源</code>的清理。<br>析构函数的特征:</p><ol><li>析构函数的名就是在<code>类名</code>前加上一个<code>~</code>即可。</li><li>同样的，析构函数没有返回值。</li><li>析构函数是<code>不支持重载</code>的。</li><li>在对象生命周期结束时，由编译器亲自调用析构函数。</li></ol><p>析构函数适用于哪些情景呢？</p><ol><li>动态分配内存：当我们使用动态分配内存时，需要使用析构函数来释放这些动态分配的内存，防止<code>内存泄漏</code>。</li><li>对象销毁前的清理工作：当我们需要在对象销毁前进行一些清理工作时，可以使用析构函数来实现。例如，我们可以在析构函数中关闭对象的一些状态，保存对象的一些状态等等。</li></ol><p>所以当类中没有申请资源时，就不用写析构函数了，例如上面date类或者student类。而一旦类中进行了动态内存分配，我们就必须得自己写一个析构函数。<br>例如我们创建了一个类——stack。就必须要手动进行释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stack</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * capacity);</span><br><span class="line">currentsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">stack</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (arr) &#123;</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line">arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* arr;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line"><span class="type">int</span> currentsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，默认的析构函数会调用自定义成员变量默认的析构函数（如果类中存在自定义成员变量的话）。</p><ul><li>构造顺序是按照语句的顺序进行构造，析构是按照构造的<code>相反顺序</code>进行析构。</li></ul><p>题1.函数F中，本地变量a和b的构造函数(constructor)和析构函数(destructor)的调用顺序是: ( )</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class A;</span><br><span class="line"></span><br><span class="line">Class B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">    B b;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>答案是a构造 b构造 b析构 a析构。</p><p>题2.设已经有A,B,C,D4个类的定义，程序中A,B,C,D析构函数调用顺序为？（ ）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> D d;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>类的析构函数调用一般按照构造函数调用的相反顺序进行调用，但是要注意static对象的存在，因为static改变了对象的生存作用域，需要等待程序结束时才会析构释放对象。</p></li><li><p><code>全局</code>对象先于<code>局部</code>对象进行构造。</p></li><li><p>局部对象按照出现的顺序进行构造，无论是否为static。</p></li><li><p>所以构造的顺序为C A B D。</p></li><li><p>析构的顺序按照构造的相反顺序析构，只需注意<code>static改变对象的生存作用域</code>之后，会放在<code>局部对象之后</code>进行析构。</p></li><li><p>因此析构顺序为B A D C。</p></li></ol><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>拷贝构造适用于创建一个与<code>原对象一模一样</code>的新对象。<br>且拷贝构造是一个构造函数的<code>重载</code>，且只有<code>单个形参</code>。<br>形参必须为<code>类类型对象的引用</code>，如果使用的是传值，那么编译器会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span>(<span class="type">const</span> date&amp; d) &#123;</span><br><span class="line">_day = d._day;</span><br><span class="line">_month = d._month;</span><br><span class="line">_year = d._year;</span><br><span class="line">stu = d.stu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果传递的是const date d，那么会引起<code>无限制的调用</code>。</p></blockquote><p>因为c++规定，在函数里调用自定义类型，必须要调用其<code>拷贝构造</code>来完成。因为传值通常就意味着拷贝，这点还是很好去理解的。只不过相较于内置类型的直接拷贝，自定义类型的传值拷贝稍微要麻烦一点点。</p><p>如果是传值，不就陷入了一个无穷的递归之中了吗？传值就要拷贝，拷贝就要调用拷贝构造，这不是没完没了了？<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B05.png"></p><p>当用户未在类中设置显式定义，编译器会生成默认的拷贝构造函数。此函数可以按照字节序进行拷贝（也被称为浅拷贝）。<br>所以如果还是使用date或者student类，仍然没有必要去写一个拷贝构造函数。那换成上面的<code>stack</code>类呢？<br>答案是<code>不行</code>。<br>因为在stack类里我们定义了一个arr作为栈的<code>基址</code>。当使用浅拷贝的时候，拷贝过去的仍然是这个基址。<br>当程序准备退出时，stack1和stack2都要调用析构函数进行销毁，无论哪个对象先调用析构进行销毁，等到下一个对象要销毁时，发现arr那块空间的支配权已经还给了系统了，同时<code>多次的内存空间释放必然会造成程序崩溃</code>。<br><img src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B06.png"><br>所以我们需要自行写一个拷贝构造函数。也就是深拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack&amp; stack1) &#123;</span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * stack<span class="number">1.</span>capacity);</span><br><span class="line"><span class="built_in">memcpy</span>(arr, stack<span class="number">1.</span>arr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * stack<span class="number">1.</span>currentsize);</span><br><span class="line">capacity = stack<span class="number">1.</span>capacity;</span><br><span class="line">currentsize = stack<span class="number">1.</span>currentsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造的使用方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stack <span class="title">s2</span><span class="params">(s1)</span></span>;   <span class="comment">//s2为要拷贝的目标，s1为拷贝的原本</span></span><br></pre></td></tr></table></figure><p>总结一下构造函数的适用场景：</p><ol><li>如上所示的stack s2(s1)，利用一个<code>已存在的对象来创建新对象</code>。</li><li>函数中有<code>参数</code>为类类型的对象。如add(date d1)这个函数，调用了d1这个对象，那么在传参的过程中必然会使用到拷贝构造。</li><li>函数<code>返回值</code>有类类型对象也是同样道理。</li></ol><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>运算符重载的引入是为了增强c++的代码可读性。其函数名为：<code> operator接需要重载的运算符号</code>。<br>并且在重载运算符中必须含有<code>至少一个类类型</code>的参数。</p><p>比如重载一个判断两日期是否相等的&#x3D;&#x3D;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> date&amp; d1) &#123;</span><br><span class="line"><span class="keyword">return</span> d<span class="number">1.</span>_year == _year &amp;&amp; d<span class="number">1.</span>_month == _month &amp;&amp; d<span class="number">1.</span>_day == _day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意： <code>::</code> ,<code>sizeof</code>,<code>?:</code>,<code> .</code>,<code> .*</code>不可被重载！</p><h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>赋值运算符重载是运算符重载的一种特例，它主要用于实现自定义类型的<code>深拷贝</code>。这个我们后面再说。<br>既然是赋值运算符重载，那么必然和普通的运算符重载有些许的区别，最明显的地方就在于<code>返回值</code>。<br>赋值运算符的返回值类型应该是一个<code>引用</code>，其目的是<code>支持连续赋值</code>。比如a&#x3D;b&#x3D;c，如果仍然按照上面的bool型返回，a&#x3D;b判断后返回一个true或者false，那又该如何去判断c呢？为了实现连续判断肯定会返回一个类对象的引用。<br>参数类型也常用引用，目的是为了<code>提高效率</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date&amp; <span class="keyword">operator</span>=(<span class="type">const</span> date&amp; d1) &#123;</span><br><span class="line">_year = d<span class="number">1.</span>_year;</span><br><span class="line">_day = d<span class="number">1.</span>_day;</span><br><span class="line">_month = d<span class="number">1.</span>_month;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，*this的用法是需要重点理解的。<br>在C++中，return *this是一个<code>返回当前对象引用</code>的语句，常用于<code>实现链式调用</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Class&amp; <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Class&amp; <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的示例中，func1()和func2()都返回MyClass类型的对象引用，因此可以在它们之间进行链式调用，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class obj;</span><br><span class="line">obj.<span class="built_in">func1</span>().<span class="built_in">func2</span>();</span><br></pre></td></tr></table></figure><p>这样的代码能够更加简洁和易读。同时，使用return *this也可以避免出现<code>多余的对象拷贝</code>操作，提高代码的效率。*this代表着返回当前对象，return *this与date &amp;作为返回值，则代表返回引用，引用就不必经过许多繁琐的拷贝工作，也就提高了效率。</p><p>c++也规定：<code> 赋值运算重载只能是类的成员函数</code>！<br>其中比较重要的一点原因：赋值运算符是<code>作用于对象</code>上的，而对象是类的实例，因此赋值运算符必须能够访问类的私有成员，只有<code>类的成员函数才能够访问类的私有成员</code>，因此赋值运算符重载只能作为类的成员函数来定义。除此之外，赋值运算符重载还需要<code>返回一个对象的引用</code>，这个引用指向赋值后的对象。如果赋值运算符重载作为全局函数或友元函数来定义，则无法访问对象的私有成员，并且无法返回对象的引用，因此无法实现赋值运算符的重载。</p><p>当用户未显式实现时，编译器也会自动生成一个<code>默认</code>的赋值运算符重载，以值的方式<code>逐字节</code>拷贝。<br>那么如果还是date这种类，直接使用默认的即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assignment</span><span class="params">(date&amp; d1)</span> </span>&#123;</span><br><span class="line">(*<span class="keyword">this</span>) = d1;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">date <span class="title">d1</span><span class="params">(<span class="number">22</span>,<span class="number">22</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">date d2;</span><br><span class="line">d<span class="number">2.</span><span class="built_in">assignment</span>(d1);</span><br></pre></td></tr></table></figure><p>编译结果：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B07.png'></p><p>但要是stack这样的类就不行了。s2&#x3D;s1，将s1的内容拷贝给s2，那么s2和s1指向同一片空间不说，s2赋值后还会丢失原本的空间，导致内存泄漏，最终释放两次相同的空间也一定会造成程序崩溃。所以stack这样的类需要的是<code>深拷贝</code>。</p><blockquote><p>请牢记，只要涉及到资源管理，那么一定需要重写赋值运算符。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符重载，实现深拷贝  </span></span><br><span class="line">    stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack&amp; other) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;  </span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 处理自赋值  </span></span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 分配新资源并复制数据  </span></span><br><span class="line">        capacity = other.capacity;  </span><br><span class="line">        currentsize = other.currentsize;  </span><br><span class="line">        arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * capacity);  </span><br><span class="line">        std::<span class="built_in">memcpy</span>(arr, other.arr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * currentsize);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="一些运算符重载示例"><a href="#一些运算符重载示例" class="headerlink" title="一些运算符重载示例"></a>一些运算符重载示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_year &lt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month &lt; x._month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _day &lt; x._day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _year == x._year</span><br><span class="line">&amp;&amp; _month == x._month</span><br><span class="line">&amp;&amp; _day == x._day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> &lt; x || *<span class="keyword">this</span> == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> date &amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == x);</span><br><span class="line">&#125;</span><br><span class="line">date <span class="keyword">operator</span>+(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">tmp += day;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前置++</span></span><br><span class="line">date&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置++</span></span><br><span class="line"><span class="comment">// 增加这个int参数不是为了接收具体的值，仅仅是占位，跟前置++构成重载</span></span><br><span class="line">date <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">date tmp = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于开头提到的取地址与取地址操作符重载 ,基本不会在日常生活中使用，想要了解的可以自行谷歌。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 对象 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体对齐与大小端</title>
      <link href="/2024/11/03/cpp-Structure%20alignment/"/>
      <url>/2024/11/03/cpp-Structure%20alignment/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h1><p>什么叫结构体对齐？</p><blockquote><p>结构体对齐是内存对齐的一种应用，主要是为了使结构体中的各个成员在内存中按照一定的规则排列，以符合CPU对数据访问的要求。某些CPU对于访问内存中的数据要求必须按照一定的边界对齐。没有对齐可能导致CPU<code>多次读取内存</code>，从而降低性能。内存对齐也可以简化编译器的设计，不用处理没有对齐的复杂情况。</p></blockquote><ul><li>结构体对齐基础规则</li></ul><ol><li>第一个成员在结构体变量偏移量为<code>0</code>的地址处</li><li>其他成员变量要对齐到<code>对齐数</code>的<code>整数倍</code>的地址处</li><li>对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的<code>较小值</code>。(VS中默认的值为8、Linux环境默认不设对齐数（对齐数是结构体成员自身的大小）)</li><li>结构体总大小为<code>最大对齐数</code>（每个成员变量都有一个对齐数）的<code>整数</code>倍</li></ol><p>看着文字可能有点懵，上个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;      <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">int</span> b;       <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="type">short</span> c;     <span class="comment">// 2 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>a在地址0x00，占用1字节<br>为了保证b能够aligned到4字节边界(b的对齐数是4，存放地址应该是4的整数倍处)，编译器会在a和b之间添加3个填充字节<br>b在地址0x04，占用4字节<br>c(同理，c的对齐数是2，存放在2的整数倍处即可)在地址0x08，占用2字节<br>为了保证整个结构体 Example 的大小能够被最大成员（4 字节）对齐，编译器可能在末尾添加 2 个填充字节，使得结构体的大小为 12 字节</p></blockquote><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF1.png'><blockquote><p>拓展1：内存体嵌套问题</p></blockquote><p>规则： 嵌套的结构体对齐到<code>自己的最大对齐数</code>的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">double</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">s1</span>;</span></span><br><span class="line"><span class="type">double</span> e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体S1的大小为16，算错的再看看上面的例子重新算一算。S1被嵌套在S2里，那么来看看S2的内存分配情况。</p><p>char型占1字节，直接从0开始算。 S1的对齐位置应该是其最大对齐数，也就是8。整体如下：</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF2.png'><blockquote><p>拓展2：如何让结构体按照指定的对齐参数进行对齐?</p></blockquote><ol><li>使用 #pragma pack（C和C++）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)  <span class="comment">// 将当前对齐方式设置为1字节对齐，并保存之前的对齐方式  </span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PackedStruct</span> &#123;  </span><br><span class="line">    <span class="type">char</span> a;  </span><br><span class="line">    <span class="type">int</span> b;  </span><br><span class="line">    <span class="type">short</span> c;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)  <span class="comment">// 恢复之前的对齐方式  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of PackedStruct: %zu\n&quot;</span>, <span class="built_in">sizeof</span>(PackedStruct));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 _<em>attribute_</em>((aligned(N)))（GCC编译器）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AlignedStruct</span> &#123;  </span><br><span class="line">    <span class="type">char</span> a;  </span><br><span class="line">    <span class="type">int</span> b;  </span><br><span class="line">    <span class="type">short</span> c;  </span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">16</span>)));  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of AlignedStruct: %zu\n&quot;</span>, <span class="built_in">sizeof</span>(AlignedStruct));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alignment of AlignedStruct: %zu\n&quot;</span>, __alignof__(AlignedStruct));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>为何要采取对齐内存的策略？</li></ul><p>如果没有内存对齐机制，就意味着数据可以存放在任意的位置，若一个int变量存放在从地址2开始的四个连续的字节地址中，当cpu取数据时，就要先从0地址开始读取第一个4字节块,再剔除掉不需要的字节地址0和1,然后从地址4开始再读取下一个4字节块,也剔除不要的数据地址6和7,最后留下的两块数据再合并放入寄存器。这样就导致读内存次数增多，也就导致了工作效率的下降。同时，有些硬件平台并不支持随意地址存取，这可能会导致抛出硬件异常。</p><h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><blockquote><p>大小端指的是多字节数据在内存中存储时，字节的<code>排列顺序</code>。具体来说，大端（Big-endian）模式将数据的最高有效字节（MSB）存储在最低的内存地址处，而最低有效字节（LSB）存储在最高的内存地址处。相反，小端（Little-endian）模式则将数据的最低有效字节存储在最低的内存地址处，最高有效字节存储在最高的内存地址处。</p></blockquote><p>这么说肯定不太直观，结合个例子看看：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF3.jpg'></p><p>小端存C1C2,先将C2(低位)存在地址的低位，大端则相反，C2存放在地址的高位。</p><ul><li>如何知道你的计算机是大端还是小端存储呢？</li></ul><blockquote><p>联合体（union）是一种特殊的数据结构，它允许在相同的内存位置以不同的类型来存储数据。联合体的所有成员共享同一块内存空间，这意味着它们在内存中的起始地址是相同的。</p></blockquote><p>定义一个联合体（union），该联合体包含至少两个不同类型的成员：一个整型（如int）和一个字符型（如char）。由于联合体成员共享同一块内存空间，因此可以通过<code>修改一个成员的值来观察另一个成员的变化</code>。<br>将整型成员的值设置为一个已知的、具有特定字节模式的值（如0x01020304）。<br>检查字符型成员的值。如果字符型成员的值是0x04（即整型值的最低字节），则机器是小端模式；如果字符型成员的值是0x01（即整型值的最高字节），则机器是大端模式。</p><p>在大端（Big-endian）模式下，最高有效字节（0x01）存储在最低的内存地址处，最低有效字节（0x04）存储在最高的内存地址处。<br>在小端（Little-endian）模式下，最低有效字节（0x04）存储在最低的内存地址处，最高有效字节（0x01）存储在最高的内存地址处。<br>由于字符型成员只占用一个字节，并且它与整型成员共享同一块内存，因此字符型成员将“看到”整型成员在<code>最低内存地址</code>处的那个字节的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">check_endianness</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>  </span><br><span class="line">        <span class="type">int</span> i;  </span><br><span class="line">        <span class="type">char</span> c;  </span><br><span class="line">    &#125; test_union;  </span><br><span class="line">  </span><br><span class="line">    test_union.i = <span class="number">0x01020304</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (test_union.c == <span class="number">0x04</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Little-endian  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// Big-endian  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> result = check_endianness();  </span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This machine is Little-endian.\n&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This machine is Big-endian.\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大小端使用场景</li></ul><p>大端在我学习计算机网络时有涉及过，网络上传输的数据普遍采用大端模式（即网络字节序）。小端模式的设备在需要进行网络通信时，可以通过软件层面的转换来适应大端模式的数据格式。<br>然而在计算机里，还是小端用的要多一些。比较浅显的理由有这么两条：</p><ol><li>小端模式下，内存的<code>低地址</code>处存放的是数据的<code>低字节</code>。这种存储方式使得在强制转换数据类型时，不需要调整字节的内容。例如，将int类型的4字节数据强制转换为short类型的2字节数据时，可以<code>直接取int数据的前两个字节</code>（即低地址处的两个字节），因为它们刚好就是short类型所需要的最低两个字节。此外，CPU在做数值运算时，通常是从内存中依次<code>从低位到高位取数据</code>进行运算，直到最后刷新最高位的符号位。小端模式符合这种运算方式，因此可以提高运算效率。</li><li>在早期的计算机系统中，存储器的价格昂贵，且加法器的设计相对复杂。小端模式可以简化加法器的设计，因为只需要一个较低位数的加法器，然后依次从低到高循环加上所有字节即可，进位的电路相对简单。</li><li>小端模式在<code>数据扩展</code>时更加方便。例如，将16位整数扩展为32位整数时，只需在高地址处添0即可，而<code>无需移动数据</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 内存对齐 </tag>
            
            <tag> 大小端 </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之引用</title>
      <link href="/2024/11/03/cpp-reference/"/>
      <url>/2024/11/03/cpp-reference/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言： 最近学到了c++中的引用，发现引用和c中所学到的指针有着很相似的效果，但在c++中仍然有着指针的一席之地，想必二者的适用场景是各有千秋，于是查阅资料，写了此文来方便日后复习。</p></blockquote><h1 id="引用的基本知识"><a href="#引用的基本知识" class="headerlink" title="引用的基本知识"></a>引用的基本知识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>引用是C++中的一种<code>数据类型</code>，它是一种类似于指针的变量。引用可以被认为是一个变量的<code>别名</code>(比如你名字叫大明，外号叫小明，别人喊小明你肯定就知道是在叫你)，它提供了一种<code>访问变量</code>的方式，使得程序员可以通过<code>不同的名称来操作同一个变量</code>(喊大明小明都是在叫你)，从而简化了代码的编写。<br>引用的语法非常简单，可以通过在变量名前面加上“&amp;”符号来定义一个引用。例如，如果我们定义了一个整型变量a，可以通过以下语句来定义一个引用b：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure><p>这样，变量b就成为了变量a的别名，它们<code>指向同一个内存地址</code>(这点非常重要)。因此，对变量b的操作也会影响到变量a。</p><h2 id="引用的适用场景"><a href="#引用的适用场景" class="headerlink" title="引用的适用场景"></a>引用的适用场景</h2><ol><li>引用必须在定义时进行<code>初始化</code>。一旦引用被初始化，它将一直指向该变量，并不能再被改变。</li><li>引用可以作为<code>函数参数</code>传递。通过引用传递参数可以避免复制大量的数据，提高程序的效率。</li><li>引用可以作为函数的<code>返回值</code>。通过引用返回值可以避免复制大量的数据，提高程序的效率。</li><li>引用可以被用来操作数组，但它的使用有一些限制。<br>这几点我会在后面进行一个详细的解释。</li></ol><h1 id="正餐"><a href="#正餐" class="headerlink" title="正餐"></a>正餐</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>人可以有多个外号，同样，一个变量也可以有多个引用。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%BC%95%E7%94%A8-1.png'></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="type">int</span>&amp; c = a;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>得到的结果是10 10 20。说明了改变b与c可以影响a，且b与c指向的是<code>同一块</code>内存空间。<br>但一个引用就只可以引用一个实体。如果出现了一个<code>引用</code>引用多个实体的情况，编译器是不会放行的。<br>引用在定义时就必须<code>进行初始化</code>，这是不同于指针的一点。</p><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b=a;</span><br></pre></td></tr></table></figure><p>这样的例子是典型的错误。编译器给出了报错原因：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%BC%95%E7%94%A8-2.png'></p><blockquote><p>在这段代码中，常量a被定义为const int类型，它的值<code>不能被修改</code>。同时，变量b被定义为int类型的引用，它指向了a的内存地址。由于a是一个常量，它的值不能被修改，因此<code>对b的任何修改都会影响到a的值</code>，这与const int类型的a所表示的<code>语义不符</code>。因此，编译器会报错，提示“invalid initialization of reference of type ‘int&amp;’ from expression of type ‘const int’”。<br>常引用在c++里通常被用作函数参数，函数返回值或者成员变量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的a是一个常引用，此时在函数里对a的<code>任何修改</code>都是<code>非法</code>的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">getLonger</span><span class="params">(<span class="type">const</span> string&amp; str1, <span class="type">const</span> string&amp; str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str<span class="number">1.l</span>ength() &gt; str<span class="number">2.l</span>ength() ? str1 : str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数的功能是返回较长的一个字符串，常引用作为返回值确保了字符串在返回时<code>不会被修改</code>。此外，在作类成员变量，或者遍历容器时也会有常引用的身影。</p><blockquote><p>即当既要使用引用提高程序的效率(下面讲)，又不能在函数内部修改实参的值时，可使用常引用。</p></blockquote><h2 id="引用的适用场景-1"><a href="#引用的适用场景-1" class="headerlink" title="引用的适用场景"></a>引用的适用场景</h2><h3 id="做参数"><a href="#做参数" class="headerlink" title="做参数"></a>做参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; nums1, <span class="type">int</span>&amp; nums2)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; nums1 + nums2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个引用做参数的典型例子，其不仅在写法上更简洁，效率也是更高的。</p><ol><li>减少了数据的<code>拷贝</code><br>当使用<code>传值</code>方式时，函数会将参数的值复制一份给形参，如果参数<code>较大</code>，则会消耗较多的时间和空间。而使用引用做参数时，函数只需要<code>传入参数的地址</code>，不需要复制数据，因此可以减少数据的拷贝，提高程序的效率。</li><li>减少了内存的占用<br>当使用传值方式时，每次调用函数都需要为形参<code>分配内存空间</code>，当调用次数较多时，会占用较多的内存空间。而使用引用做参数时，只需要传递一个地址，不需要分配额外的内存空间，因此可以减少内存的占用，提高程序的效率。</li></ol><h3 id="做返回值"><a href="#做返回值" class="headerlink" title="做返回值"></a>做返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> nums1,<span class="type">int</span> nums2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums1+nums2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="built_in">add</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>传值返回</code>的传统写法，在返回时会创建一个<code>临时变量</code>，哪怕函数的栈帧已经被销毁，main里面接受的值也是从临时变量得来的，所以这种传递方式是安全的。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%BC%95%E7%94%A81.png'><br>但如果返回的是一个引用，那么情况就会出现变数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; nums1, <span class="type">int</span>&amp; nums2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = nums1 + nums2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时int c&#x3D;add(a, b)中的c是不确定的，可能得到正确的答案，那是因为add函数栈帧还没清理，如果栈帧被清理，得到的就是个随机值了。<br>同样的，如果将接受的变量换做一个<code>引用</code>，会变得更加的不可控。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; c=<span class="built_in">add</span>(a, b);</span><br><span class="line"> cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;aaa\n&quot;</span>);</span><br><span class="line"> cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>我的编译器给出的结果：</p><blockquote><p>30<br>aaa<br>-858993460</p></blockquote><p>可见在随意的调用另一个函数后，c的值发生了变化。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%BC%95%E7%94%A82.png'></p><p>此时，c是指向sum的，当add函数调用完成后<code>栈帧就被销毁</code>，但此时我的编译器仍然没有清理它，销毁意味着系统将add所用的栈帧空间<code>回收</code>，但回收并不意味着数据也随之抹去，比如你今天在A201上课，放学后你离开了A201，意味着你将教室归还，当你朋友第二天来<code>A201</code>上课时，教室是存在的,只是<code>使用者被换了</code>。<br>所以这里当add调用完成后，空间还给了操作系统，操作系统又把这块空间给了printf函数来使用，自然第二次输出c就会是乱码了。因为c始终都<code>指向</code>这个位置，但<code>谁来用</code>这个位置是不确定的。</p><p>那么可以做如下的总结：</p><ol><li>几乎在任何的场景下使用<code>引用传参</code>都是可以的。</li><li>但<code>引用返回</code>是需要谨慎使用的。一不留神就使用到了错误的空间。</li><li>函数返回时，出了函数作用域，如果返回对象还<code>未归还</code>给系统，则可以使用引用返回，但如果已经将其归还给了系统，那么最好用传值返回。</li></ol><h1 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h1><p>看到这里，你会发现指针似乎和引用没有很大的区别，确实，就我现阶段的学习来看，二者的差别并不是很大。<br>以下是我总结的一些差别和相同的地方。<br>区别：</p><ol><li>指针可以被<code>重新赋值</code>，而引用不行。(引用在初始化后不能改变所指向的对象)</li><li>指针可以为<code>空</code>，而引用不行。</li><li>指针可以进行指针运算，而引用不行。</li><li>指针可以<code>指向空地址</code>，而引用必须指向已存在的对象。</li><li>指针可以指向同一类型的不同对象，而引用只能指向同一类型的同一对象。</li><li>引用必须在<code>定义时</code>初始化，而指针可以在任何时候进行初始化。</li><li>指针有<code>多级</code>的说法，但引用没有。</li><li>指针需要<code>解引用</code>才可以访问存储的地址，引用不用。<br>相同：</li><li>指针和引用都是用来间接访问程序中的变量。</li><li>指针和引用都可以作为函数的参数和返回值。</li></ol><p>指针和引用都可以提高程序的运行效率，因为它们避免了不必要的变量拷贝。<br>指针和引用都是C++中的两种重要的数据类型，它们在某些方面有相同之处，但也有很多区别。在使用时，需要根据具体的情况来选择使用哪种类型。例如，如果需要动态分配内存或者需要进行指针运算，则必须使用指针；而如果不需要修改变量的值，则可以使用引用，避免了指针的复杂性。</p><p>还有一点很有意思，在语法的概念上，引用就是取一个别名，是<code>没有独立的空间</code>的。但在其底层实现上实际是存在空间的，这是因为<code>引用是按照指针的形式来实现的</code>。这一点可以在反汇编代码进行查证。<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/c++%E5%BC%95%E7%94%A83.png'></p><p>可以看到反汇编代码几乎是一致的。但要深究其原理就等到以后再填坑啦。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++如何实现函数重载?</title>
      <link href="/2024/10/26/cpp-Function%20overloading/"/>
      <url>/2024/10/26/cpp-Function%20overloading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在c++中，有一种用法，名叫<code>函数重载</code>，函数重载是c++中一个非常重要的特性，它允许程序员定义<code>同名</code>但<code>参数列表不同</code>的函数，这样可以方便地实现代码复用和提高程序的可读性。但是在学习过程中令我感到奇怪的是，C却并不支持这一做法。于是通过查阅资料，完成了此篇博客。</p></blockquote><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数重载指的是在同一个作用域内，可以定义多个同名但参数列表不同的函数。例如：<br>如下是两个同名的add函数，功能是将两数相加并返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是add，但是它们的<code>参数列表不同</code>，一个是两个整数，一个是两个浮点数。当调用add函数时，编译器会根据实参的类型和数量来选择调用哪一个函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">// 调用int add(int, int)</span></span><br><span class="line"><span class="type">double</span> y = <span class="built_in">add</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);  <span class="comment">// 调用double add(double, double)</span></span><br></pre></td></tr></table></figure><p>这就是函数重载。函数重载的好处在于，可以让程序员使用同一个名字来表示多个不同的操作，这样做最浅显的好处就是给代码带来了美观。</p><p>函数重载一共有以下几种：</p><blockquote><p>参数数量不同</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数类型不同</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数顺序不同</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用引用或指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *a)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>常量参数与非常量参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>不同的返回类型（仅限于与参数数量和类型不同的情况）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>重点来啦：单纯通过返回类型的不同而构成重载是不可行的，必须还有<code>参数上的区别</code>。因为这样做编译器搞不明白你究竟想要使用的是哪个函数。<br>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>编译器到底该调哪一个呢？</p><h1 id="c-如何支持函数重载"><a href="#c-如何支持函数重载" class="headerlink" title="c++如何支持函数重载"></a>c++如何支持函数重载</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在c&#x2F;c++中，要想将一个程序跑起来，就需要经过如下的几个阶段 </p><blockquote><p>预处理，编译，汇编，链接<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD1.jpg'><br>图源王道2025操作系统讲义3.1</p></blockquote><p><code>预处理</code>是C++程序在编译过程中的第一步，它主要负责处理头文件、宏定义和条件编译等。在预处理阶段，预处理器会对<code>函数的声明</code>进行处理，通常，此文件是以<code>.i</code>为后缀。</p><p>编译器在<code>编译</code>阶段主要负责将源代码翻译成<code>汇编</code>代码。编译器通过分析源代码，将其转换为计算机可以理解的指令。汇编语言程序中的每条语句都以一种标准的文本格式确切的描述了一条低级机器语言指令。此时，文件后缀为<code>.s</code>。</p><p>在<code>汇编</code>阶段，编译器会将<code>汇编</code>代码翻译成<code>机器</code>代码。汇编器将<code>.s文件</code>翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件<code>.o</code>中。<code>.o</code>文件是一个二进制文件，它的字节编码是机器语言指令而不是字符，如果我们在文本文件中打开<code>.o文件</code>，所呈现的就是一串串的乱码。在汇编阶段，会生成一份<code>符号表</code>（这个表很重要,每个目标文件都有一份符号表，可简单理解为函数或变量对应的实际内存地址）。</p><p>在<code>链接</code>阶段，编译器会将多个目标文件链接成一个可执行文件。</p><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/52ca90eb6e87f4b12c4dc7a7a4a2681.jpg'>图源《计算机系统基础》-袁春风(此图在软件层并未涉及到链接)<blockquote><p>(拓展)此图给出了实现两个相邻数组元素交换功能的不同层次语言的描述 。在高级语言源程序中，可直观地用三个赋值语句实现;在经<code>编译</code>后生成的汇编语言源程序中,可用4 个汇编指令 表 示 ， 其 中 ， 两 条 是 取 数 指 令 I w (l o a d w o r d )， 另 两 条 是 存 数 指 令 s w (s t o r e w o r d ); 在 经 汇编后生成的<code>机器语言程序</code>中，对应的机器指令是特定格式的二进制代码，例如，第一条Iw指令对应的机器代码为“1000 11000100 11110000000000000000”，这是一条MIPS体系结构中的指令，其中，高6位“100011” 为操作码，随后5位“00010” 为寄存器编号2，再后面5位 “01111” 为另一个寄存器编号，最后16位表示立即数0 。CPU能够通过<code>逻辑电路</code>直接执行这种<code>二进制表示的机器指令</code>。指令执行时通过控制器对指令操作码进行译码，解释成控制信号(control signal)控制数据通路执行，例如，控制信号ALUop&#x3D; add 可以控制ALU进行加法操作，RegWr&#x3D; 1 可以控制将结果写人寄存器。</p></blockquote><p>而要解释为何c++支持函数重载，就需要说一说<code>链接</code>阶段。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><blockquote><p>链接过程就是将<code>多个</code>输入目标文件(.o文件)加工合并成<code>一个</code>输出文件(<code>可执行</code>二进制文件)。在此阶段，可执行的二进制文件会对一些<code>符号</code>进行解析，调整一些地址。(注意：目标文件也是二进制，但操作系统并不允许直接执行！)</p></blockquote><ul><li>重点<br>比如在编译main文件时，有一个func函数(来自func文件)的声明，但编译器完全不知道他的存在！printf也是同理，虽然有#include &lt;stdio.h&gt;，但是在此头文件里也仅仅是一个<code>函数声明</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就意味着具体代码是什么样，或者存放在哪个内存块都是编译器目前不知道的。那么没有办法，只有先把函数的<code>跳转地址设置为0</code>，等到链接阶段再去修正。(为了找到这些要修正的函数，会生成重定位表，存放函数地址的偏移量。)</p><blockquote><p>(扩展)重定位表（Relocation Table）：重定位表保存了程序中需要进行地址重定位的信息。在编译和链接过程中，代码和数据段的实际内存地址可能还未确定，因此在生成目标文件时，编译器会记录下哪些位置<code>需要在链接时进行修改</code>。</p></blockquote><p>所以链接其实就是将多个目标文件以及一些静态库等等组合成一个可执行文件。在此过程中还会进行地址修正等工作。</p><p>接下来用一个具体的例子来解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>; <span class="comment">// 声明外部函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo(); <span class="comment">// 调用外部函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时生成的总符号表：</p><table><thead><tr><th>符号</th><th>类型</th><th>地址</th></tr></thead><tbody><tr><td>foo</td><td>函数</td><td>0x1000</td></tr><tr><td>bar</td><td>函数</td><td>0x2000</td></tr></tbody></table><p>bar里的重定位表</p><table><thead><tr><th>段</th><th>偏移</th><th>符号</th><th>操作</th></tr></thead><tbody><tr><td>.text.bar</td><td>0x04</td><td>foo</td><td>重定位</td></tr></tbody></table><p>在链接阶段，链接器会通过重定位表中的信息，将 b.c 中对 foo 的调用地址修改为 foo 在内存中的实际地址（假设是 0x1000）。</p><ul><li>注意：在不同的编译和链接阶段，符号表中的地址可能会有变化，尤其是在动态链接和加载的情况下。这里只是取简单情况进行分析。具体还要结合链接方式等情况来分析。</li></ul><p>如何在符号表里找到想要的函数，就需要借助命名规则。<br>Linux下的g++的命名规则最简单，常常修饰后变成【_Z+函数长度+函数名+类型首字母】。<br>c++存在这样的<code>函数名修饰</code>规则，而c没有，这就是c++可以实现重载的关键。</p><blockquote><p>规则规定：在 c++ 中，为了支持函数重载，编译器会对每个<code>函数名</code>进行<code>修饰</code>，从而生成<code>唯一的符号</code>来标识该函数。函数名修饰规则是由编译器定义的，不同的编译器可能会采用不同的修饰规则。Microsoft Visual C++ 编译器将函数名后面加上下划线和参数个数，参数类型和参数个数之间用 @ 分隔。例如，函数 void foo(int a, float b) 的修饰名为 _foo@8。</p></blockquote><p>如：<br><img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD4.png'></p><p>汇编阶段生成的符号表将会记录函数的<code>名称</code>与<code>地址</code>。</p><ul><li>若无函数名修饰规则，那么编译器只根据原始函数名来生成放在符号表中的函数名；如果有修饰规则，那么会将<code>形参个数，类型，顺序</code>也添加进考虑范围，以形成新的函数名。</li></ul><p>有一点需要注意，在编译的过程中，是<code>不会</code>执行用户的自定义函数的。</p><blockquote><p>在链接的阶段，链接器会解析<code>所有的符号</code>，并将被调用的函数的目标代码包含在可执行文件中。当我们在一个源文件中定义一个函数时，编译器会将该函数编译成目标代码，并在生成的目标文件中生成相应的符号。如果在其他源文件中<code>调用</code>了该函数，链接器会在链接阶段将相应的目标文件合并成一个可执行文件，并将<code>各个符号解析成实际的地址</code>，从而使得程序能够正确地执行。</p></blockquote><ul><li>所以c无法实现函数重载就是因为c没有像c++这样的修饰规则，而是仅仅以函数名来区分各函数。<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD3.png'></li></ul><p>此时又会出现一个问题，如果在团队开发里，有人用c，有人用c++，那么此时在这种混合模式下开发，由于c和c++编译器对函数名字修饰规则不同，可能就会导致链接失败！<br>针对这样的问题，可以采取在函数前加extern “C”的办法，也就是告诉编译器将该函数按照c语言规则来编译。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 函数重载 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
