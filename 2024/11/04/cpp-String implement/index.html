<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>String类的简单模拟实现 | ChengZi</title><meta name="keywords" content="c++,string,数据结构"><meta name="author" content="chengzi"><meta name="copyright" content="chengzi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="String类的简单模拟实现"><meta name="application-name" content="String类的简单模拟实现"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="String类的简单模拟实现"><meta property="og:url" content="http://example.com/2024/11/04/cpp-String%20implement/index.html"><meta property="og:site_name" content="ChengZi"><meta property="og:description" content="最近学到了string的相关的库，于是为了加深对函数的理解便打算模拟实现一下常用的string库函数。  引入这是一个简单的string类的用法。 12345678910#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;int main() &amp;amp;#123"><meta property="og:locale" content="en"><meta property="og:image" content="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730709520256.jpg"><meta property="article:author" content="chengzi"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730709520256.jpg"><meta name="description" content="最近学到了string的相关的库，于是为了加深对函数的理解便打算模拟实现一下常用的string库函数。  引入这是一个简单的string类的用法。 12345678910#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;int main() &amp;amp;#123"><link rel="shortcut icon" href="/tubiao1.jpg"><link rel="canonical" href="http://example.com/2024/11/04/cpp-String%20implement/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"(⁎⁍̴̛ᴗ⁍̴̛⁎)快回来快回来！","backTitle":"♪(^∇^*)你好鸭！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"σ(o’ω’o)睡觉啦，不要熬夜！","startTime":0,"endTime":5},{"greeting":"٩(๑˃̵ᴗ˂̵๑)۶早上好鸭，今天也要开心！","startTime":6,"endTime":9},{"greeting":"(｡◕ ∀ ◕｡)上午好鸭，今天有什么计划呢？","startTime":10,"endTime":10},{"greeting":"(๑¯ω¯๑)想淦饭了捏~","startTime":11,"endTime":11},{"greeting":"ʕ•̀ω•́ʔ✧午安!","startTime":12,"endTime":14},{"greeting":"(･’ω’･)今天完成了什么工作呢？","startTime":14,"endTime":18},{"greeting":"(๑˃̵ᴗ˂̵)و ﾖｼ!19点喽, 奖励一顿丰盛的大餐吧。","startTime":19,"endTime":19},{"greeting":"(,,◕ ⋏ ◕,,)晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏠 摆烂躺平大学生","智能家居小能手","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇博客已经","messageNext":"天没有更新啦，可能某些内容已经不适用。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"Author: chengzi","link":"Link: ","source":"Source: ChengZi","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ChengZi',
  title: 'String类的简单模拟实现',
  postAI: '',
  pageFillDescription: '引入, 函数模拟实现, 构造函数与析构函数, snowflake获取其长度容量内容, reserve函数, push_back和append函数, cyclonepush_back, append, +x3D操作符, insert函数, find函数, (重要必看)substr函数, 迭代器, resize函数, 一些运算符, ltlt与gtgt最近学到了的相关的库于是为了加深对函数的理解便打算模拟实现一下常用的库函数引入这是一个简单的类的用法由上可见类是标准库中的一个类它定义在命名空间中因此当使用类时需要指定其命名空间为若未定义则可能被认为是未定义的标识符从而导致错误是标准库中定义的命名空间它包含了许多标准库中的类函数和类型定义在中命名空间提供了一种将名称隔离开来以避免名称冲突的机制这样不同库中的同名函数或类就可以在同一个程序中共存而不会发生冲突所以我想进行模拟的类实现为了避免与的类冲突就自定义了一个新的在这块命名空间中我创建了自己的类有三个基本元素字符串容量目前大小设置容量和大小的目的主要是为了方便内存的管理同时需要注意字符串虽然是以结尾但在类中是否结束的标志是获取字符串的长度不包括结尾符遍历字符串包括字符和换行符如上输出的结果是并没有遇到就终止函数模拟实现构造函数与析构函数首先要实现的是构造和析构函数其重要性不必多说这里还有一点要注意虽然常见的输入都是以为结尾的字符串但有时候仍然会遇见中间出现的串这时使用这里的构造函数就会出现问题了比如一个串为在进行时就只会到第一个遇到的为止后面的内容就会遗失所以为了避免这种情况可以考虑将换成不清楚的可以看下这里的对比分析和都是中常用的字符串内存拷贝函数函数用于将一个以结尾的字符串从源地址拷贝到目标地址其函数原型如下其中是目标地址是源地址函数会将源地址包括结尾符中的所有字符拷贝到目标地址中并返回目标地址的指针函数不会检查目标地址是否有足够的空间来存储源地址中的所有字符如果目标地址不够大可能会导致内存溢出和程序崩溃的问题例如下面的代码使用函数将字符串拷贝到字符数组中函数用于将指定长度的内存块从源地址拷贝到目标地址其函数原型如下其中是目标地址是源地址是要拷贝的字节数函数会将源地址中的指定长度的内存块拷贝到目标地址中并返回目标地址的指针与不同函数不会自动添加结尾符而且要求目标地址有足够的空间来存储拷贝的数据例如下面的代码使用函数将长度为的内存块从数组中拷贝到数组中下面这一点非常重要由于函数不会自动添加结尾符如果使用函数拷贝字符串时需要手动添加结尾符例如将原字符串带的一起复制到新的空间获取其长度容量内容由于是自定义的类无法直接使用来输出那么就可以考虑实现来获取字符串内容长度和容量由于在其他函数中复用很多也就一并拿出来了获取字符串长度这里的表示该成员函数是一个常量成员函数这意味着它不会修改类的任何成员变量因此这个成员函数可以在常量对象上被调用也可以在被声明为的对象指针或引用上被调用获取字符串容量获取字符串内容这里的表示返回的指针指向的字符数组是常量即通过这个指针不能修改字符数组的内容函数函数用于为字符串预分配内存空间以提高字符串操作的效率和性能其函数原型如下其中是要预分配的内存空间大小以字节为单位函数会尝试为字符串分配至少个字节的内存空间如果当前已经分配的内存空间足够大则不会进行分配如果分配失败则会抛出异常下面的代码使用函数为字符串预分配个字节的内存空间调用函数仅仅是为字符串预分配内存空间并不会改变字符串的长度如果要修改字符串的长度可以使用函数或者直接对字符串进行赋值操作另外由于中的类已经封装了内存管理的细节因此在大多数情况下不需要手动调用函数进行内存管理只需要使用字符串类提供的成员函数和操作符即可只有在特殊的性能优化或者内存限制的情况下才需要手动调用函数模拟实现如下只有当预留空间大于当前分配空间才会进行核心思路就是开辟一个新的空间让旧指针指向他和函数和用于向字符串末尾添加新的字符或字符串它们的区别和用法如下函数用于向字符串末尾添加一个字符其函数原型如下其中是要添加的字符例如下面的代码使用函数向字符串中添加字符上述代码中函数将字符添加到字符串的末尾模拟实现为倍扩容不要忘记函数用于向字符串末尾添加一个字符串其函数原型如下其中是要添加的字符串是要添加的字符数组是要添加的字符个数是要添加的字符例如下面的代码使用函数向字符串中添加一个字符串和一个字符上述代码中函数先将字符串中的前个字符即添加到字符串的末尾然后再将字符添加到字符串的末尾函数可以一次性向字符串中添加多个字符和字符串比函数更加灵活模拟实现为至少扩容到操作符有了和直接复用就好思考为什么要加第二个函数如果去掉使用这样的语句编译器会报错没有与这些操作数匹配的运算符原因是的类型是同时被隐式转换为参数却希望接受这样的结果当然是编译器所不希望的也就是所谓的权限放大明明是不可以更改的常量串传个参还变成可更改了这自然不被允许函数用于向字符串中插入字符或字符串其函数原型如下其中是要插入的位置是要插入的字符串和是要插入的子字符串的起始位置和长度是要插入的字符数组是要插入的字符个数是要插入的字符是要插入的位置和是要插入的字符序列的起始和结束迭代器在指定位置插入一个字符或一个字符序列例如下面的代码使用函数在字符串的第个位置插入字符上述代码中函数将字符插入到字符串的第个位置函数还可以插入一个字符序列例如上述代码中函数将字符串插入到字符串的第个位置常用的也就是上面两种模拟实现如下至少扩容到重要的地方同理要加至少扩容到别写成了此时比还小不用循环同样可以用或者示例的模拟实现就是先判定空间是否够大不够大就扩容然后把插入位置后面的元素都往后挪个位置再回到插入指定的元素这个地方单独提一下因为存在减为继续减到的情况但这里是类型是一个无符号整型当再减时就变成了一个极大数此时需要来终止循环函数用于在字符串中查找指定子串的位置其函数原型如下其中是要查找的子串是要查找的字符数组是要查找的字符个数是要查找的字符是查找起始位置具体用法如下查找指定字符串在源字符串中的位置例如下面的代码使用函数在字符串中查找子串的位置上述代码中函数查找字符串在字符串中第一次出现的位置并将其返回如果字符串不在字符串中函数将返回查找指定字符数组在源字符串中的位置例如下面的代码使用函数在字符串中查找字符数组的位置上述代码中函数在字符串的第个位置开始查找字符数组的前个字符并将其返回如果字符数组不在字符串中函数将返回查找指定字符在源字符串中的位置例如下面的代码使用函数在字符串中查找字符的位置上述代码中函数在字符串的第个位置开始查找字符的位置并将其返回如果字符不在字符串中函数将返回在类中存在这个特殊的常量在字符串操作中通常使用等函数来查找指定子串或字符在原字符串中的位置如果查找失败这些函数会返回一个特殊的值以表示查找失败的情况以下是两种常用形式的模拟实现也可以是不过需要自己新定义一个是的一个静态成员变量是语言标准库中的一个函数用于在一个字符串中查找另一个字符串的第一次出现位置返回偏移量重要必看函数用于从一个字符串中提取子串其函数原型为其中是子串的起始位置是子串的长度如果省略参数则返回从开始到字符串末尾的所有字符如果大于等于字符串的长度或者为那么函数返回一个空字符串下面是一个使用函数提取子串的示例从位置开始提取长度为的子串输出上述代码中函数从字符串中提取了一个子串其起始位置是长度是提取出的子串是并赋值给了变量模拟实现如下这里有几个需要注意的点第一是并未传入参数所以此处调用无参构造而上文还未实现无参构造第二时会调用拷贝构造函数上文也没写拷贝构造敲重点非常重要构造函数拷贝构造函数调用构造函数调用构造函数在堆上创建对象并初始化为调用拷贝构造函数创建作为的副本同样调用拷贝构造函数时返回类型是所以该返回一份副本应该调用拷贝构造函数如果是引用或者指针的形式就不会创建副本也就不会调用拷贝构造但这个行为非常危险完善无参构造与拷贝构造无参构造函数拷贝构造函数迭代器因为是自己实现的类所以如果要用到范围这样的代码就得自己实现迭代器注意有无的情况最好都写一下必须要加单纯返回类型不一致无法构成重载同理这样就可以使用范围等需要迭代器的用法了如果你的类支持正向遍历和反向遍历你可能需要实现两个迭代器一个正向迭代器和一个反向迭代器一旦你实现了迭代器你的自定义类就可以像标准容器一样使用范围语句了在范围语句中你需要使用方法返回你的类的起始迭代器使用方法返回你的类的结束迭代器例如返回正向迭代器返回正向迭代器返回反向迭代器返回反向迭代器处理元素反向遍历元素函数是标准库中容器和字符串类中的一个成员函数用于改变容器或字符串的大小会改变容器中元素的个数对容器而言如果新的大小小于当前大小那么超出新大小的元素将被截断如果新的大小大于当前大小那么容器将增加新元素并使用默认构造函数初始化这些新元素对于字符串如果新的大小小于当前大小那么超出新大小的字符将被截断如果新的大小大于当前大小那么字符串将增加新字符并使用字符填充这些新字符一些运算符第三个参数确定要比较的字节数比大则返回正数小则返回负数相等则返回第一个修饰的是函数参数表示该参数是一个常量引用避免了对参数进行修改而第二个修饰的是函数自身表示该成员函数不会修改对象的状态即不会修改该对象的成员变量用一个写好的运算符在其他的运算符中进行复用也是一个常见的技巧像这个直接就复用了才写好的和与要实现这样的效果就需要重载与操作符从输入流中读取一个字符检查此字符是否是空字符或者这两个重载需要放在全局情况中不要放到类中这是因为在中运算符重载是一种基于函数重载的机制它允许自定义类对象的行为并支持与内置类型的相同语义在大多数情况下可以重载任何运算符包括和等然而对于和运算符它们具有特殊的语义通常用于输入和输出操作因此在重载时需要特别注意如果将或运算符作为成员函数来定义其左操作数将被隐式地设置为该类的对象而右操作数则需要作为函数参数传入但是对于输入流对象和输出流对象它们是作为全局对象存在的而不是作为类的成员对象存在的因此需要使用全局函数来重载这些运算符',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-15 08:50:25',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E9%B8%AD%E5%AD%90%E8%B5%B0%E8%B7%AF.gif"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/null" title="demo"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="project" alt="demo"/><span class="back-menu-item-text">demo</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">ChengZi</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> Search</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">February 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">December 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/c/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>c++</span></a><a class="article-meta__tags" href="/tags/string/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>string</span></a><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>数据结构</span></a></span></div></div><h1 class="post-title" itemprop="name headline">String类的简单模拟实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-11-04T08:35:14.000Z" title="Created 2024-11-04 16:35:14">2024-11-04</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-15T00:50:25.685Z" title="Updated 2024-12-15 08:50:25">2024-12-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为四川"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>四川</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730709520256.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/11/04/cpp-String%20implement/"><header><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><a href="/tags/c/" tabindex="-1" itemprop="url">c++</a><a href="/tags/string/" tabindex="-1" itemprop="url">string</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url">数据结构</a><h1 id="CrawlerTitle" itemprop="name headline">String类的简单模拟实现</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">chengzi</span><time itemprop="dateCreated datePublished" datetime="2024-11-04T08:35:14.000Z" title="Created 2024-11-04 16:35:14">2024-11-04</time><time itemprop="dateCreated datePublished" datetime="2024-12-15T00:50:25.685Z" title="Updated 2024-12-15 08:50:25">2024-12-15</time></header><blockquote>
<p>最近学到了string的相关的库，于是为了加深对函数的理解便打算模拟实现一下常用的string库函数。</p>
</blockquote>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>这是一个简单的string类的用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The length of the string is: &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由上可见，string类是C++标准库中的一个类，它定义在<code>std命名空间</code>中。因此，当使用string类时，需要指定其命名空间为std，若未定义，则可能被认为是未定义的标识符，从而导致错误。</p>
<blockquote>
<p>std是C++标准库中定义的命名空间，它包含了许多C++标准库中的类、函数和类型定义。在C++中，命名空间提供了一种将名称隔离开来以<code>避免名称冲突</code>的机制。这样，不同库中的同名函数或类就可以在同一个程序中共存，而不会发生冲突。</p>
</blockquote>
<p>所以我想进行模拟的string类实现，为了避免与std的string类冲突，就自定义了一个新的namespace——newstring。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> newstring &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">size_t</span> _size;</span><br><span class="line">		<span class="type">size_t</span> _capacity;</span><br><span class="line">		<span class="type">char</span>* _str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在newstring这块命名空间中，我创建了自己的string类，有三个基本元素：</p>
<ol>
<li>字符串_str</li>
<li>容量_capacity</li>
<li>目前大小_size</li>
</ol>
<p>设置容量和大小的目的主要是为了方便内存的管理，同时需要注意，字符串虽然是以’\0’结尾，但在string类中，是否结束的标志是size。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;123\\01212121&quot;</span>;</span><br><span class="line">   <span class="type">size_t</span> len = str<span class="number">1.</span><span class="built_in">size</span>(); <span class="comment">// 获取字符串的长度，不包括 null 结尾符</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> c : str1) &#123; <span class="comment">// 遍历字符串，包括 null 字符和换行符</span></span><br><span class="line">       std::cout &lt;&lt; c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如上，输出的结果是123\01212121，并没有遇到\0就终止。</p>
<h1 id="函数模拟实现"><a href="#函数模拟实现" class="headerlink" title="函数模拟实现"></a>函数模拟实现</h1><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>首先要实现的是构造和析构函数，其重要性不必多说。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">	_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">	_capacity = _size;</span><br><span class="line">	_str = <span class="keyword">new</span> <span class="type">char</span>[_size + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(_str, str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">string</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] _str;</span><br><span class="line">	_str = <span class="literal">nullptr</span>;</span><br><span class="line">	_size = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里还有一点要注意，虽然常见的输入都是以’\0’为结尾的字符串，但有时候仍然会遇见<br>中间出现’\0’的串，这时使用这里的构造函数就会出现问题了。</p>
</blockquote>
<p>比如，一个串为”hello\0world”,在进行strcpy时就只会copy到<code>第一个遇到的\0</code>为止，后面的内容就会遗失，所以为了避免这种情况，可以考虑将strcpy换成<code>memcpy</code>。</p>
<p>不清楚的可以看下这里的对比分析。</p>
<p>strcpy 和 memcpy 都是 C&#x2F;C++ 中常用的<code>字符串/内存拷贝</code>函数。<br>strcpy 函数用于将一个以 <code>null</code> 结尾的字符串从源地址拷贝到目标地址，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，dest 是<code>目标地址</code>，src 是<code>源地址</code>。strcpy 函数会将源地址（包括 null 结尾符）中的所有字符拷贝到目标地址中，并<code>返回目标地址的指针</code>。strcpy 函数<code>不会检查目标地址是否有足够的空间</code>来存储源地址中的所有字符，如果目标地址不够大，可能会导致内存溢出和程序崩溃的问题。</p>
<p>例如，下面的代码使用 strcpy 函数将字符串 “Hello, world!” 拷贝到字符数组 str 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>memcpy 函数用于将<code>指定长度的内存块</code>从源地址拷贝到目标地址，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>


<p>其中，dest 是目标地址，src 是源地址，count 是要拷贝的字节数。memcpy 函数会将源地址中的指定长度的内存块拷贝到目标地址中，并返回目标地址的指针。与 strcpy 不同，memcpy 函数<code>不会自动添加 null 结尾符</code>，而且要求目标地址有足够的空间来存储拷贝的数据。</p>
<p>例如，下面的代码使用 memcpy 函数将长度为 10 的内存块从数组 src 中拷贝到数组 dest 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> src[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(dest, src, <span class="built_in">sizeof</span>(src));</span><br></pre></td></tr></table></figure>

<p>下面这一点非常重要！</p>
<blockquote>
<p>由于 memcpy 函数<code>不会自动添加 null 结尾符</code>，如果使用 memcpy 函数拷贝字符串时，需要手动添加 null 结尾符，例如：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span>* src = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(str, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>); <span class="comment">//将原字符串带的\0一起复制到新的空间。</span></span><br></pre></td></tr></table></figure>




<h2 id="snowflake-获取其长度，容量，内容"><a href="#snowflake-获取其长度，容量，内容" class="headerlink" title=":snowflake:获取其长度，容量，内容"></a>:snowflake:获取其长度，容量，内容</h2><p>由于是自定义的类，无法直接使用cout来输出，那么就可以考虑实现c_str来获取字符串内容。长度和容量由于在其他函数中复用很多，也就一并拿出来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 获取字符串长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">//这里的 const 表示该成员函数是一个常量成员函数。这意味着它不会修改类的任何成员变量。因此，这个成员函数可以在常量对象上被调用，也可以在被声明为 const 的对象指针或引用上被调用。</span></span><br><span class="line">	<span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串容量</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串内容</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">//这里的 const 表示返回的指针指向的字符数组是常量，即通过这个指针不能修改字符数组的内容。</span></span><br><span class="line">	<span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="reserve函数"><a href="#reserve函数" class="headerlink" title="reserve函数"></a>reserve函数</h2><p>reserve 函数用于为<code>字符串预分配内存空间</code>，以提高字符串操作的效率和性能。其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(size_type new_cap)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，new_cap 是要预分配的内存空间大小，以字节为单位。reserve 函数会尝试为字符串分配至少 new_cap 个字节的内存空间，如果当前已经分配的内存空间足够大，则不会进行分配，如果分配失败，则会抛出 <code>std::bad_alloc</code> 异常。</p>
<p>下面的代码使用 reserve 函数为字符串 str 预分配 100 个字节的内存空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">str.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>调用reserve函数仅仅是为字符串预分配内存空间，并<code>不会改变字符串的长度</code>。如果要修改字符串的长度，可以使用 resize 函数或者直接对字符串进行赋值操作。<br>另外，由于 C++ STL 中的 std::string 类已经封装了内存管理的细节，因此在大多数情况下不需要手动调用 reserve 函数进行内存管理，只需要使用字符串类提供的成员函数和操作符即可。只有在特殊的性能优化或者内存限制的情况下，才需要手动调用 reserve 函数。</p>
<p>模拟实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; _capacity) <span class="comment">//只有当预留空间大于当前分配空间才会进行</span></span><br><span class="line">		&#123;</span><br><span class="line">                <span class="comment">//核心思路就是开辟一个新的空间，让旧指针指向他</span></span><br><span class="line">			<span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(tmp, _str);</span><br><span class="line">			<span class="keyword">delete</span>[] _str;</span><br><span class="line">			_str = tmp;</span><br><span class="line">			_capacity = n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h2 id="push-back和append函数"><a href="#push-back和append函数" class="headerlink" title="push_back和append函数"></a>push_back和append函数</h2><p>push_back 和 append用于向字符串<code>末尾</code>添加新的字符或字符串。它们的区别和用法如下：</p>
<h3 id="cyclone-push-back"><a href="#cyclone-push-back" class="headerlink" title=":cyclone:push_back"></a>:cyclone:push_back</h3><p>push_back 函数用于向字符串末尾添加<code>一个字符</code>。其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，ch 是要添加的字符。例如，下面的代码使用 push_back 函数向字符串 str 中添加字符 ‘a’：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，push_back 函数将字符 ‘a’ 添加到字符串 str 的末尾。<br>模拟实现为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 2倍扩容</span></span><br><span class="line">				<span class="built_in">reserve</span>(_capacity == <span class="number">0</span> ? <span class="number">4</span> : _capacity * <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			_str[_size] = ch;</span><br><span class="line"></span><br><span class="line">			++_size;</span><br><span class="line">			_str[_size] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//不要忘记\0</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>append 函数用于向字符串末尾添加<code>一个字符串</code>。其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> basic_string&amp; str)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">append</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，str 是要添加的字符串，s 是要添加的字符数组，n 是要添加的字符个数，c 是要添加的字符。例如，下面的代码使用 append 函数向字符串 str 中添加一个字符串和一个字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot; - C++&quot;</span>, <span class="number">5</span>).<span class="built_in">append</span>(<span class="number">1</span>, <span class="string">&#x27;!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，append 函数先将字符串 “ - C++” 中的前 5 个字符（即 “ - C”）添加到字符串 str 的末尾，然后再将字符 ‘!’ 添加到字符串 str 的末尾。<br>append 函数可以一次性向字符串中添加多个字符和字符串，比 push_back 函数更加灵活。</p>
<p>模拟实现为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">			<span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 至少扩容到_size + len</span></span><br><span class="line">				<span class="built_in">reserve</span>(_size + len);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">strcpy</span>(_str + _size, str);</span><br><span class="line">			_size += len;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="+&#x3D;操作符"></a>+&#x3D;操作符</h2><p>有了append和push_back，+&#x3D;直接复用就好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">char</span> ch)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">push_back</span>(ch);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str)  <span class="comment">//思考为什么要加const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">append</span>(str);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二个函数如果去掉const，使用str+&#x3D;”abc”这样的语句，编译器会报错:没有与这些操作数匹配的 “+&#x3D;” 运算符。原因是”abc”的类型是const char，同时被<code>隐式转换为const char*</code>，参数却希望接受char*，这样的结果当然是编译器所不希望的，也就是所谓的权限放大。明明是不可以更改的常量串，传个参还变成可更改了，这自然不被允许。</p>
</blockquote>
<h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2><p>insert用于向字符串中插入字符或字符串。其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> basic_string&amp; str)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> basic_string&amp; str, size_type subpos, size_type sublen)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> <span class="type">char</span>* s, size_type n)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">basic_string&amp; <span class="title">insert</span><span class="params">(size_type pos, size_type n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator p, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator p, size_type n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator p, InputIt first, InputIt last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，pos 是要插入的位置，str 是要插入的字符串，subpos 和 sublen 是要插入的子字符串的起始位置和长度，s 是要插入的字符数组，n 是要插入的字符个数，c 是要插入的字符，p 是要插入的位置，first 和 last 是要插入的字符序列的起始和结束迭代器。</p>
<p>在指定位置插入一个字符或一个字符序列。<br>例如，下面的代码使用 insert 函数在字符串 str 的第 5 个位置插入字符 ‘a’：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，insert 函数将字符 ‘a’ 插入到字符串 str 的第 5 个位置。</p>
<p>insert 函数还可以插入一个字符序列，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot; - C++&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，insert 函数将字符串 “ - C++” 插入到字符串 str 的第 5 个位置。</p>
<p>常用的也就是上面两种。<br>模拟实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (_size + n &gt; _capacity)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 至少扩容到_size + len</span></span><br><span class="line">				<span class="built_in">reserve</span>(_size + n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">size_t</span> end = _size;</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= pos &amp;&amp; end&lt;_size)<span class="comment">//重要的地方</span></span><br><span class="line">			&#123;</span><br><span class="line">				_str[end + n] = _str[end];</span><br><span class="line">				--end;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				_str[pos + i] = ch;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			_size += n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* str)</span>  <span class="comment">//同理要加const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line">			<span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">			<span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 至少扩容到_size + len</span></span><br><span class="line">				<span class="built_in">reserve</span>(_size + len);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">size_t</span> end = _size;</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= pos &amp;&amp; end != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				_str[end + len] = _str[end];</span><br><span class="line">				--end;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				_str[pos + i] = str[i]; <span class="comment">//别写成了_sre[end]，此时enb比pos还小1</span></span><br><span class="line">			&#125;   <span class="comment">//不用for循环同样可以用memcpy或者strcpy，</span></span><br><span class="line">			    <span class="comment">//示例:memcpy(_str + pos, str, len);</span></span><br><span class="line"></span><br><span class="line">			_size += len;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>insert的模拟实现就是先判定空间是否够大，不够大就扩容，然后把插入位置pos后面的元素都往后挪n个位置，再回到pos插入指定的元素。</p>
<blockquote>
<p>while (end &gt;&#x3D; pos &amp;&amp; end&lt;&#x3D;_size)</p>
</blockquote>
<p>这个地方单独提一下，因为end存在减为0继续减到-1的情况，但这里end是size_t类型，是一个<code>无符号整型</code>，当0再减1时，end就变成了一个<code>极大数</code>，此时需要end&lt;&#x3D;_size来终止循环。</p>
<h2 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h2><p>find用于在字符串中查找指定子串的位置。其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> basic_string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，str 是要查找的子串，s 是要查找的字符数组，n 是要查找的字符个数，c 是要查找的字符，pos 是查找起始位置。具体用法如下：</p>
<p>查找指定字符串在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找子串 “world” 的位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，find 函数查找字符串 “world” 在字符串 str 中第一次出现的位置，并将其返回。如果字符串 “world” 不在字符串 str 中，find 函数将返回 std::string::npos。</p>
<p>查找指定字符数组在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找字符数组 “world” 的位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，find 函数在字符串 str 的第 7 个位置开始查找字符数组 “world” 的前 5 个字符，并将其返回。如果字符数组 “world” 不在字符串 str 中，find 函数将返回 std::string::npos。</p>
<p>查找指定字符在源字符串中的位置。<br>例如，下面的代码使用 find 函数在字符串 str 中查找字符 ‘o’ 的位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，find 函数在字符串 str 的第 5 个位置开始查找字符 ‘o’ 的位置，并将其返回。如果字符 ‘o’ 不在字符串 str 中，find 函数将返回 std::string::npos。</p>
<blockquote>
<p>在string类中存在<code>npos</code>这个<code>特殊的常量</code>。在字符串操作中，通常使用 find 等函数来查找指定子串或字符在原字符串中的位置。如果查找失败，这些函数会<code>返回一个特殊的值 npos</code>，以表示查找失败的情况。</p>
</blockquote>
<p>以下是两种常用形式的模拟实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> ch, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = pos; i &lt; _size; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (_str[i] == ch)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//也可以是npos，不过需要自己新定义一个，npos 是 std::string::npos 的一个静态成员变量。</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line">			<span class="type">const</span> <span class="type">char</span>* ptr = <span class="built_in">strstr</span>(_str + pos, str); <span class="comment">//strstr 是 C 语言标准库中的一个函数，用于在一个字符串中查找另一个字符串的第一次出现位置。</span></span><br><span class="line">			<span class="keyword">if</span> (ptr)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> ptr - _str; <span class="comment">//返回偏移量</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重要必看-substr函数"><a href="#重要必看-substr函数" class="headerlink" title="(重要必看)substr函数"></a>(重要必看)substr函数</h2><p>substr用于从一个字符串中提取子串。其函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> count = npos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，pos 是子串的起始位置，count 是子串的长度。如果省略 count 参数，则返回从 pos 开始到字符串末尾的所有字符。如果 pos 大于等于字符串的长度，或者 count 为 0，那么函数返回一个空字符串。</p>
<p>下面是一个使用 substr 函数提取子串的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>);  <span class="comment">// 从位置 7 开始提取长度为 5 的子串</span></span><br><span class="line">    std::cout &lt;&lt; sub &lt;&lt; std::endl;  <span class="comment">// 输出 &quot;world&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，substr 函数从字符串 str 中提取了一个子串，其起始位置是 7，长度是 5。提取出的子串是 “world”，并赋值给了变量 sub。<br>模拟实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">			<span class="type">size_t</span> n = length;</span><br><span class="line">			<span class="keyword">if</span> (pos + length &gt; size)</span><br><span class="line">				n = size - pos;</span><br><span class="line">			string tmp;</span><br><span class="line">			<span class="type">char</span>* s = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];</span><br><span class="line">			tmp._str = s;</span><br><span class="line">			tmp._capacity = n;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				tmp += _str[pos + i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有几个需要注意的点。第一是string tmp并未传入参数，所以此处调用<code>无参构造</code>。而上文还未实现无参构造。第二，return时会调用拷贝构造函数，上文也没写拷贝构造。</p>
</blockquote>
<p><em><strong>敲重点！非常重要</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value) &#123;&#125; <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">data</span>(other.data) &#123;&#125; <span class="comment">// 拷贝构造函数  </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> data;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用构造函数  </span></span><br><span class="line">MyClass* objPtr = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">20</span>); <span class="comment">// 调用构造函数，在堆上创建对象并初始化data为20</span></span><br><span class="line">MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数，创建obj2作为obj1的副本  </span></span><br><span class="line"><span class="function">MyClass <span class="title">obj3</span><span class="params">(obj1)</span></span>; <span class="comment">// 同样调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>return时返回类型是string，所以该返回一份副本，应该调用拷贝构造函数。如果是引用或者指针的形式，就不会创建副本，也就不会调用拷贝构造，但这个行为非常危险！</p>
<p>完善无参构造与拷贝构造：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">string</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">capacity</span>(<span class="number">0</span>),_str(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数  </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; other) &#123;</span><br><span class="line">		size = other.size;</span><br><span class="line">		capacity = other.capacity;</span><br><span class="line">		_str = <span class="keyword">new</span> <span class="type">char</span>[capacity + <span class="number">1</span>];</span><br><span class="line">		std::<span class="built_in">memcpy</span>(_str, other._str, size + <span class="number">1</span>); </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>因为是自己实现的类，所以如果要用到范围for这样的代码，就得自己实现迭代器。注意有无const的情况最好都写一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">char</span>* iterator;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* const_iterator;</span><br><span class="line"></span><br><span class="line">		<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _str + _size;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">//必须要加const，单纯返回类型不一致无法构成重载！</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//同理</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _str + _size;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以使用范围for等需要迭代器的用法了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : s1) &#123;</span><br><span class="line">       std::cout &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果你的类支持正向遍历和反向遍历，你可能需要实现两个迭代器：一个<code>正向迭代器和一个反向迭代器</code>。</p>
<p>一旦你实现了迭代器，你的自定义类就可以像标准容器一样使用范围for语句了。在范围for语句中，你需要使用 <code>begin() </code>方法返回你的类的起始迭代器，使用<code>end()</code> 方法返回你的类的结束迭代器。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回正向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回正向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">ReverseIterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回反向迭代器 */</span> &#125;</span><br><span class="line">    <span class="function">ReverseIterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="comment">/* 返回反向迭代器 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyContainer container;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : container) &#123;</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : std::<span class="built_in">reverse</span>(container)) &#123;</span><br><span class="line">    <span class="comment">// 反向遍历元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h2><p>resize() 是 C++ 标准库中容器和字符串类中的一个成员函数，用于改变容器或字符串的大小。<br>resize() 会<code>改变容器中元素的个数</code>。<br>对容器而言：</p>
<ol>
<li>如果新的大小<code>小于</code>当前大小，那么超出新大小的元素将被截断；</li>
<li>如果新的大小<code>大于</code>当前大小，那么容器将增加新元素，并使用默认构造函数初始化这些新元素。</li>
</ol>
<p>对于字符串：</p>
<ol>
<li>如果新的大小<code>小于</code>当前大小，那么超出新大小的字符将被截断；</li>
<li>如果新的大小<code>大于</code>当前大小，那么字符串将增加新字符，并使用<code> &#39;\0&#39; 字符</code>填充这些新字符。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> ch = <span class="string">&#x27;\0&#x27;</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (n &lt; _size)</span><br><span class="line">			&#123;</span><br><span class="line">				_size = n;</span><br><span class="line">				_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">reserve</span>(n);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">size_t</span> i = _size; i &lt; n; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					_str[i] = ch;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				_size = n;</span><br><span class="line">				_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些运算符"><a href="#一些运算符" class="headerlink" title="一些运算符"></a>一些运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">memcmp</span>(_str, s._str, _size &lt; s._size ? _size : s._size); <span class="comment">//第三个参数确定要比较的字节数</span></span><br><span class="line">	<span class="comment">//_str比s._str大则返回正数，小则返回负数，相等则返回0</span></span><br><span class="line">	<span class="keyword">return</span> ret == <span class="number">0</span> ? _size &lt; s._size : ret &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个 const 修饰的是<code>函数参数 s</code>，表示该参数是一个常量引用，避免了对参数进行修改。而第二个 const 修饰的是<code>函数自身</code>，表示该成员函数不会修改对象的状态，即不会修改该对象的成员变量。<br>用一个写好的运算符在其他的运算符中进行复用也是一个常见的技巧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _size == s._size </span><br><span class="line">	&amp;&amp; <span class="built_in">memcmp</span>(_str, s._str, _size) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span> &lt; s || *<span class="keyword">this</span> == s;  <span class="comment">//像这个，直接就复用了才写好的&lt;和==		</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> string&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title="&lt;&lt;与&gt;&gt;"></a>&lt;&lt;与&gt;&gt;</h2><p>要实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>这样的效果，就需要重载&gt;&gt;与&lt;&lt;操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; ch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> ch = in.<span class="built_in">get</span>(); <span class="comment">//从输入流中读取一个字符</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">//检查此字符是否是空字符或者&#x27;\0&#x27;</span></span><br><span class="line">	&#123;</span><br><span class="line">		ch = in.<span class="built_in">get</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ch != <span class="string">&#x27; &#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		buff[i++] = ch;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">127</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			s += buff;</span><br><span class="line">			i = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ch = in.<span class="built_in">get</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		s += buff;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两个重载需要放在全局情况中，不要放到string类中！</p>
</blockquote>
<p>这是因为在 C++ 中，运算符重载是一种基于函数重载的机制，它允许自定义类对象的行为，并支持与内置类型的相同语义。在大多数情况下可以重载任何运算符，包括 &lt;, &gt;, &#x3D;&#x3D;, &lt;&lt; 和 &gt;&gt; 等。<br>然而，对于 &lt;&lt; 和 &gt;&gt; 运算符，它们具有特殊的语义，通常用于<code>输入和输出</code>操作，因此在重载时需要特别注意。如果将 &lt;&lt; 或 &gt;&gt; 运算符<code>作为成员函数</code>来定义，其左操作数将被隐式地设置为<code>该类的对象</code>，而右操作数则需要作为<code>函数参数</code>传入。但是，对于输入流对象和输出流对象，它们是作为<code>全局对象</code>存在的，而不是作为类的成员对象存在的，因此需要使用全局函数来重载这些运算符。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" title="头像" alt="头像"></a><div class="post-copyright__author_name">chengzi</div><div class="post-copyright__author_desc">个人博客</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/11/04/cpp-String%20implement/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/11/04/cpp-String%20implement/')">String类的简单模拟实现</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/11/04/cpp-String%20implement/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=String类的简单模拟实现&amp;url=http://example.com/2024/11/04/cpp-String%20implement/&amp;pic=https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730709520256.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/c/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>c++<span class="tagsPageCount">11</span></a><a class="post-meta__box__tags" href="/tags/string/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>string<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>数据结构<span class="tagsPageCount">4</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/f9ae59d626015a2d731a4cef99d081c3718a0184.gif@1000w_540h.webp?_r_=b02d81f0-1448-1884-23bb-96a2e894bda0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/03/cpp-Inheritance%20and%20polymorphism/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730638310439.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">继承与多态</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/06/Life%20may%20exist%20on%20Jupiter/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730855251925.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">木星卫星上可能存在生命</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/12/13/cpp-vector%20implement/" title="Vector的简单模拟实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734060885575.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-13</div><div class="title">Vector的简单模拟实现</div></div></a></div><div><a href="/2024/12/15/cpp-list%20implement/" title="List的简单模拟实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734227595729.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-15</div><div class="title">List的简单模拟实现</div></div></a></div><div><a href="/2024/12/15/cpp-priority_queue/" title="优先级队列的简单模拟实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734239881472.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-15</div><div class="title">优先级队列的简单模拟实现</div></div></a></div><div><a href="/2024/10/26/cpp-Function%20overloading/" title="C++如何实现函数重载?"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1729922661478.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-10-26</div><div class="title">C++如何实现函数重载?</div></div></a></div><div><a href="/2024/11/03/cpp-reference/" title="C++之引用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730599324079.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-11-03</div><div class="title">C++之引用</div></div></a></div><div><a href="/2024/11/03/cpp-Member%20functions/" title="默认成员函数那些事儿"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1730628665868.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-11-03</div><div class="title">默认成员函数那些事儿</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">本博客记载<b style="color:#fff">开发，算法等</b>相关内容，还有<b style="color:#fff">雅思学习</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">希望你在这里能得到有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">chengzi</h1><div class="author-info__desc">个人博客</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/chengzi516" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">函数模拟实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">构造函数与析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#snowflake-%E8%8E%B7%E5%8F%96%E5%85%B6%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%AE%B9%E9%87%8F%EF%BC%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.</span> <span class="toc-text">:snowflake:获取其长度，容量，内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reserve%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">reserve函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-back%E5%92%8Cappend%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">push_back和append函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cyclone-push-back"><span class="toc-number">2.4.1.</span> <span class="toc-text">:cyclone:push_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append"><span class="toc-number">2.4.2.</span> <span class="toc-text">append</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.5.</span> <span class="toc-text">+&#x3D;操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">insert函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">find函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%BF%85%E7%9C%8B-substr%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.</span> <span class="toc-text">(重要必看)substr函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.9.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#resize%E5%87%BD%E6%95%B0"><span class="toc-number">2.10.</span> <span class="toc-text">resize函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.11.</span> <span class="toc-text">一些运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.12.</span> <span class="toc-text">&lt;&lt;与&gt;&gt;</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/22/test-blog/" title="博客项目测试文档"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/f9ae59d626015a2d731a4cef99d081c3718a0184.gif@1000w_540h.webp?_r_=b02d81f0-1448-1884-23bb-96a2e894bda0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客项目测试文档"/></a><div class="content"><a class="title" href="/2025/02/22/test-blog/" title="博客项目测试文档">博客项目测试文档</a><time datetime="2025-02-22T07:41:10.000Z" title="Created 2025-02-22 15:41:10">2025-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/25/post/" title="基于Linux的进程通信"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/f9ae59d626015a2d731a4cef99d081c3718a0184.gif@1000w_540h.webp?_r_=1f205f5f-8dfa-3aa3-d4c2-913d49d178f9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Linux的进程通信"/></a><div class="content"><a class="title" href="/2024/12/25/post/" title="基于Linux的进程通信">基于Linux的进程通信</a><time datetime="2024-12-25T07:26:01.000Z" title="Created 2024-12-25 15:26:01">2024-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/18/linux-file%20system/" title="IO与文件系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734494164320.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IO与文件系统"/></a><div class="content"><a class="title" href="/2024/12/18/linux-file%20system/" title="IO与文件系统">IO与文件系统</a><time datetime="2024-12-18T03:54:29.000Z" title="Created 2024-12-18 11:54:29">2024-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/15/cpp-priority_queue/" title="优先级队列的简单模拟实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734239881472.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优先级队列的简单模拟实现"/></a><div class="content"><a class="title" href="/2024/12/15/cpp-priority_queue/" title="优先级队列的简单模拟实现">优先级队列的简单模拟实现</a><time datetime="2024-12-15T05:15:03.000Z" title="Created 2024-12-15 13:15:03">2024-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/15/cpp-list%20implement/" title="List的简单模拟实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734227595729.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="List的简单模拟实现"/></a><div class="content"><a class="title" href="/2024/12/15/cpp-list%20implement/" title="List的简单模拟实现">List的简单模拟实现</a><time datetime="2024-12-15T00:41:28.000Z" title="Created 2024-12-15 08:41:28">2024-12-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:p772307283@outlook.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/chengzi516" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div><div class="copyright">&copy;2023 - 2025 By chengzi</div><div id="workboard"><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a></p></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">27</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/null" title="demo"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="project" alt="demo"/><span class="back-menu-item-text">demo</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/IO/" style="font-size: 0.88rem;">IO<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c++<sup>11</sup></a><a href="/tags/list/" style="font-size: 0.88rem;">list<sup>1</sup></a><a href="/tags/makefile/" style="font-size: 0.88rem;">makefile<sup>1</sup></a><a href="/tags/queue/" style="font-size: 0.88rem;">queue<sup>1</sup></a><a href="/tags/string/" style="font-size: 0.88rem;">string<sup>1</sup></a><a href="/tags/vector/" style="font-size: 0.88rem;">vector<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" style="font-size: 0.88rem;">内存对齐<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/" style="font-size: 0.88rem;">函数重载<sup>1</sup></a><a href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/" style="font-size: 0.88rem;">初始化列表<sup>1</sup></a><a href="/tags/%E5%8F%8B%E5%85%83/" style="font-size: 0.88rem;">友元<sup>1</sup></a><a href="/tags/%E5%A4%9A%E6%80%81/" style="font-size: 0.88rem;">多态<sup>1</sup></a><a href="/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/" style="font-size: 0.88rem;">大小端<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">对象<sup>2</sup></a><a href="/tags/%E5%BC%95%E7%94%A8/" style="font-size: 0.88rem;">引用<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>4</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">文件系统<sup>1</sup></a><a href="/tags/%E6%98%93%E9%94%99%E7%82%B9/" style="font-size: 0.88rem;">易错点<sup>1</sup></a><a href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" style="font-size: 0.88rem;">碎碎念<sup>1</sup></a><a href="/tags/%E7%A7%91%E6%8A%80/" style="font-size: 0.88rem;">科技<sup>1</sup></a><a href="/tags/%E7%B1%BB/" style="font-size: 0.88rem;">类<sup>2</sup></a><a href="/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%BA%BA2024/" style="font-size: 0.88rem;">经济学人2024<sup>1</sup></a><a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 0.88rem;">继承<sup>1</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 0.88rem;">编译<sup>2</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 0.88rem;">进程<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="5094069883" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=5094069883&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("10/26/2024 12:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 chengzi 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("10/26/2024 12:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>