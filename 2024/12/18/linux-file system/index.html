<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>IO与文件系统 | ChengZi</title><meta name="keywords" content="文件系统,IO"><meta name="author" content="chengzi"><meta name="copyright" content="chengzi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="IO与文件系统"><meta name="application-name" content="IO与文件系统"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="IO与文件系统"><meta property="og:url" content="http://example.com/2024/12/18/linux-file%20system/index.html"><meta property="og:site_name" content="ChengZi"><meta property="og:description" content="回顾c语言的文件操作相关接口简单的回顾下在c语言中，我们是如何使用相关的文件接口的。C语言提供了一套强大而灵活的文件接口，使得程序能够在磁盘上读取和写入数据。这个文件接口是操作系统提供的API（应用程序编程接口）的一部分，这里则是简单介绍一下C语言中常用的文件接口，包括文件的打开、读取、写入、关闭等"><meta property="og:locale" content="en"><meta property="og:image" content="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734494164320.jpg"><meta property="article:author" content="chengzi"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734494164320.jpg"><meta name="description" content="回顾c语言的文件操作相关接口简单的回顾下在c语言中，我们是如何使用相关的文件接口的。C语言提供了一套强大而灵活的文件接口，使得程序能够在磁盘上读取和写入数据。这个文件接口是操作系统提供的API（应用程序编程接口）的一部分，这里则是简单介绍一下C语言中常用的文件接口，包括文件的打开、读取、写入、关闭等"><link rel="shortcut icon" href="/tubiao1.jpg"><link rel="canonical" href="http://example.com/2024/12/18/linux-file%20system/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"(⁎⁍̴̛ᴗ⁍̴̛⁎)快回来快回来！","backTitle":"♪(^∇^*)你好鸭！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"σ(o’ω’o)睡觉啦，不要熬夜！","startTime":0,"endTime":5},{"greeting":"٩(๑˃̵ᴗ˂̵๑)۶早上好鸭，今天也要开心！","startTime":6,"endTime":9},{"greeting":"(｡◕ ∀ ◕｡)上午好鸭，今天有什么计划呢？","startTime":10,"endTime":10},{"greeting":"(๑¯ω¯๑)想淦饭了捏~","startTime":11,"endTime":11},{"greeting":"ʕ•̀ω•́ʔ✧午安!","startTime":12,"endTime":14},{"greeting":"(･’ω’･)今天完成了什么工作呢？","startTime":14,"endTime":18},{"greeting":"(๑˃̵ᴗ˂̵)و ﾖｼ!19点喽, 奖励一顿丰盛的大餐吧。","startTime":19,"endTime":19},{"greeting":"(,,◕ ⋏ ◕,,)晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏠 摆烂躺平大学生","智能家居小能手","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇博客已经","messageNext":"天没有更新啦，可能某些内容已经不适用。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"Author: chengzi","link":"Link: ","source":"Source: ChengZi","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ChengZi',
  title: 'IO与文件系统',
  postAI: '',
  pageFillDescription: '回顾c语言的文件操作, 相关接口, c语言的输入输出流, linux下的文件操作, 系统文件io, 四个常用接口介绍, 文件描述符, 缓冲区, linux如何管理文件, 概述, 文件系统, 软硬链接回顾语言的文件操作相关接口简单的回顾下在语言中我们是如何使用相关的文件接口的语言提供了一套强大而灵活的文件接口使得程序能够在磁盘上读取和写入数据这个文件接口是操作系统提供的应用程序编程接口的一部分这里则是简单介绍一下语言中常用的文件接口包括文件的打开读取写入关闭等操作打开文件在语言中要对一个文件进行操作首先需要将其打开这可以通过使用函数来实现声明一个文件指针打开名为的文件以供读取声明了一个文件指针使用函数将名为的文件以只读模式打开函数返回一个指向该文件的指针读取文件一旦文件打开成功我们可以使用函数来读取文件内容声明一个用于存储数据的缓冲区从文件中读取个字符到缓冲区中使用函数从打开的文件中读取了个字符然后将其存储到名为的字符数组中写入文件如果需要将数据写入文件可以使用函数将数据写入文件将字符串写入到已经打开的文件中关闭文件在完成文件操作后应该及时关闭文件以释放资源关闭文件错误处理可以通过检查函数的返回值来判断文件是否成功打开或操作是否成功无法打开文件语言的输入输出流函数将字符串写入标准输出函数的参数依次为字符串的指针字符串的长度写入次数和目标输出函数来打印函数将格式化字符串写入标准输出函数来打印函数的参数依次为目标输出和格式化字符串上面三个函数都提到了那么到底是什么在语言中是指向标准输出的文件指针标准输出是一个特殊的文件流通常用于将程序的输出打印到屏幕上在这个函数中使用了不同的输出函数来将字符串打印到标准输出上和都可以接受文件指针作为参数用于指定输出的目标使用可以方便地将输出打印到屏幕上而不需要指定具体的文件或设备这样程序的输出就可以在控制台上可见并且可以通过重定向等方式将输出保存到文件中语言默认会打开三个输入输出流分别是已经在上文解释过当涉及到输入和错误输出时语言提供了两个额外的标准流和是指向标准输入的文件指针标准输入用于接收来自用户的输入通常是通过键盘输入例如使用函数可以从标准输入中读取用户的输入是指向标准错误的文件指针标准错误用于输出程序的错误消息或其他诊断信息与标准输出不同标准错误的输出通常被发送到屏幕上的错误流中而不会被重定向到文件例如使用函数可以将错误消息输出到标准错误流下的文件操作系统文件除了上面提到的语言来进行文件操作也可以通过系统调用来对文件进行读或者写等等操作当使用系统调用进行文件时有几个常用的调用用于打开文件它接受文件路径和一些标志作为参数并返回一个文件描述符表示打开的文件用于从文件中读取数据它接受文件描述符数据缓冲区和读取字节数作为参数并返回实际读取的字节数用于向文件中写入数据它接受文件描述符数据缓冲区和写入字节数作为参数并返回实际写入的字节数用于关闭文件它接受文件描述符作为参数并在操作完成后关闭文件打开一个名为的文件如果不存在则创建然后写入字符串最后关闭文件处理打开文件失败的情况处理写入文件失败的情况四个常用接口介绍要打开或创建的目标文件打开文件时可以传入多个参数选项用下面的一个或者多个常量进行或运算构成参数只读打开只写打开读写打开这三个常量必须指定一个且只能指定一个若文件不存在则创建它追加写返回值成功新打开的文件描述符什么是文件描述符会在下文讲失败参数用于指定新创建文件的权限模式这个函数用于关闭文件它接受文件描述符作为参数在操作完成后关闭文件参数要关闭的文件描述符返回值成功失败这个函数用于向文件中写入数据它接受文件描述符数据缓冲区指针和要写入的字节数作为参数参数要写入的文件描述符指向要写入的数据的缓冲区的指针要写入的字节数返回值成功实际写入的字节数失败这个函数用于从文件中读取数据它接受文件描述符数据缓冲区指针和要读取的最大字节数作为参数参数要读取的文件描述符指向存储读取数据的缓冲区的指针要读取的最大字节数返回值成功实际读取的字节数失败接口演示处理文件打开失败的情况处理读取文件失败的情况打印读取的数据可以看到上文很多地方都出现了和文件描述符的概念二者是一个东西那么什么是文件描述符呢文件描述符在文章开篇时提到了语言会打开三个输入输出流那是如何得知这三个流被打开了呢文件描述符是一个非负整数用于唯一标识一个打开的文件或流它是一个抽象的概念可以是文件管道套接字等标准文件描述符系统通常会为每个进程自动分配三个标准文件描述符标准输入通常用于从键盘或其他输入设备读取数据标准输出通常用于向终端或其他输出设备输出数据标准错误通常用于输出错误消息对应的物理设备一般是键盘显示器显示器文件描述符主要用于进行文件和操作通常通过以下系统调用来操作文件描述符打开一个文件并返回一个文件描述符关闭一个文件描述符释放相关资源从文件描述符中读取数据向文件描述符中写入数据移动文件描述符的读写位置和复制文件描述符创建一个新的文件描述符与之关联也就是说可以这样输出上面的代码实现了从标准输入读取数据并将其写入标准输出和标准错误当打开一个文件时操作系统在内存中要创建相应的数据结构来描述目标文件比如文件大小在磁盘位置打开计数等文件属性也就是结构体来表示并描述一个已经打开的文件对象而如何管理一个个结构体呢为其创建了文件描述符表图中的里面存储了一个指针数组每个元素都指向一个已经打开的文件如图当进程执行系统调用打开文件时当前进程结构中有一个指针指向一张文件描述符表每个进程有自己的表该表的指针数组中每个元素都是一个指向打开文件的指针下标指向默认的文件下标指向文件下标指向文件所以文件描述符就是该数组的下标只要有文件描述符就可以找到对应的文件进程指针分别是这个指针数组的下标从上往下分别指向所代表的三个已打开的文件上图的列表仅存储打开的文件也就是说如果此时新建一个文件那么分配给他的下标就会是如果在创建此文件前关闭了那么此文件的文件描述符就会被分配为这就是系统下文件描述符基本的分配规则当关闭掉文件描述符语言函数底层封装的输出接口仍然是下标哪怕被关闭系统也只认识他要做的就是将需要打印的内容输出到代表的这个文件这也是环境下文件管理的一个显著特征层层封装再由系统统一调用有点多态的意思在里面将原本该打印到屏幕的内容打印到里这就叫重定向文件描述符的重定向允许将一个文件描述符与另一个文件或设备相关联例如可以使用将命令的输出重定向到文件或使用将文件内容作为输入输出重定向将命令的标准输出保存到文件将写入到文件输入重定向从文件中读取数据作为命令的标准输入从文件中读取数据并将其作为命令的输入追加将命令的标准输出追加到文件末尾追加到文件错误输出重定向将命令的标准错误输出保存到文件将命令的标准错误输出保存到文件标准输出和标准错误重定向到同一文件将标准输出和标准错误输出都重定向到同一个文件使用管道将一个命令的输出传递给另一个命令的输入列出当前目录下的文件并将结果通过管道传递给命令以筛选文件名中包含的文件但在本质上重定向更改的是文件描述符所指向的内容如上文所画的图当执行了操作再执行新建文件那么此时文件描述符为的坑位就指向了而不是可以这么说重定向的魅力在于操作文件描述符将它们连接到不同的位置从而改变了命令的输入和输出源使得命令行操作更加灵活多变举一个例子打开或创建文件并获取文件描述符表示以只写方式打开文件表示如果文件不存在则创建它表示如果文件已存在截断文件长度为即清空文件内容是文件的权限模式这里表示所有者所属组其他用户都有读写权限实际权限会受影响检查文件是否成功打开如果为表示打开文件失败函数用于输出错误信息它会输出传入的字符串以及对应的系统错误提示遇到错误以错误状态码退出程序备份标准输出文件描述符函数用于复制一个现存的文件描述符这里复制标准输出文件描述符其值为返回新的文件描述符它指向与标准输出相同的文件通常是终端屏幕检查复制文件描述符是否成功如果为表示复制失败使用将文件描述符复制到标准输出文件描述符这意味着后续所有向标准输出文件描述符为的输出操作都会改为输出到所指向的文件即现在标准输出已经被重定向到执行语句输出的内容会写入到文件中恢复标准输出通过再次使用将之前备份的标准输出文件描述符复制回标准输出文件描述符这样后续的输出操作又会回到正常的终端屏幕输出了关闭文件描述符关闭用于操作文件的文件描述符释放相关资源关闭备份的标准输出文件描述符同样是释放资源现在标准输出已经恢复继续输出到屏幕这条语句输出的内容会显示在终端屏幕上因为相关函数与系统调用接口对应并且库函数封装系统调用所以本质上访问文件都是通过访问的所以库当中的结构体内部必定封装了缓冲区执行三个输出将信息打印到屏幕上再执行新建一个子进程如果将此文件重定向到一个普通文件中时输出会变成这样仍然只执行一次而和被执行了两次首先需要明白一个概念和库函数有自带的缓冲区而作为系统调用则没有缓冲区这些缓冲区都是用户级缓冲区和都是库函数这个缓冲区由的标准库来提供而是系统调用库函数则是在系统调用的上层是对系统调用的封装所以没有这个缓冲区也不足为奇一般库函数写入文件时是全缓冲进程结束统一刷新的而写入显示器是行缓冲遇到刷新当发生重定向到普通文件时数据的缓冲方式由行缓冲变成了全缓冲那么缓冲区中的数据就不会被立即刷新甚至之后也不会刷新当进程退出之后就会被统一刷新再写入文件当中父进程角度在执行之前代码中按照顺序先调用了此时字符串被放入了标准缓冲区尚未真正输出因为缓冲区未满且没遇到强制刷新等情况接着执行数据也被放入对应的标准缓冲区同样没实际输出再执行由于是系统调用直接将输出到了文件因为标准输出已重定向到该文件这就是为什么输出结果中第一个出现的是当执行函数后父进程继续往下执行在父进程返回时之前标准缓冲区中的数据之前和缓冲的数据会被刷新输出到文件所以会输出和子进程角度子进程复制了父进程的状态包括标准缓冲区的内容是复制不是共享子进程有自己独立的缓冲区副本当子进程继续执行到最后返回之前同样会刷新自己的标准缓冲区把缓冲的和也输出到文件这就导致了后面又出现一次和的输出结果如何管理文件概述在系统中文件系统以一种层次化的树状结构组织和描述所有的文件和目录以根目录为起点所有的文件和目录都从这里开始也许你听过一句话在系统中一切皆为文件这包括了普通文件目录设备文件链接等等并且不同类型的文件具有不同的属性和用途将硬件底层封装为文件并允许进程通过文件指针来进行调用和访问在中硬件设备通常由设备文件来表示这些设备文件位于目录下每个硬件设备都有一个相应的设备文件例如硬盘设备可以表示为串口可以表示为等同时每个进程都有一个文件描述符表它是一个索引到文件的整数数组文件描述符是进程用来访问文件的句柄通常标准输入标准输出和标准错误分别对应文件描述符和进程可以通过系统调用来操作文件例如系统调用用于打开一个文件和用于读取和写入文件数据用于关闭文件进程通过这些系统调用来请求操作文件或设备当进程打开一个文件时操作系统维护一个文件指针或文件偏移量它指示文件中下一个读取或写入操作的位置文件指针可以通过系统调用来移动如可以这么认为系列的函数都是对系统调用的封装方便二次开发在中每个文件都有一个唯一的路径用于描述其在文件系统中的位置路径可以是绝对路径从根目录开始的完整路径或相对路径相对于当前工作目录的路径每个文件和目录都有权限设置这确定了谁可以对其进行读写和执行操作此外每个文件都有一个所有者和所属的用户组支持多种文件系统类型包括等每个文件系统类型都具有不同的特性和性能系统通过系统调用提供了一组用于管理文件和目录这些系统调用包括打开读取写入关闭创建和删除文件以及更改文件属性等以下几点作为了解链接和挂载支持硬链接和符号链接允许多个文件名引用同一个文件此外还支持文件系统挂载使不同的文件系统可以被组合到同一个目录结构中特殊文件系统还包括特殊文件如设备文件用于与硬件设备通信套接字文件用于进程间通信和管道文件用于进程间数据传输文件系统维护系统中有一系列工具用于文件系统维护如用于文件系统检查和修复用于查看磁盘使用情况用于查看磁盘空间等文件系统的文件都存储在磁盘上那么谈文件系统就不能跳过磁盘文件系统将文件数据分成小块通常是扇区或块这些块以逻辑方式组织在磁盘上这样操作系统就可以进行有效地读取和写入当在上进行创建编辑或删除文件的操作时实际上是在磁盘上进行操作文件数据被写入到磁盘的数据块中文件的元数据如被更新以反映文件的更改了解下磁盘的物理结构一块磁盘通常由多个盘面组成每个盘面分为多个磁道而每个磁道又分为多个扇区扇区是磁盘上最小的可寻址存储单元通常为字节或操作系统和文件系统使用扇区来读取和写入数据磁头则是用于读写数据的磁盘表面上的读写头磁头的数量取决于磁盘驱动器的设计不知道大家小时候有没有用过播放英语听力的磁带一圈圈的绕起来和磁盘的结构很像类比一下磁盘也是如此你可以想象磁盘上的磁道是一整条磁带而数据就按照特定的顺序排列在上面可以这么讲磁盘的逻辑结构是线性的而文件数据也线性地分布在上面文件系统是一种在磁盘上创建的组织数据的结构这样使得数据存储访问和管理更加方便磁盘则是实际的存储媒介而文件系统为数据在磁盘上的组织和操作提供了接口和规则以下是文件系统的组成图示以及每个组成部分的主要用途引导块通常位于文件系统之前是文件系统的前导部分引导块的主要目的是引导操作系统从而启动计算机引导块与文件系统的关系在于它是文件系统之前的一部分但不直接与文件系统的组件如超级块表等交互引导块包含有关如何加载操作系统的信息这个引导加载程序负责启动操作系统并在需要时加载文件系统在计算机开机时会先去中寻找自举装入程序通过此程序再找到位于磁盘的引导块将完整的自举程序对入内存完成初始化而则是文件系统根据分区的大小划分为数个每个都有着相同的结构组成可以联想到国家设立省市来实行分级管理超级块包含文件系统的元数据如文件系统大小块大小数量或者一些磁盘数据如磁道数扇区数等它是文件系统的核心信息存储用于初始化和维护文件系统组描述符表包含了关于每个数据块组的信息如块位图位图和表的位置块位图跟踪哪些数据块已经被使用哪些还没有被使用图源王道操作系统强化讲义位图用于跟踪哪些节点已被使用哪些还没有被使用原理图同表存储文件和目录的元数据如文件权限拥有者文件大小等每个文件和目录在表中都有一个对应的条目这点很重要图源王道操作系统强化讲义拿举例号节点存储着某个文件暂称为目录文件的相关数据如的所有者是谁什么时间创建以及该文件占用几个块等从图中可以得到信息共有两块号块和号块数据块存储实际的文件内容和目录结构它包含文件的实际数据以及目录中文件和子目录的引用图源王道操作系统强化讲义还是拿举例如果是一个目录文件那么中就保存了该目录下的所有文件以及其对应的号如果是一个普通文件那么直接存储数据即可综上文件系统遵循着将文件数据和属性分开存放的思想数据通通存在中而文件属性则单独放在表里二者的联系则借助于如何从文件系统角度新建删除文件当需要新建文件时首先会在中寻找一个未使用的索引节点接着在中分配这个索引节点记录文件的元数据信息比如文件名权限等然后会在中寻找一些未使用的数据块也会随着更新最后将文件的数据写入这些数据块中完成文件的创建当需要删除文件时首先会释放文件占用的数据块在中标记这些数据块为未使用状态然后释放文件的索引节点在中标记这个索引节点为未使用状态最后在中删除文件的元数据信息完成文件的删除打开文件文件都在磁盘中进行保存当要打开指定文件时操作系统会将文件包括其与需要的文件内容统统调入内存中如果学习过计算机组成原理相关课程应该不会对结构体感到陌生也就是常说的页或者物理内存页常取大小当文件被调入内存操作系统会通过结构体来对其进行描述和组织一个文件常常会占用多个页页之前可能不连续页的状态及属性标志如锁定脏页等标志位页的引用计数页被映射的次数根据具体情况存储特定相关数据所属的地址空间结构体指针在所属地址空间中的偏移量用于链接到链表空闲页链表相关指针复合页的头部页指针复合页析构函数指针复合页映射计数复合页的阶数所属的内存区域结构体指针每一个都构成内存数组的一部分物理内存从整体上看是一个连续的字节数组为了方便管理内核将物理内存划分为固定大小的页每个页对应一个结构体来进行描述和管理从这个角度看所有的结构体所代表的页就像是连续排列的元素共同构成了一个对整个物理内存进行描述的数组就像普通数组可以通过索引快速定位到特定的元素一样在内存管理中内核可以通过一定的机制将物理页框编号等信息转换为的索引从而快速定位到对应的结构体也就是说只要给定一个物理内存地址内核可以通过计算得到该地址所在页对应的在中的位置更通俗的讲访问内存就是在访问内存数组当应用程序发起对文件的访问请求时操作系统借助文件系统来执行读取操作文件系统首先查找文件的元数据例如以此确定文件在磁盘上的物理位置系统设有页缓存机制它会将文件系统中的数据缓存至内存若所需文件数据已存在于页缓存中则无需从磁盘重新读取若不存在则需从磁盘读取数据并缓存至内存物理内存与磁盘均以作为基本存储单元来存储数据出于效率考量二者之间进行数据交换时亦以为最小操作单位例如对于一台拥有物理内存的计算机以为最小分片单位可划分出约一百万个分片可类比为具有一百万个下标的数组这就是上文提到的内存页数组操作系统通过特定的地址转换方法能够实现虚拟地址与页下标的转换进而精准定位到正确的物理地址空间以存放数据这一过程遵循先描述再组织的设计理念每个的页均由结构体进行描述该结构体中存储着页的各类必要属性信息当一个进程尝试打开文件时如前文所述会在进程对应的文件描述符表中查找对应的指针进程指针数组上文已经提到过分别是这个指针数组的下标从上往下依次指向所代表的三个已打开的文件更具体的说指向各自的结构体而结构体里有指向结构体和结构体的指针例如当打开文件描述符为的文件时文件属性存储在结构体中而文件内容则以特定形式封装于结构体中内部包含了一棵红黑树用于组织和管理与该文件相关的所有页面缓存也就是文件的页缓冲区通过这种树型结构内核可以快速地查找插入和删除页面缓存当需要查找某个文件偏移量对应的页缓存时可以通过红黑树快速定位到相应的结构体区别文件缓冲区和页缓冲区定义文件缓冲区文件缓冲区是一块内存区域用于暂时存放程序和文件之间传输的数据当程序要写入数据到文件时数据先被放入文件缓冲区而不是直接写入文件同样当程序从文件读取数据时数据先从文件读取到缓冲区然后再从缓冲区提供给程序使用例如在语言中使用库函数如等进行文件操作时会涉及文件缓冲区其目的是减少对文件的实际读写次数提高读写效率因为文件的读写操作通常比内存操作慢很多通过缓冲区可以批量处理数据文件的页缓冲区页缓存页缓冲区主要是操作系统层面的概念在操作系统中文件是以页为单位存储在磁盘上的页缓冲区是内存中的一块区域用于缓存从磁盘读取的文件页当程序请求读取文件中的某个部分时如果该部分对应的页已经在页缓冲区中就可以直接从内存中获取而不必从磁盘读取大大提高了文件访问速度同时对于要写入磁盘的文件数据也会先暂存在页缓冲区等合适的时候再写入磁盘这是一种以页为单位的缓存机制通常由操作系统的内存管理子系统和文件系统协同管理区别管理层面和单位不同文件缓冲区通常是在应用程序层面进行管理以字节流等方式来组织和处理数据例如语言中的文件缓冲区程序员可以通过函数手动刷新缓冲区将缓冲区中的数据写入文件它的大小可以在一定程度上由应用程序控制比如通过函数设置缓冲区大小文件的页缓冲区是由操作系统管理的是以页为单位通常页的大小是固定的如等操作系统负责维护页缓冲区中的数据与磁盘文件数据的一致性应用程序一般不能直接控制页缓冲区的具体操作如替换策略等数据范围和用途不同文件缓冲区主要是为了优化单个应用程序对文件的读写操作例如一个文本编辑器在保存文件时会先将用户输入的字符存入文件缓冲区直到缓冲区满或者用户手动保存才会将缓冲区中的内容写入文件文件的页缓冲区是为了提高整个系统对文件的访问效率它缓存的是文件在磁盘上的页这些页可能被多个应用程序共享访问例如不同的进程可能都需要读取同一个配置文件的部分内容这些内容所在的页就可能被缓存在页缓冲区中供多个进程使用联系协同工作提高性能两者都是为了提高文件操作的效率文件缓冲区中的数据最终可能会通过系统调用传递到页缓冲区然后再写入磁盘例如当应用程序调用函数将数据写入文件时数据先进入文件缓冲区当文件缓冲区被刷新或者满了之后数据会通过操作系统的文件写入机制进入页缓冲区如果数据对应的磁盘文件页不在页缓冲区中最后再写入磁盘它们在数据从应用程序到磁盘存储的过程中起到了层层缓冲的作用减少了频繁的磁盘操作软硬链接当使用命令时会看到类似下图的信息月从左到右分别是模式硬链接数文件所有者组大小最后修改时间是文件系统中的数据结构包含着文件的属性信息硬链接指一个文件可以有多个文件名指向同一个作为文件系统中的数据结构包含了文件的元数据比如权限所有者文件大小等以及指向实际数据块的指针所有硬链接文件都指向同一个因此它们实际上共享相同的数据块删除任意一个硬链接并不影响其他硬链接只有当所有链接都被删除时的引用计数才会变为零文件系统才会释放相关的数据块但硬链接也有自己的缺点硬链接不能跨越文件系统只能在同一文件系统内创建也不能对目录创建硬链接不能对目录创建硬链接的主要原因是防止文件系统的树形结构出现循环举个例子你在目录下查找文件但同时目录中存在目录目录是指向目录的硬链接这会导致什么后果硬链接到其他文件或目录和实际上指向同一个目录这就导致了在进行遍历查找时可能会陷入循环的问题创建硬链接空的文件夹引用计数是但空的文件夹其实并不是空的其中含有两个隐藏的文件和这两个文件分别指向了本目录和上层目录都是硬链接如果一个目录引用计数是那就代表这个目录下还有个子目录与硬链接相对应的就是软链接软链接可以类比成系统下的快捷方式软链接是一种特殊类型的文件所以他有自己的它创建一个指向另一个文件或目录的符号链接软链接类似于快捷方式它只包含目标文件的路径信息而不是实际的数据如果源文件或目录被删除或移动软链接将失效创建软链接',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-25 21:17:08',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E9%B8%AD%E5%AD%90%E8%B5%B0%E8%B7%AF.gif"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/null" title="demo"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="project" alt="demo"/><span class="back-menu-item-text">demo</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">ChengZi</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> Search</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">February 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">December 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/" itemprop="url">linux</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>文件系统</span></a><a class="article-meta__tags" href="/tags/IO/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>IO</span></a></span></div></div><h1 class="post-title" itemprop="name headline">IO与文件系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-12-18T03:54:29.000Z" title="Created 2024-12-18 11:54:29">2024-12-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-25T13:17:08.125Z" title="Updated 2024-12-25 21:17:08">2024-12-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为四川"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>四川</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734494164320.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/12/18/linux-file%20system/"><header><a class="post-meta-categories" href="/categories/linux/" itemprop="url">linux</a><a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url">文件系统</a><a href="/tags/IO/" tabindex="-1" itemprop="url">IO</a><h1 id="CrawlerTitle" itemprop="name headline">IO与文件系统</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">chengzi</span><time itemprop="dateCreated datePublished" datetime="2024-12-18T03:54:29.000Z" title="Created 2024-12-18 11:54:29">2024-12-18</time><time itemprop="dateCreated datePublished" datetime="2024-12-25T13:17:08.125Z" title="Updated 2024-12-25 21:17:08">2024-12-25</time></header><h1 id="回顾c语言的文件操作"><a href="#回顾c语言的文件操作" class="headerlink" title="回顾c语言的文件操作"></a>回顾c语言的文件操作</h1><h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><p>简单的回顾下在c语言中，我们是如何使用相关的文件接口的。<br>C语言提供了一套强大而灵活的文件接口，使得程序能够在磁盘上读取和写入数据。这个文件接口是操作系统提供的API（应用程序编程接口）的一部分，这里则是简单介绍一下C语言中常用的文件接口，包括文件的打开、读取、写入、关闭等操作。</p>
<blockquote>
<p>打开文件</p>
</blockquote>
<p>在C语言中，要对一个文件进行操作，首先需要<code>将其打开</code>。这可以通过使用fopen函数来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fptr;  <span class="comment">// 声明一个文件指针</span></span><br><span class="line">fptr = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">// 打开名为example.txt的文件以供读取</span></span><br></pre></td></tr></table></figure>

<p>声明了一个文件指针fptr，使用fopen函数将名为example.txt的文件以<code>只读</code>模式打开，函数返回一个指向该文件的指针。</p>
<blockquote>
<p>读取文件</p>
</blockquote>
<p>一旦文件打开成功，我们可以使用fread函数来读取文件内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];  <span class="comment">// 声明一个用于存储数据的缓冲区</span></span><br><span class="line">fread(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">100</span>, fptr);  <span class="comment">// 从文件中读取100个字符到缓冲区中</span></span><br></pre></td></tr></table></figure>

<p>使用fread函数从打开的文件中读取了100个字符，然后将其存储到名为buffer的字符数组中。</p>
<blockquote>
<p>写入文件</p>
</blockquote>
<p>如果需要将数据写入文件，可以使用fwrite函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">fwrite(data, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(data), fptr);  <span class="comment">// 将数据写入文件</span></span><br></pre></td></tr></table></figure>

<p>将字符串”Hello, World!”写入到已经打开的文件中。</p>
<blockquote>
<p>关闭文件</p>
</blockquote>
<p>在完成文件操作后，应该<code>及时关闭</code>文件，以释放资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(fptr);  <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误处理</p>
</blockquote>
<p>可以通过检查函数的<code>返回值</code>来判断文件是否成功打开或操作是否成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *fptr;</span><br><span class="line">fptr = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c语言的输入输出流"><a href="#c语言的输入输出流" class="headerlink" title="c语言的输入输出流"></a>c语言的输入输出流</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line"> fwrite(str, <span class="built_in">strlen</span>(str), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello linux\n&quot;</span>);</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fwrite函数将字符串 “hello world\n” 写入<code>标准输出</code>。fwrite 函数的参数依次为字符串的指针（str），字符串的长度（strlen(str)），写入次数（1），和目标输出（stdout）。<br>printf 函数来打印 “hello linux”。printf 函数将格式化字符串写入标准输出。<br>fprintf 函数来打印 “hello world”。fprintf 函数的参数依次为目标输出（stdout）和格式化字符串。</p>
<p>上面三个函数都提到了<code>stdout</code>，那么stdout到底是什么？</p>
<blockquote>
<p>在C语言中，stdout是<code>指向标准输出的文件指针</code>。标准输出是一个特殊的<code>文件流</code>，通常用于将程序的输出<code>打印</code>到屏幕上。<br>在这个函数中，使用了不同的输出函数来将字符串打印到标准输出上。fwrite、printf和fprintf都可以接受<code>文件指针作为参数</code>，用于指定输出的目标。<br>使用stdout可以方便地将输出打印到屏幕上，而不需要指定具体的文件或设备。这样，程序的输出就可以在控制台上可见，并且可以通过重定向等方式将输出保存到文件中。</p>
</blockquote>
<p>C语言默认会打开<code>三个</code>输入输出流，分别是<code>stdin, stdout, stderr</code>。<br>stdout已经在上文解释过，当涉及到<code>输入和错误输出</code>时，C语言提供了两个额外的标准流：stdin和stderr。</p>
<p>stdin是指向<code>标准输入</code>的文件指针。标准输入用于<code>接收来自用户的输入</code>，通常是通过<code>键盘</code>输入。例如，使用scanf函数可以从标准输入中读取用户的输入。</p>
<p>stderr是指向<code>标准错误</code>的文件指针。标准错误用于<code>输出程序的错误消息或其他诊断信息</code>。与标准输出不同，标准错误的输出通常被发送到屏幕上的错误流中，而不会被重定向到文件。例如，使用fprintf(stderr, …)函数可以将错误消息输出到标准错误流。</p>
<h1 id="linux下的文件操作"><a href="#linux下的文件操作" class="headerlink" title="linux下的文件操作"></a>linux下的文件操作</h1><h2 id="系统文件io"><a href="#系统文件io" class="headerlink" title="系统文件io"></a>系统文件io</h2><p>除了上面提到的C语言来进行文件操作，也可以通过<code>系统调用</code>来对文件进行读或者写等等操作。<br>当使用系统调用进行文件I&#x2F;O时，有几个常用的调用：</p>
<ol>
<li>open()：用于打开文件。它接受文件路径和一些标志作为参数，并返回一个文件描述符（file descriptor），表示打开的文件。</li>
<li>read()：用于从文件中读取数据。它接受文件描述符、数据缓冲区和读取字节数作为参数，并返回实际读取的字节数。</li>
<li>write()：用于向文件中写入数据。它接受文件描述符、数据缓冲区和写入字节数作为参数，并返回实际写入的字节数。</li>
<li>close()：用于关闭文件。它接受文件描述符作为参数，并在操作完成后关闭文件。</li>
</ol>
<blockquote>
<p>打开一个名为 “example.txt” 的文件（如果不存在则创建），然后写入字符串 “Hello, world!”。最后关闭文件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理打开文件失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理写入文件失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四个常用接口介绍"><a href="#四个常用接口介绍" class="headerlink" title="四个常用接口介绍"></a>四个常用接口介绍</h2><blockquote>
<p>open</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>pathname: 要打开或创建的目标文件<br>flags: 打开文件时，可以传入多个参数选项，用下面的一个或者多个常量进行“或”运算，构成flags。<br><br>参数:   <br><br>O_RDONLY: 只读打开。 <br><br>O_WRONLY: 只写打开。 <br><br>O_RDWR : 读，写打开。 <br><br>这三个常量，必须指定一个且只能指定一个。<br><br>O_CREAT : 若文件不存在，则创建它。  <br><br>O_APPEND: 追加写。 <br><br>返回值： <br><br>成功：新打开的文件描述符（什么是文件描述符会在下文讲）。 <br><br>失败：-1  <br><br>mode参数用于指定新创建文件的权限模式。 <br></p>
<blockquote>
<p>close</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数用于关闭文件。它接受文件描述符（fd）作为参数，在操作完成后关闭文件。<br>参数：<br>fd：要关闭的文件描述符。<br>返回值：<br>成功：0。<br>失败：-1。</p>
<blockquote>
<p>write</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数用于向文件中写入数据。它接受文件描述符（fd），数据缓冲区指针（buf）和要写入的字节数（count）作为参数。<br>参数：<br>fd：要写入的文件描述符。<br>buf：指向要写入的数据的缓冲区的指针。<br>count：要写入的字节数。<br>返回值：<br>成功：实际写入的字节数。<br>失败：-1。</p>
<blockquote>
<p>read</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数用于从文件中读取数据。它接受文件描述符（fd），数据缓冲区指针（buf）和要读取的最大字节数（count）作为参数。</p>
<p>参数：<br>fd：要读取的文件描述符。<br>buf：指向存储读取数据的缓冲区的指针。<br>count：要读取的最大字节数。<br>返回值：<br>成功：实际读取的字节数。<br>失败：-1。</p>
<blockquote>
<p>接口演示</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理文件打开失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理读取文件失败的情况</span></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取的数据</span></span><br><span class="line">    write(STDOUT_FILENO, buffer, bytes_read);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上文很多地方都出现了fd和文件描述符的概念（二者是一个东西），那么什么是文件描述符呢？</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>在文章开篇时，提到了c语言会打开三个输入输出流，那是如何得知这三个流被打开了呢？</p>
<p>文件描述符是一个<code>非负整数</code>，用于<code>唯一标识</code>一个打开的文件或I&#x2F;O流。它是一个抽象的概念，可以是文件、管道、套接字等。</p>
<p>标准文件描述符</p>
<blockquote>
<p>Linux系统通常会为每个进程自动分配三个标准文件描述符：<br>0（stdin）：标准输入，通常用于从键盘或其他输入设备读取数据。<br>1（stdout）：标准输出，通常用于向终端或其他输出设备输出数据。<br>2（stderr）：标准错误，通常用于输出错误消息。<br>0,1,2对应的物理设备一般是：<code>键盘，显示器，显示器</code>。</p>
</blockquote>
<p>文件描述符主要用于进行文件和I&#x2F;O操作，通常通过以下系统调用来操作文件描述符：</p>
<blockquote>
<p>open()：打开一个文件并返回一个文件描述符。<br>close()：关闭一个文件描述符，释放相关资源。<br>read()：从文件描述符中读取数据。<br>write()：向文件描述符中写入数据。<br>lseek()：移动文件描述符的读&#x2F;写位置。<br>dup()和dup2()：复制文件描述符，创建一个新的文件描述符与之关联。</p>
</blockquote>
<p>也就是说，可以这样输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="type">ssize_t</span> s = read(<span class="number">0</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> buffer[s] = <span class="number">0</span>;</span><br><span class="line"> write(<span class="number">1</span>, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line"> write(<span class="number">2</span>, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实现了从标准输入读取数据，并将其写入标准输出和标准错误。<br>当打开一个文件时，操作系统在内存中要创建相应的数据结构来<code>描述目标文件</code>(比如文件大小，在磁盘位置，打开计数等文件属性)，也就是file结构体来表示并描述一个已经打开的文件对象。而如何管理一个个file结构体呢？Linux为其创建了文件描述符表(图中的File Struct)，里面存储了一个指针数组，每个元素都指向一个已经打开的文件。<br>如图，当进程执行open系统调用打开文件时，当前进程结构中有一个指针<code>*files</code>, 指向一张<code>文件描述符表</code>files_struct(每个进程有自己的表),该表的指针数组中每个元素都是一个指向打开文件的指针。下标0指向默认的stdin文件，下标1指向stdout文件，下标2指向stderr文件。所以，<code>文件描述符就是该数组的下标</code>。只要有文件描述符，就可以找到对应的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+         +------------------------+</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   Process (进程)  |         |   File Struct (file)   |</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   +------------+  |         |   +----------------+   |</span><br><span class="line">|   |  *files    |  |         |   | File*  0       |   |</span><br><span class="line">|   |  (指针)    |----------&gt; |   | File*  1       |   |</span><br><span class="line">|   +------------+  |         |   | File*  2       |   |</span><br><span class="line">|                   |         |   +----------------+   |                  </span><br><span class="line">+-------------------+         +------------------------+</span><br><span class="line">  </span><br><span class="line">0,1,2分别是这个指针数组的下标，从上往下分别指向stdin，stdout，stderr所代表的三个已打开的文件。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上图的File*列表仅存储打开的文件，也就是说，如果此时新建一个文件，那么分配给他的下标就会是3，如果在创建此文件前关闭了1，那么此文件的文件描述符就会被分配为1。这就是Linux系统下文件描述符基本的分配规则。</p>
</blockquote>
<p>当关闭掉文件描述符1:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> close(<span class="number">1</span>);</span><br><span class="line"> <span class="type">int</span> fd = open(<span class="string">&quot;file&quot;</span>, O_WRONLY|O_CREAT, <span class="number">00644</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"> </span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c语言printf函数底层封装的输出接口仍然是下标1，哪怕stdout被关闭，系统也只认识1，他要做的就是将需要打印的内容输出到1代表的这个文件。这也是linux环境下文件管理的一个显著特征，层层封装，再由系统统一调用，有点多态的意思在里面。</p>
<blockquote>
<p>将原本该打印到屏幕的内容打印到file里，这就叫重定向。</p>
</blockquote>
<p>文件描述符的重定向允许将一个文件描述符与另一个文件或设备相关联。例如，可以使用&gt;将命令的输出重定向到文件，或使用&lt;将文件内容作为输入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出重定向：将命令的标准输出保存到文件。</span></span><br><span class="line"><span class="comment">//将 &quot;Hello, World!&quot; 写入到文件 output.txt</span></span><br><span class="line">echo <span class="string">&quot;Hello, World!&quot;</span> &gt; output.txt</span><br><span class="line"><span class="comment">//输入重定向：从文件中读取数据作为命令的标准输入。</span></span><br><span class="line"><span class="comment">//从文件 input.txt 中读取数据并将其作为命令的输入</span></span><br><span class="line">cat &lt; input.txt</span><br><span class="line"><span class="comment">//追加：将命令的标准输出追加到文件末尾。</span></span><br><span class="line"><span class="comment">//追加 &quot;Hello again!&quot; 到文件 output.txt</span></span><br><span class="line">echo <span class="string">&quot;Hello again!&quot;</span> &gt;&gt; output.txt</span><br><span class="line"><span class="comment">//错误输出重定向：将命令的标准错误输出保存到文件。</span></span><br><span class="line"><span class="comment">//将命令的标准错误输出保存到 error.log 文件</span></span><br><span class="line">ls non_existent_directory <span class="number">2</span>&gt; error.<span class="built_in">log</span>  </span><br><span class="line"><span class="comment">//标准输出和标准错误重定向到同一文件：</span></span><br><span class="line"><span class="comment">//将标准输出和标准错误输出都重定向到同一个文件</span></span><br><span class="line">ls non_existent_directory &gt; output_and_error.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="comment">//使用管道：将一个命令的输出传递给另一个命令的输入。</span></span><br><span class="line"><span class="comment">//列出当前目录下的文件，并将结果通过管道传递给 grep 命令以筛选文件名中包含 &quot;example&quot; 的文件</span></span><br><span class="line">ls | grep <span class="string">&quot;example&quot;</span></span><br></pre></td></tr></table></figure>

<p>但在本质上，重定向更改的是文件描述符所指向的内容。如上文所画的图，当执行了close(1)操作，再执行新建file文件，那么此时文件描述符为1的坑位就指向了file而不是stdout。<br>可以这么说，重定向的魅力在于<code>操作文件描述符</code>，将它们连接到不同的位置，从而<code>改变了命令的输入和输出源</code>，使得命令行操作更加灵活多变。<br>举一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开或创建文件 &quot;output.txt&quot;，并获取文件描述符</span></span><br><span class="line">    <span class="comment">// O_WRONLY 表示以只写方式打开文件</span></span><br><span class="line">    <span class="comment">// O_CREAT 表示如果文件不存在则创建它</span></span><br><span class="line">    <span class="comment">// O_TRUNC 表示如果文件已存在，截断文件长度为0（即清空文件内容）</span></span><br><span class="line">    <span class="comment">// 0666 是文件的权限模式，这里表示所有者、所属组、其他用户都有读写权限（实际权限会受umask影响）</span></span><br><span class="line">    <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查文件是否成功打开，如果file_fd为 -1，表示打开文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (file_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// perror函数用于输出错误信息，它会输出传入的字符串以及对应的系统错误提示</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="comment">// 遇到错误，以错误状态码1退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 备份标准输出文件描述符</span></span><br><span class="line">    <span class="comment">// dup函数用于复制一个现存的文件描述符，这里复制标准输出文件描述符（其值为1）</span></span><br><span class="line">    <span class="comment">// 返回新的文件描述符（stdout_backup），它指向与标准输出相同的文件（通常是终端屏幕）</span></span><br><span class="line">    <span class="type">int</span> stdout_backup = dup(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查复制文件描述符是否成功，如果stdout_backup为 -1，表示复制失败</span></span><br><span class="line">    <span class="keyword">if</span> (stdout_backup == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用dup2将文件描述符 &quot;file_fd&quot; 复制到标准输出文件描述符 &quot;1&quot;</span></span><br><span class="line">    <span class="comment">// 这意味着后续所有向标准输出（文件描述符为1）的输出操作，都会改为输出到file_fd所指向的文件（即output.txt）</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(file_fd, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在标准输出已经被重定向到 &quot;output.txt&quot;，执行printf语句，输出的内容会写入到output.txt文件中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to output.txt\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复标准输出</span></span><br><span class="line">    <span class="comment">// 通过再次使用dup2，将之前备份的标准输出文件描述符（stdout_backup）复制回标准输出（文件描述符1）</span></span><br><span class="line">    <span class="comment">// 这样后续的输出操作又会回到正常的终端屏幕输出了</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(stdout_backup, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="comment">// 关闭用于操作output.txt文件的文件描述符file_fd，释放相关资源</span></span><br><span class="line">    close(file_fd);</span><br><span class="line">    <span class="comment">// 关闭备份的标准输出文件描述符stdout_backup，同样是释放资源</span></span><br><span class="line">    close(stdout_backup);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在标准输出已经恢复，继续输出到屏幕，这条printf语句输出的内容会显示在终端屏幕上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be shown on the screen\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为IO相关函数与系统调用接口对应，并且库函数封装系统调用，所以本质上，访问文件都是通过<code>fd</code>访问的。所以C库当中的FILE结构体内部，<code>必定封装了fd</code>。</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p1=<span class="string">&quot;fwrite\n&quot;</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p2=<span class="string">&quot;write\n&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;printf\n&quot;</span>);</span><br><span class="line"> fwrite(p1, <span class="built_in">strlen</span>(p1), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line"> write(<span class="number">1</span>, p2, <span class="built_in">strlen</span>(p2));</span><br><span class="line"> fork();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行三个输出，将信息打印到屏幕上，再执行fork新建一个子进程。<br>如果将此文件重定向到一个普通文件中时:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"> <span class="keyword">if</span> (dup2(file_fd, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p1=<span class="string">&quot;fwrite\n&quot;</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *p2=<span class="string">&quot;write\n&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;printf\n&quot;</span>);</span><br><span class="line"> fwrite(p1, <span class="built_in">strlen</span>(p1), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line"> write(<span class="number">1</span>, p2, <span class="built_in">strlen</span>(p2));</span><br><span class="line"> fork();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出会变成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write</span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">fwrite</span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">fwrite</span><br></pre></td></tr></table></figure>
<p>write仍然只执行一次，而printf和fwrite被执行了两次。</p>
<p>首先，需要明白一个概念:printf和fwrite库函数有自带的缓冲区，而write作为系统调用则没有缓冲区。<br>这些缓冲区都是<code>用户级</code>缓冲区。<br>printf和fwrite都是库函数，这个缓冲区由C的标准库来提供。而write是系统调用，库函数则是在系统调用的“上层”， 是对系统调用的“封装”，所以write没有这个缓冲区也不足为奇。 <br><br>一般C库函数写入文件时是<code>全缓冲</code>(进程结束统一刷新)的，而写入显示器是<code>行缓冲</code>(遇到\n刷新)。当发生重定向到普通文件时，数据的缓冲方式由行缓冲变成了全缓冲。那么缓冲区中的数据就不会被立即刷新，甚至fork之后也不会刷新。当<code>进程退出</code>之后，就会被统一刷新，再写入文件当中。</p>
<blockquote>
<p>父进程角度</p>
</blockquote>
<p>在执行 fork 之前，代码中按照顺序先调用了 printf(“printf\n”);，此时 “printf\n” 字符串被放入了标准 I&#x2F;O 缓冲区，尚未真正输出（因为缓冲区未满且没遇到强制刷新等情况）。<br>接着执行fwrite(p1, strlen(p1), 1, stdout);，数据也被放入 fwrite 对应的标准 I&#x2F;O 缓冲区，同样没实际输出。<br>再执行 write(1, p2, strlen(p2));，由于write是系统调用，直接将 “write\n” 输出到了 output.txt 文件（因为标准输出已重定向到该文件），这就是为什么输出结果中第一个出现的是”write”。<br>当执行 fork 函数后，父进程继续往下执行，在父进程返回时（return 0; 之前），标准 I&#x2F;O 缓冲区中的数据（之前 printf 和 fwrite 缓冲的数据）会被刷新输出到 output.txt 文件，所以会输出 “printf” 和 “fwrite”。</p>
<blockquote>
<p>子进程角度</p>
</blockquote>
<p>子进程复制了父进程的状态，包括标准 I&#x2F;O 缓冲区的内容（是复制，不是共享，子进程有自己独立的缓冲区副本），当子进程继续执行到最后返回（return 0; 之前），同样会刷新自己的标准 I&#x2F;O 缓冲区，把缓冲的 “printf” 和 “fwrite” 也输出到 output.txt 文件，这就导致了后面又出现一次 “printf” 和 “fwrite” 的输出结果。</p>
<h1 id="linux如何管理文件"><a href="#linux如何管理文件" class="headerlink" title="linux如何管理文件"></a>linux如何管理文件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Linux系统中，文件系统以一种层次化的<code>树状结构</code>组织和描述所有的文件和目录。以<code>根目录</code>为起点，所有的文件和目录都从这里开始。<br>也许你听过一句话，<code>在Linux系统中，一切皆为文件</code>。这包括了普通文件、目录、设备文件、链接等等，并且不同类型的文件具有不同的属性和用途。<br>Linux将<code>硬件底层封装为文件</code>，并允许进程通过<code>文件指针</code>来进行调用和访问。<br>在Linux中，硬件设备通常由设备文件来表示，这些设备文件位于&#x2F;dev目录下。每个硬件设备都有一个相应的设备文件，例如硬盘设备可以表示为&#x2F;dev&#x2F;sda，串口可以表示为&#x2F;dev&#x2F;ttyS0等。<br>同时，每个进程都有一个文件描述符表，它是一个索引到文件的整数数组。文件描述符是进程用来访问文件的句柄。通常，标准输入、标准输出和标准错误分别对应文件描述符0、1和2。<br>进程可以通过系统调用来操作文件。例如，open系统调用用于打开一个文件，read和write用于读取和写入文件数据，close用于关闭文件。进程通过这些系统调用来请求操作文件或设备。<br>当进程打开一个文件时，操作系统维护一个文件指针（或文件偏移量），它指示文件中下一个读取或写入操作的位置。文件指针可以通过系统调用来移动，如lseek。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B61.png'>
>可以这么认为，f#系列的函数，都是对系统调用的封装，方便二次开发。

<p>在Linux中，每个文件都有一个<code>唯一的路径</code>，用于描述其在文件系统中的位置。路径可以是绝对路径（从根目录开始的完整路径）或相对路径（相对于当前工作目录的路径）。每个文件和目录都有权限设置，这确定了谁可以对其进行读、写和执行操作。此外，每个文件都有一个<code>所有者和所属的用户组</code>。<br>Linux支持多种文件系统类型，包括ext4、XFS、btrfs等。每个文件系统类型都具有不同的特性和性能。<br>Linux系统通过<code>系统调用</code>提供了一组API，用于<code>管理文件和目录</code>。这些系统调用包括打开、读取、写入、关闭、创建和删除文件，以及更改文件属性等。<br>以下几点作为了解：<br>链接和挂载： Linux支持硬链接和符号链接，允许多个文件名引用同一个文件。此外，Linux还支持文件系统挂载，使不同的文件系统可以被组合到同一个目录结构中。<br>特殊文件： Linux系统还包括特殊文件，如设备文件（用于与硬件设备通信）、套接字文件（用于进程间通信）和管道文件（用于进程间数据传输）。<br>文件系统维护： Linux系统中有一系列工具用于文件系统维护，如fsck用于文件系统检查和修复，du用于查看磁盘使用情况，df用于查看磁盘空间等。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>linux的文件都存储在磁盘上，那么谈文件系统就不能跳过磁盘。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B62.png'> <br><br>文件系统将文件数据分成小块（通常是扇区或块），这些块以逻辑方式组织在磁盘上，这样操作系统就可以进行有效地读取和写入。<br>当在Linux上进行创建、编辑或删除文件的操作时，实际上是在磁盘上进行操作。文件数据被写入到磁盘的数据块中，文件的元数据（如inode）被更新以反映文件的更改。</p>
<p>了解下磁盘的物理结构。</p>
<blockquote>
<p>一块磁盘通常由多个盘面（Platters）组成，每个盘面分为多个磁道（Tracks），而每个磁道又分为多个扇区（Sectors）。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B63.png'>

<p>扇区是磁盘上最小的可寻址存储单元，通常为512字节或4KB。<br>操作系统和文件系统使用扇区来读取和写入数据。<br>磁头则是用于读写数据的磁盘表面上的读&#x2F;写头。磁头的数量取决于磁盘驱动器的设计。</p>
<p>不知道大家小时候有没有用过播放英语听力的磁带，一圈圈的绕起来，和磁盘的结构很像。类比一下，磁盘也是如此，你可以想象磁盘上的磁道是一整条<code>磁带</code>，而数据就按照特定的顺序排列在上面。可以这么讲，磁盘的逻辑结构是<code>线性</code>的。而文件数据也线性地分布在上面。</p>
<blockquote>
<p>文件系统是一种在磁盘上创建的组织数据的结构，这样使得数据存储、访问和管理更加方便。磁盘则是实际的存储媒介，而文件系统为数据在磁盘上的组织和操作提供了接口和规则。</p>
</blockquote>
<p>以下是文件系统的组成图示以及每个组成部分的主要用途：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%96%87%E4%BB%B64.png'></p>
<p>引导块(Boot Block)通常位于文件系统<code>之前</code>，是文件系统的前导部分。引导块的主要目的是<code>引导</code>操作系统，从而启动计算机。引导块与文件系统的关系在于它是文件系统之前的一部分，但不直接与文件系统的组件（如超级块、inode 表等）交互。引导块包含有关如何加载操作系统的信息，这个引导加载程序负责启动操作系统，并在需要时加载文件系统。在计算机开机时，会先去ROM中寻找自举装入程序，通过此程序再找到位于磁盘的引导块，将<code>完整的自举程序</code>对入内存，完成初始化。</p>
<p>而Block Group则是文件系统根据分区的大小划分为数个Block Group。每个Block Group都有着相同的结构组成。可以联想到国家设立省市来实行分级管理。</p>
<p>Superblock: 超级块包含文件系统的元数据，如文件系统大小、块大小、inode 数量或者一些磁盘数据，如磁道数，扇区数等。它是文件系统的核心信息存储，用于初始化和维护文件系统。</p>
<p>Group Descriptor Table (GDT): 组描述符表包含了关于每个数据块组(data blocks)的信息，如块位图、inode 位图和inode 表的位置。</p>
<p>Block Bitmaps: 块位图跟踪哪些数据块已经被使用，哪些还没有被使用。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/a181eeae1b6c82ba5e2528158b4c015.jpg'>  [图源王道操作系统强化讲义]<br><br>Inode Bitmaps: inode 位图用于跟踪哪些inode节点已被使用，哪些还没有被使用。原理图同Block Bitmaps。</p>
<p>Inode Table: inode 表存储文件和目录的元数据，如文件权限、拥有者、文件大小等。<code>每个文件和目录在inode表中都有一个对应的inode条目</code>（这点很重要）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/aa184653c1dbbcec3301f5e998393cc.jpg'>
[图源王道操作系统强化讲义] <br>
拿inode1举例,inode1号节点存储着某个文件(暂称为目录文件A)的相关数据，如A的所有者是谁，什么时间创建，以及该文件占用几个块等。从图中可以得到信息，A共有两块，6号块和7号块。

<p>Data Blocks: 数据块存储<code>实际的文件内容和目录结构</code>。它包含文件的实际数据，以及目录中文件和子目录的引用。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/d28ccc7052d925836418693cb52f916.jpg'><br>[图源王道操作系统强化讲义] <br><br>还是拿A举例，A如果是一个目录文件，那么A中就保存了该目录下的所有文件以及其对应的inode号。<br>如果A是一个普通文件，那么直接存储数据即可。</p>
<p>综上，文件系统遵循着将文件数据和属性<code>分开存放</code>的思想。数据通通存在data blocks中，而文件属性则单独放在inode表里。二者的联系则借助于GDT。</p>
<blockquote>
<p>如何从文件系统角度新建，删除文件？</p>
</blockquote>
<p>当需要新建文件时，首先会在Inode Bitmap中寻找一个<code>未使用</code>的索引节点。接着在Inode Table中分配这个索引节点，记录文件的元数据信息，比如文件名、权限等。然后会在Block Bitmap中寻找一些未使用的数据块（block Bitmaps也会随着更新）。最后，将文件的数据写入这些数据块中，完成文件的创建。</p>
<p>当需要删除文件时，首先会释放文件占用的数据块，在Block Bitmap中标记这些数据块为未使用状态。<br>然后释放文件的索引节点，在Inode Bitmap中标记这个索引节点为未使用状态。最后，在Inode Table中删除文件的元数据信息，完成文件的删除。</p>
<blockquote>
<p>打开文件</p>
</blockquote>
<p>文件都在磁盘中进行保存，当要打开指定文件时，操作系统会将文件(包括其inode与需要的文件内容)统统调入内存中。如果学习过计算机组成原理相关课程，应该不会对结构体page感到陌生，page也就是常说的<code>页</code>或者物理内存页，常取大小4KB。当文件被调入内存，操作系统会通过page结构体来对其进行描述和组织。一个文件常常会占用多个页(页之前可能不连续)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;         <span class="comment">/* 页的状态及属性标志，如锁定、脏页等标志位 */</span></span><br><span class="line">    <span class="type">atomic_t</span> _count;             <span class="comment">/* 页的引用计数 */</span></span><br><span class="line">    <span class="type">atomic_t</span> _mapcount;          <span class="comment">/* 页被映射的次数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;       <span class="comment">/* 根据具体情况存储特定相关数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>  <span class="comment">/* 所属的地址空间结构体指针 */</span></span><br><span class="line">    <span class="type">pgoff_t</span> index;               <span class="comment">/* 在所属地址空间中的偏移量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>        <span class="comment">/* 用于链接到LRU链表 */</span></span><br><span class="line">    <span class="type">void</span> *freelist;              <span class="comment">/* 空闲页链表相关指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head;  <span class="comment">/* 复合页的头部页指针 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_dtor;  <span class="comment">/* 复合页析构函数指针 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_mapcount;  <span class="comment">/* 复合页映射计数 */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> compound_order;  <span class="comment">/* 复合页的阶数 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>           <span class="comment">/* 所属的内存区域结构体指针 */</span></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>每一个struct page都构成内存数组(struct page mem_array[])的一部分！</strong><br>物理内存从整体上看是一个连续的字节数组，为了方便管理，内核将物理内存划分为固定大小的页，每个页对应一个 struct page 结构体来进行描述和管理。从这个角度看，所有的 struct page 结构体所代表的页，就像是连续排列的元素，共同构成了一个对整个物理内存进行描述的数组。<br>就像普通数组可以通过索引快速定位到特定的元素一样，在内存管理中，内核可以通过一定的机制将物理页框编号（PFN）等信息转换为 struct page mem_array[] 的索引，从而快速定位到对应的 struct page 结构体。也就是说只要给定一个物理内存地址，内核可以通过计算得到该地址所在页对应的 struct page 在 mem_array 中的位置，更通俗的讲，<code>访问内存就是在访问内存page数组</code>。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734848314495.png'></p>
<p>当应用程序发起对文件的访问请求时，操作系统借助文件系统来执行读取操作。文件系统首先查找文件的元数据，例如 inode，以此确定文件在磁盘上的物理位置。Linux 系统设有页缓存（Page Cache）机制，它会将文件系统中的数据缓存至内存。若所需文件数据已存在于页缓存中，则无需从磁盘重新读取；若不存在，则需从磁盘读取数据并缓存至内存。</p>
<p>物理内存与磁盘均以 4KB 作为基本存储单元来存储数据，出于效率考量，二者之间进行数据交换时亦以 4KB 为最小操作单位。例如，对于一台拥有 4GB 物理内存的计算机，以 4KB 为最小分片单位，可划分出约一百万个分片（可类比为具有一百万个下标的数组），这就是上文提到的内存页数组。操作系统通过特定的地址转换方法，能够实现虚拟地址与页下标的转换，进而精准定位到正确的物理地址空间以存放数据。这一过程遵循“先描述再组织”的设计理念，每个 4KB 的页均由 struct page 结构体进行描述，该结构体中存储着页的各类必要属性信息。</p>
<p>当一个进程尝试打开文件时，如前文所述，会在进程对应的文件描述符表中查找对应的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+         +------------------------+</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   Process (进程)  |         |   File Struct (file)   |</span><br><span class="line">|                   |         |                        |</span><br><span class="line">|   +------------+  |         |   +----------------+   |</span><br><span class="line">|   |  *files    |  |         |   | File*  0       |   |</span><br><span class="line">|   |  (指针数组) |----------&gt; |   | File*  1       |   |</span><br><span class="line">|   +------------+  |         |   | File*  2       |   |</span><br><span class="line">|                   |         |   +----------------+   |                  </span><br><span class="line">+-------------------+         +------------------------+</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>上文已经提到过，0,1,2 分别是这个指针数组的下标，从上往下依次指向 stdin，stdout，stderr 所代表的三个已打开的文件。更具体的说指向各自的struct file结构体。而file结构体里有指向inode结构体和address_space结构体的指针。<br>例如，当打开文件描述符fd为7的文件时，文件属性存储在 inode 结构体中，而文件内容则以特定形式封装于 address_space 结构体中。struct address_space 内部包含了一棵红黑树page_tree，用于组织和管理与该文件相关的所有页面缓存(也就是文件的页缓冲区)。通过这种树型结构，内核可以快速地查找、插入和删除页面缓存。当需要查找某个文件偏移量对应的页缓存时，可以通过红黑树快速定位到相应的 struct page 结构体。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1734850251487.png'></p>
<p><strong>区别文件缓冲区和页缓冲区</strong></p>
<ol>
<li><strong>定义</strong><ul>
<li><strong>文件缓冲区</strong>：<ul>
<li>文件缓冲区是一块内存区域，用于暂时存放程序和文件之间传输的数据。当程序要写入数据到文件时，数据先被放入文件缓冲区，而不是直接写入文件。同样，当程序从文件读取数据时，数据先从文件读取到缓冲区，然后再从缓冲区提供给程序使用。例如，在C语言中，使用<code>stdio.h</code>库函数（如<code>fprintf</code>、<code>fscanf</code>等）进行文件操作时，会涉及文件缓冲区。其目的是减少对文件的实际读写次数，提高读写效率。因为文件的读写操作通常比内存操作慢很多，通过缓冲区可以批量处理数据。</li>
</ul>
</li>
<li><strong>文件的页缓冲区（页缓存）</strong>：<ul>
<li>页缓冲区主要是操作系统层面的概念。在操作系统中，文件是以页为单位存储在磁盘上的，页缓冲区是内存中的一块区域，用于缓存从磁盘读取的文件页。当程序请求读取文件中的某个部分时，如果该部分对应的页已经在页缓冲区中，就可以直接从内存中获取，而不必从磁盘读取，大大提高了文件访问速度。同时，对于要写入磁盘的文件数据，也会先暂存在页缓冲区，等合适的时候再写入磁盘，这是一种以页为单位的缓存机制，通常由操作系统的内存管理子系统和文件系统协同管理。</li>
</ul>
</li>
</ul>
</li>
<li><strong>区别</strong><ul>
<li><strong>管理层面和单位不同</strong>：<ul>
<li>文件缓冲区通常是在应用程序层面进行管理，以字节流等方式来组织和处理数据。例如，C语言中的文件缓冲区，程序员可以通过<code>fflush</code>函数手动刷新缓冲区，将缓冲区中的数据写入文件。它的大小可以在一定程度上由应用程序控制，比如通过<code>setvbuf</code>函数设置缓冲区大小。</li>
<li>文件的页缓冲区是由操作系统管理的，是以页为单位（通常页的大小是固定的，如4KB等）。操作系统负责维护页缓冲区中的数据与磁盘文件数据的一致性，应用程序一般不能直接控制页缓冲区的具体操作，如替换策略等。</li>
</ul>
</li>
<li><strong>数据范围和用途不同</strong>：<ul>
<li>文件缓冲区主要是为了优化单个应用程序对文件的读写操作。例如，一个文本编辑器在保存文件时，会先将用户输入的字符存入文件缓冲区，直到缓冲区满或者用户手动保存，才会将缓冲区中的内容写入文件。</li>
<li>文件的页缓冲区是为了提高整个系统对文件的访问效率。它缓存的是文件在磁盘上的页，这些页可能被多个应用程序共享访问。例如，不同的进程可能都需要读取同一个配置文件的部分内容，这些内容所在的页就可能被缓存在页缓冲区中供多个进程使用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>联系</strong><ul>
<li><strong>协同工作提高性能</strong>：<ul>
<li>两者都是为了提高文件操作的效率。文件缓冲区中的数据最终可能会通过系统调用传递到页缓冲区，然后再写入磁盘。例如，当应用程序调用<code>fwrite</code>函数将数据写入文件时，数据先进入文件缓冲区，当文件缓冲区被刷新或者满了之后，数据会通过操作系统的文件写入机制进入页缓冲区（如果数据对应的磁盘文件页不在页缓冲区中），最后再写入磁盘。它们在数据从应用程序到磁盘存储的过程中起到了层层缓冲的作用，减少了频繁的磁盘I&#x2F;O操作。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h2><p>当使用ls -l命令时，会看到类似下图的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 654 &quot;11月 9 13:06&quot; chengzi.c</span><br></pre></td></tr></table></figure>
<p>从左到右，分别是：模式，硬链接数，文件所有者，组，大小，最后修改时间。inode是文件系统中的数据结构，包含着文件的属性信息。<br>硬链接（Hard Links）指一个文件可以有<code>多个文件名指向同一个inode</code>。inode作为文件系统中的数据结构，包含了文件的元数据（比如权限、所有者、文件大小等）以及指向实际数据块的指针。<br>所有硬链接文件都指向同一个inode，因此它们实际上共享相同的数据块。<br>删除任意一个硬链接并不影响其他硬链接，只有当所有链接都被删除时，inode的<code>引用计数</code>才会变为零，文件系统才会释放相关的数据块。<br>但硬链接也有自己的缺点，硬链接不能跨越文件系统，只能在同一文件系统内创建。也<code>不能对目录创建硬链接</code>。<br>不能对目录创建硬链接的主要原因是防止文件系统的树形结构出现<code>循环</code>。<br>举个例子：你在目录a下查找文件b，但同时目录a中存在目录c，目录c是指向目录a的硬链接，这会导致什么后果？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/user</span><br><span class="line">|-- a</span><br><span class="line">|   |-- directory_c (硬链接到 /home/user/a)</span><br><span class="line">  其他文件或目录</span><br><span class="line">|   |-- file_b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;home&#x2F;user&#x2F;b&#x2F;directory_c 和 &#x2F;home&#x2F;user&#x2F;a 实际上指向同一个目录，这就导致了在进行遍历查找时，可能会陷入循环的问题。</p>
<p>创建硬链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln source_file hard_link_name</span><br></pre></td></tr></table></figure>

<p><code>空</code>的文件夹引用计数是<code>2</code>。但空的文件夹其实并不是空的， 其中含有两个隐藏的文件.和..。这两个文件分别指向了本目录和上层目录，都是硬链接。如果一个目录引用计数是17，那就代表这个目录下还有15个子目录。</p>
<p>与硬链接相对应的就是软链接。<br>软链接可以类比成windows系统下的<code>快捷方式</code>。<br>软链接是一种特殊类型的文件(所以他有自己的inode)，它创建一个指向另一个文件或目录的符号链接。软链接类似于快捷方式，它只包含目标文件的<code>路径信息</code>，而不是实际的数据。如果源文件或目录被删除或移动，软链接将失效。</p>
<p>创建软链接:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /path/to/source /path/to/symlink</span><br></pre></td></tr></table></figure>







</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" title="头像" alt="头像"></a><div class="post-copyright__author_name">chengzi</div><div class="post-copyright__author_desc">个人博客</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/12/18/linux-file%20system/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/12/18/linux-file%20system/')">IO与文件系统</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/12/18/linux-file%20system/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=IO与文件系统&amp;url=http://example.com/2024/12/18/linux-file%20system/&amp;pic=https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734494164320.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>文件系统<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/IO/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>IO<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1740279920116.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/15/cpp-priority_queue/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734239881472.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">优先级队列的简单模拟实现</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/25/linux-Process%20communication/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1740279920116.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">基于Linux的进程通信</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">本博客记载<b style="color:#fff">开发，算法等</b>相关内容，还有<b style="color:#fff">雅思学习</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">希望你在这里能得到有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">chengzi</h1><div class="author-info__desc">个人博客</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/chengzi516" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BEc%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">回顾c语言的文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">相关接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.2.</span> <span class="toc-text">c语言的输入输出流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">linux下的文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6io"><span class="toc-number">2.1.</span> <span class="toc-text">系统文件io</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.</span> <span class="toc-text">四个常用接口介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.4.</span> <span class="toc-text">缓冲区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">linux如何管理文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">3.3.</span> <span class="toc-text">软硬链接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/22/test-blog/" title="博客项目测试文档"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1740280088679.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客项目测试文档"/></a><div class="content"><a class="title" href="/2025/02/22/test-blog/" title="博客项目测试文档">博客项目测试文档</a><time datetime="2025-02-22T07:41:10.000Z" title="Created 2025-02-22 15:41:10">2025-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/25/linux-Process%20communication/" title="基于Linux的进程通信"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1740279920116.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Linux的进程通信"/></a><div class="content"><a class="title" href="/2024/12/25/linux-Process%20communication/" title="基于Linux的进程通信">基于Linux的进程通信</a><time datetime="2024-12-25T07:26:01.000Z" title="Created 2024-12-25 15:26:01">2024-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/18/linux-file%20system/" title="IO与文件系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734494164320.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IO与文件系统"/></a><div class="content"><a class="title" href="/2024/12/18/linux-file%20system/" title="IO与文件系统">IO与文件系统</a><time datetime="2024-12-18T03:54:29.000Z" title="Created 2024-12-18 11:54:29">2024-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/15/cpp-priority_queue/" title="优先级队列的简单模拟实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734239881472.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优先级队列的简单模拟实现"/></a><div class="content"><a class="title" href="/2024/12/15/cpp-priority_queue/" title="优先级队列的简单模拟实现">优先级队列的简单模拟实现</a><time datetime="2024-12-15T05:15:03.000Z" title="Created 2024-12-15 13:15:03">2024-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/15/cpp-list%20implement/" title="List的简单模拟实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%5Blab.magiconch.com%5D%5B%E7%A6%8F%E9%9F%B3%E6%88%B0%E5%A3%AB%E6%A8%99%E9%A1%8C%E7%94%9F%E6%88%90%E5%99%A8%5D-1734227595729.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="List的简单模拟实现"/></a><div class="content"><a class="title" href="/2024/12/15/cpp-list%20implement/" title="List的简单模拟实现">List的简单模拟实现</a><time datetime="2024-12-15T00:41:28.000Z" title="Created 2024-12-15 08:41:28">2024-12-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:p772307283@outlook.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/IMG_1561-VEED.gif" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/chengzi516" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div><div class="copyright">&copy;2023 - 2025 By chengzi</div><div id="workboard"><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a></p></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">29</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/null" title="demo"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="project" alt="demo"/><span class="back-menu-item-text">demo</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/IO/" style="font-size: 0.88rem;">IO<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>1</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c++<sup>11</sup></a><a href="/tags/list/" style="font-size: 0.88rem;">list<sup>1</sup></a><a href="/tags/makefile/" style="font-size: 0.88rem;">makefile<sup>1</sup></a><a href="/tags/queue/" style="font-size: 0.88rem;">queue<sup>1</sup></a><a href="/tags/string/" style="font-size: 0.88rem;">string<sup>1</sup></a><a href="/tags/vector/" style="font-size: 0.88rem;">vector<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" style="font-size: 0.88rem;">内存对齐<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/" style="font-size: 0.88rem;">函数重载<sup>1</sup></a><a href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/" style="font-size: 0.88rem;">初始化列表<sup>1</sup></a><a href="/tags/%E5%8F%8B%E5%85%83/" style="font-size: 0.88rem;">友元<sup>1</sup></a><a href="/tags/%E5%A4%9A%E6%80%81/" style="font-size: 0.88rem;">多态<sup>1</sup></a><a href="/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/" style="font-size: 0.88rem;">大小端<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">对象<sup>2</sup></a><a href="/tags/%E5%BC%95%E7%94%A8/" style="font-size: 0.88rem;">引用<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>4</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">文件系统<sup>1</sup></a><a href="/tags/%E6%98%93%E9%94%99%E7%82%B9/" style="font-size: 0.88rem;">易错点<sup>1</sup></a><a href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" style="font-size: 0.88rem;">碎碎念<sup>1</sup></a><a href="/tags/%E7%A7%91%E6%8A%80/" style="font-size: 0.88rem;">科技<sup>1</sup></a><a href="/tags/%E7%B1%BB/" style="font-size: 0.88rem;">类<sup>2</sup></a><a href="/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%BA%BA2024/" style="font-size: 0.88rem;">经济学人2024<sup>1</sup></a><a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 0.88rem;">继承<sup>1</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 0.88rem;">编译<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">软件测试<sup>1</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 0.88rem;">进程<sup>3</sup></a><a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 0.88rem;">通信<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="5094069883" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=5094069883&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("10/26/2024 12:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 chengzi 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("10/26/2024 12:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>